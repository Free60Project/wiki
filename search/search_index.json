{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Free60.org Wiki","text":"<p>Welcome to the archive of Free60.org Mediawiki.</p> <p>To submit changes:</p> <ol> <li> <p>Fork the repo</p> </li> <li> <p>Make changes</p> </li> <li> <p>Send a Pull Request</p> </li> </ol> <p>Join us on IRC or Discord!</p>"},{"location":"#categories","title":"Categories","text":"<p>Xbox 360 Hardware Xbox 360 System Software</p> <p>Xbox 360 Homebrew Software Xbox 360 Linux Xbox 360 Development</p> <p>Support</p> <p>Pages with missing images Template documentation</p>"},{"location":"#to-do","title":"To-do","text":"<p>TODO</p>"},{"location":"#index","title":"Index","text":"Generic Hardware Software Attack 8051 8052 1bl Code Boot Process CPU 360FlashTool Contribute Case 849x System Update Error Codes Chatpad Bootloader FAQ DVD Drive CB Code Dump Flash the NAND Toolchain Ethernet Console Security Certificate Falcon Cross Compiler Finding the right timing Dashboard Flash Debian-etch Fusesets Debian-lenny GamePad Debian-squeeze Gamepad Keyboard Dumpana GPU HDD Emulators Harddrive FATX Headset Motherboard Flash Filesystem Jasper GDFX Level Shifter GPD <p>Free60 Git Repository</p> <p>Generic Xbox 360 File Container</p> <p>Genesis Plus</p> <p>Help</p> <p>Histogram</p> <p>Homebrew Games</p> <p>Homebrew Launchers</p> <p>Homebrew Repository</p> <p>HvxExpansionInstall</p> <p>HvxKeysExecute</p> <p>HvxPostOutput</p> <p>Hypervisor</p> <p>Hypervisor (Old Notes)</p> <p>IRC</p> <p>Kernel</p> <p>Kernel Exports</p> <p>King Kong Hack</p> <p>Launchers</p> <p>Lflash</p> <p>LibHomebrew</p> <p>LibXenon</p> <p>LibXenon Examples</p> <p>Lib Homebrew</p> <p>Libraries</p> <p>Libxenonexamples</p> <p>Links</p> <p>Linux Bootloader</p> <p>Linux Distributions</p> <p>Linux Distros</p> <p>Linux Kernel</p> <p>Linux Kernel Development</p> <p>List of PC utilities</p> <p>List of Unix Distributions</p> <p>List of all homebrew</p> <p>List of development tools</p> <p>List of homebrew applications</p> <p>List of homebrew emulators</p> <p>List of homebrew games</p> <p>List of homebrew loaders</p> <p>List of system tools</p> <p>LiveCD</p> <p>Mainboard</p> <p>Media Remote</p> <p>Memory</p> <p>Memory MAP</p> <p>Memory Unit</p> <p>Modesetting</p> <p>Mupen64-360</p> <p>NAND</p> <p>NAND: Bad Blocks</p> <p>NANDPro</p> <p>NAND File System</p> <p>NAND Reading</p> <p>NFS Root</p> <p>NandCompare</p> <p>Northbridge</p> <p>Old Main Page</p> <p>Opus</p> <p>Other OS Loader</p> <p>PCSXR-Xenon</p> <p>PC Software</p> <p>PEC</p> <p>POST</p> <p>Pin Headers</p> <p>Play and Charge Kit</p> <p>Pong</p> <p>Pre-release differences</p> <p>Profile: Account</p> <p>R6T3</p> <p>README</p> <p>RF Module</p> <p>Rawflash</p> <p>Reading Out nand</p> <p>Reset Glitch Hack</p> <p>Reversing the bootloaders</p> <p>Run Code</p> <p>SDLQuake</p> <p>SFCX</p> <p>SMBus Controller</p> <p>SMC</p> <p>SMC Command 0x01</p> <p>SMC Command 0x82</p> <p>SMC Hack</p> <p>SMS Plus</p> <p>SPA</p> <p>SPI</p> <p>SPI Programmer</p> <p>STFS</p> <p>Sandbox</p> <p>Secure Transacted File System</p> <p>Sega Genesis Plus GX</p> <p>Sega Master System Plus</p> <p>Serial Console</p> <p>Shadowboot</p> <p>Snes9x-Gx</p> <p>Southbridge</p> <p>Starting Homebrew Development</p> <p>Stereo DAC</p> <p>System Calls</p> <p>Tanks 360</p> <p>Timing Attack</p> <p>Toolchain</p> <p>Trinity</p> <p>UART</p> <p>USB</p> <p>Ubuntu</p> <p>Ubuntu 11.10</p> <p>Ubuntu 7.10</p> <p>Utilities</p> <p>Valhalla</p> <p>Webcam</p> <p>Wifi Adapter</p> <p>XCP</p> <p>XConfig</p> <p>XContent</p> <p>XDBF</p> <p>XDK Kernel</p> <p>XEX</p> <p>XMENU</p> <p>XMPlayer</p> <p>XTAF</p> <p>Xbox 360 Motherboards</p> <p>Xbox Revision Identification</p> <p>Xbox Revisions</p> <p>Xbox Software</p> <p>Xbox System Software</p> <p>XeLL</p> <p>XeLL Reloaded</p> <p>XeLLous</p> <p>Xenon</p> <p>Xenon (CPU)</p> <p>Xenon (Motherboard)</p> <p>Xenon Toolchain</p> <p>Xenos</p> <p>Xenos (GPU)</p> <p>Xenos Framebuffer</p> <p>ZLX Browser</p> <p>Zephyr</p>"},{"location":"%21Pages_That_Need_Updates/","title":"Pages That Need Updates","text":"<p>Some pages need edits to remain useful or become more beautiful.</p> <ul> <li>STFS needs the base sequence written up</li> <li>halotroop2288 is working on this!</li> <li>https://github.com/halotroop2288/kaitai_struct_formats/blob/pr/xbox/filesystem/stfs.ksy</li> <li>XCP needs a full file format spec written up for it.</li> <li>halotroop2288 is working on this!</li> <li>https://gitlab.com/0x8081/libxcp/-/blob/main/src/xcp.h</li> <li>https://gitlab.com/0x8081/libxcp/-/blob/main/src/xcp.c</li> <li>XConfig's spec (Notes section) should be converted to a markdown table.</li> </ul>"},{"location":"%21Pages_with_missing_images/","title":"Pages with missing images","text":"<ul> <li>DVD Drive</li> <li>NAND \"Atmel2.jpg\"</li> <li>Wifi Adapter</li> </ul>"},{"location":"%21TODO/","title":"TODO - Broken links, comments etc.","text":"<p>Attack.md 109 perhabs link to early version of Boot_Process.md</p> <p>Attack.md 242-252 things from the website</p> <p>Debian-etch.md 24 newer version?</p> <p>Debian-etch.md 47 no archive in the waybackmachine, other source?</p> <p>Debian-etch.md 85 newer version? other source than waybackmachine?</p> <p>Debian-etch.md 88 newer version? other source than waybackmachine?</p> <p>Debian-lenny.md 17 newer version? other source than waybackmachine?</p> <p>Debian-lenny.md 21 newer version? other source than waybackmachine?</p> <p>Debian-lenny.md 49 version not available</p> <p>Debian-lenny.md 56 change to mirrors.kernel.org/debian/ ; dont think the command will work (missing files at the server)</p> <p>Debian-lenny.md 86 no archive in the waybackmachine, other source?</p> <p>Debian-lenny.md 89 newer version? other source than waybackmachine?</p> <p>Debian-squeeze.md 62 version not available</p> <p>Debian-squeeze.md 68 change to mirrors.kernel.org/debian/ ; dont think the command will work (missing files at the server)</p> <p>EEProm.md 154 i cant load the page; repleace with waybackmachine?</p> <p>Error_Codes.md 2 No Picture in ./images</p> <p>Genesis_Plus.md 3 no archive in the waybackmachine, other source?</p> <p>HDD.md 105 no archive in the waybackmachine, other source?</p> <p>HDD.md 111 i cant load the page; repleace with waybackmachine?</p> <p>HDD.md 115 i cant load the page; repleace with waybackmachine?</p> <p>Help.md 18 below</p> <p>Help.md 21 broken category link</p> <p>Help.md 24 free60.org/old not available</p> <p>King_Kong_Hack.md 41 no archive in the waybackmachine, other source?</p> <p>King_Kong_Hack.md 77 no archive in the waybackmachine, other source?</p> <p>LibXenon_Examples.md 1 below</p> <p>LibXenon_Examples.md 7 below</p> <p>LibXenon_Examples.md 12 removed User link (User:cpasjuste)</p> <p>LibXenon_Examples.md 4 below</p> <p>LibXenon_Examples.md 14 not in the file.libxenon.org repository</p> <p>LibXenon_Examples.md 8-9 no archive in the waybackmachine, other source?</p> <p>Links.md 4 perhaps not safe</p> <p>Links.md 20 no archive in the waybackmachine, other source?</p> <p>Links.md 26 not all pictures (archive.org)</p> <p>Linux_Kernel.md 63 file missing, but folder is there?</p> <p>List_of_development_tools.md 32-34 repository missing?</p> <p>Memory_Unit.md 69 something is broken (redirect to start page of waybackmachine)</p> <p>Motherboard.md 34 lost reference (wikipedia)</p> <p>NAND_Bad_Blocks.md 280 no useable archive in the waybackmachine, other source?</p> <p>NAND_Reading.md 113 no archive in the waybackmachine, other source?</p> <p>NAND_Reading.md 739 no archive in the waybackmachine, other source?</p> <p>NAND.md 111 below</p> <p>NAND.md 113 below</p> <p>NAND.md 117 no archive in the waybackmachine, other source?</p> <p>NAND.md 115 Waybackmachine infinte loop?!?</p> <p>NAND.md 210 no archive in the waybackmachine, other source?</p> <p>Old_Main_Page.md 49 at the end: Press_Release_2007-05-08</p> <p>PC_Software.md 11 newer version?</p> <p>PC_Software.md 35 newer version?</p> <p>PC_Software.md 44 newer version?</p> <p>R6T3.md 72 no archive in the waybackmachine, other source?</p> <p>Sega_Master_System_Plus.md 3 no archive in the waybackmachine, other source?</p> <p>SMBus_Controller.md 118 i cant load the page; repleace with waybackmachine?</p> <p>SMC_Hack.md 19 dont know where to link</p> <p>SMC_Hack.md 78 dont know where to link</p> <p>STFS.md 504 not avaiable (perhaps waybackmachine)</p> <p>STFS.md 512 i cant load the page; repleace with waybackmachine?</p> <p>Timing_Attack.md 229 below</p> <p>Timing_Attack.md 233 below</p> <p>Timing_Attack.md 238 below</p> <p>Timing_Attack.md 241 below</p> <p>Timing_Attack.md 246 below</p> <p>Timing_Attack.md 255 \"anchor\" broken</p> <p>Ubuntu11_10.md 68 below</p> <p>Ubuntu11_10.md 84 below</p> <p>Ubuntu11_10.md 85 below</p> <p>Ubuntu11_10.md 87 below</p> <p>Ubuntu11_10.md 88 below</p> <p>Ubuntu11_10.md 89 below</p> <p>Ubuntu11_10.md 91-94 dont think the command will work </p> <p>Utilities.md 9 below</p> <p>Utilities.md 18 dead link</p> <p>Wifi_Adapter.md 3 below</p> <p>Wifi_Adapter.md 20 below</p> <p>Wifi_Adapter.md 29 missing pictures from free60</p> <p>Wifi_Adapter.md 65 no archive in the waybackmachine, other source?</p> <p>Xbox_Revision_Identification.md 2612 i cant load the page; repleace with waybackmachine?</p> <p>Xenon_(CPU).md 63 http://www.ibm.com/developerworks/library/pa-soc1/ and other ibm links should be repleaced with newer version</p> <p>Xenon_Toolchain.md 106 Use of updated version?</p> <p>XEX.md 230 no archive in the waybackmachine, other source?</p> <p>849x_System_Update.md 10-12 update free60 links?</p>"},{"location":"Category_Template_documentation/","title":"Category: Template documentation","text":"<p>Old Main Page</p> <p>Other OS Loader</p>"},{"location":"Hypervisor/","title":"Hypervisor","text":""},{"location":"Hypervisor/#note","title":"Note","text":"<p>Old notes on the Xbox 360 Hypervisor can be found here: Hypervisor (Old Notes)</p>"},{"location":"Hypervisor/#what-is-a-hypervisor","title":"What is a Hypervisor?","text":"<p>Like in the PS3, Microsoft protects the integrity of its system with a Hypervisor. Using the virtualization technologies of today's processors, a hypervisor can act as a small piece of code with even higher privileges than the more complex operating system. In theory, even potential flaws in the operating system cannot be exploited since the hypervisor puts up additional restrictions.</p> <p>In case of the Xbox 360, the hypervisor is responsible for encryption, decryption and the enforcement of access restrictions on memory.</p> <p>Thanks to the work of an anonymous hacker, a flaw in the hypervisor has been discovered on certain versions of the Xbox 360 kernel, allowing the injection of code, which has not been cryptographically signed by Microsoft.</p>"},{"location":"Hypervisor/#how-it-works","title":"How It Works","text":"<p>The Hypervisor (HV) is primarily made up of a series of interrupt vectors and system calls that are accompanied by a few cryptography related helper sub-routines. On the 360, the main job of the HV is to manage the security of the system and handle encryption/crypto-signatures of files that will be run. Because of this, the HV is only executed in Real-Mode, with the highest privileges. Memory paging is disabled and the HV can access any memory space on the system, including memory mapped devices, however code run from user-mode (normal mode) cannot read or write to HV space. It is essential to understand how the HV works to understand the lower level of software on the xbox 360.</p> <p>When an interrupt is generated by the CPU, it jumps to the corresponding handler. When this occurs, the address of the instruction that generated the interrupt is stored in SRR0 and the MSR before the interrupt occurred is stored in SRR1 with bits 33-36 and bits 42-47 loaded with data specific to the interrupt. For every interrupt, the CPU is sent into Real Mode/privileged state, interrupts are the entrance to the HV. Instruction and data relocation is disabled at this time.</p> <p>When a return from interrupt (rfid) instruction occurs, it copies SRR1 to the MSR, synchronizes context, and jumps to the address stored in SRR0. Unless the Interrupt modified the contents of SRR1, the program will exit privileged state after the MSR is set.</p> <p>All interrupts are ordered meaning while one is being handled, the CPU will wait until it is finished before handling another. The exception to this is the RESET and MACHINE_CHECK interrupts, these are unorded and can take place at any time. If they occur while another interrupt is being handled, SRR0 and SRR1 will be overwritten by the new handler and context synchronization will be lost. During normal operation of the Xbox 360, the RESET interrupt does not occur and the MACHINE_CHECK interrupt is not recoverable.</p>"},{"location":"Hypervisor/#interrupt-vectors","title":"Interrupt Vectors","text":"Vectors Offset 0x00000100 0x00000200 0x00000218 0x00000300 0x00000380 0x00000400 0x00000480 0x00000500 0x00000600 0x00000700 0x00000800 0x00000900 0x00000980 0x00000B9C 0x00000C00 0x00000D00 0x00000A5C 0x00000F20 0x00001600 0x00001700 0x00001800"},{"location":"Hypervisor/#cryptography","title":"Cryptography","text":"<p>Retail 17511 - These offsets are subject to change!</p> Cryptography Functions Offset 0x00020300 0x00023500 0x000226F0 0x00022738 0x00020520 0x0000A880 0x0000AD20 0x00022DB8 0x00022BD0 0x00022CF0 0x00023170 0x00023218 0x00020578 0x00020F00 0x00021210 0x00020EC8 0x000244D8 0x00024560 0x000211F0 0x00024AF0 0x00024A40 0x00024A98 0x000247D0 0x00020910 0x00024C68 0x00023108 0x00022E98 0x00023010 0x00023060 0x000200F8 0x00023008 0x00021128 0x00020D28 0x000211A8 0x00021240 0x00021840 0x00021BC8 0x000217C0 0x00021968 0x00021710 0x00021270 0x00021C08 0x00023278 0x00023330 0x00020550 0x00020250 0x00020468 0x000203A8 0x00024420 0x00020680 0x00000E14"},{"location":"Hypervisor/#utility-functions","title":"Utility Functions","text":"Utility Functions Offset 0x00000384 0x00000398 0x000003C4 0x00000484 0x000004A8 0x000004D8 0x0000068C 0x000006A0 0x000006B4 0x000006CC 0x00000E14 0x00000EE4 0x00001804 0x000029E0 0x00003358 0x000033D8 0x00003620 0x00000000"},{"location":"Hypervisor/#invoking-the-hypervisor","title":"Invoking The Hypervisor","text":"<p>User-mode code can invoke the Hypervisor at any time through what is called a system call(syscall). System calls are functions set up by the Hypervisor that can preform various tasks on the system, for example getting the value of a special cpu register or printing to the console's post bus. When a system call is preformed, the cpu generates a syscall interrupt and jumps to the appropriate handler. System calls are described more here: System Calls</p>"},{"location":"Hypervisor_%28Old_Notes%29/","title":"Hypervisor (old notes)","text":"<p>no booting details known changes between beta hardware and final: alpha hardware = macintosh beta = ? looks like retail, but no encryption second beta =! retail</p> <p>tried to dump RAM could only dump virtual memory ram is at 8000_0000 southbridge: pci config space, mapped to VM, accessible by user apps memory at bottom looks random/encrypted, might be hypervisor 256 KB</p> <p>8040_0000 xbox kernel starts, MZ header</p> <p>read memory using debug interface: everything is in plaintext, you can read kernel + app (dashboard etc.), i.e. virtual memory is not encrypted</p> <p>kernel interesting to disassemble communication with hypervisor using syscalls</p> <p>hypervisor does interrupts/exceptions</p>"},{"location":"Hypervisor_%28Old_Notes%29/#syscalls","title":"Syscalls","text":"<pre><code>final:\n\nSC 00: GetVersionCode (e.g. r3=072F8002)\n\nSC 01: KeStartupProcessors\n\nSC 02: unknown KiQuiesce\n\nSC 03: KeFlushEntireTb\n\nSC 04: called in FlushMultipleTb\n\nSC 05: ??\n\nSC 06: KeGetSpecialPurposeRegister (r3=0x3F5)\n\nSC 07: KeSetSpecialPurposeRegister\n\nSC 08: KeGetSocRegister(r3=???)/KeGetPWMRegister(r3=60000)/\nKeGetPRVRegister(r3=61000)\n\nSC 09: KeSetSocRegister\n\nSC 0A: KeStartupProcessors\n\nSC 0B: called in ReserveKernelPtes\n\nSC 0C: called from MmAllocatePhysicalMemoryEx\n\nSC 0D: setAD16\n\nSC 0E: KeEnablePPUPerformanceMonitor\n\nSC 0F: called from MmGetPhysicalAddress\n\nSC 10: called from MmDbgReleaseAddress\n\nSC 11: XexpLoadFile calls it, seems to get privkey\n\nr4 = phys addr (of header?) offset: +8\n\nr5 = region\n\nr6 = ?? offset: +4\n\nr7 = ?? size?\n\nSC 12: called from MmAllocateImageMemory\n\nSC 13: called from MmAllocateImageMemory\n\nSC 14: called in XexpLoadFile\n\nSC 15: called in XexpLoadFile\n\nSC 16: called in XexpCompleteImageLoad\n\nSC 17: called in XexpCompleteImageLoad\n\nSC 18: called in XexpLoadFile, XexpCompleteImageLoad\n\nSC 19: unload?\n\nSC 1A: unload?\n\nSC 1B: unload?\n\nSC 1c: called on XexpTitleTerminateNotification\n\nSC 1d: KeCreateUserMode\n\nSC 1e: KeDeleteUserMode\n\nSC 1f: Flush TLB\n\nSC 20: set power\n\nSC 21: shadow boot\n\nSC 22: Burn fuses\n\nSC 23: FSB interrupt related\n\nSC 24: KeLockL2\n\nSC 25:\n\nSC 26\n\nSC 27\n\nSC 28\n\nSC 29\n\nSC 2A\n\nSC 2B\n\nSC 2C: SataCdRomHvVerifyLBA\n\nSC 2D\n\nSC 2E: XeKeysInitialize (r3, r4 = address)\n\nSC 2F: XeKeysGetKeyProperties\n\nSC 30: XeKeysGetStatus\n\nSC 31: XeKeysGenerateRandomKey\n\nSC 32: XeKeysGetFactoryChallenge\n\nSC 33: XeKeysSetFactoryResponse\n\nSC 34: XeKeysSaveBootLoader\n\nSC 35: XeKeysSaveKeyVault\n\nSC 36: XeKeysSetKey\n\nSC 37: XeKeysGetKey\n\nSC 38: XeKeysGetDigest\n\nSC 39: XeKeysQwNeRsaPrvCrypt\n\nSC 3D: XeKeysDesCbc. r6: address, r5: context\n\nSC 3F: XeKeysSaveSystemUpdate\n\nSC 40:\nXeKeysExecute\n</code></pre>"},{"location":"Hypervisor_%28Old_Notes%29/#sc-22-burn-fuses","title":"SC 22 (Burn fuses)","text":"<p>tested on 2 kernels</p> <p>first: SC \"access fuses\"</p> <p>second: \"burn fuses\"</p> <p>(rumour has it that this is used to make retail boxes out of debug boxes)</p> <p>memory management 0F/10: perhaps page table access code in hypervisor, all high level code in kernel</p> <p>you can't map memory as you like</p> <p>network adapter in the southbridge</p> <p>debug code dumps registers with names</p> <p>it is possible to dump physical memory using network adapter DMA accesses</p> <p>not perfect dump</p> <p>reading physical memory = encrypted</p> <p>data segments are not encrypted, but nearly all code segments</p> <p>older recovery cd (early 2005), worked on first beta developer kits, without security enabled:</p> <p>cd included kernel which included stuff that is encrypted in retail version</p> <p>includes hypervisor code! it is old, but...</p> <p>getspr: SC 6</p> <p>setspr: SC 7 -&gt; possible to see implementation of basic syscall handling</p> <p>function in hypervisor to chain-run a new kernel from the old kernel</p> <p>hypervisor: sign with private key etc.</p> <p>hypervisor can only do physical memory</p> <p>hashing: load into register base address, length, destination of hash buffer, call syscode, hypervisor will hash -&gt; attack: hash 1 byte, *itself*, -&gt; hangs</p> <p>hypervisor lies at 0 in VM and physical mem</p>"},{"location":"Modesetting/","title":"Modesetting","text":"<p>We know libxenon sets graphics modes by writing a complete Ana dump to Ana memory and writing some values to the GPU registers. The registers affected and the information that gets written is the following:</p> <pre><code>total_width,\u00a0hsync_offset,\u00a0real_active_width,\u00a0total_height,\nvsync_offset,\u00a0active_height,\u00a0width,\u00a0height,\n\nis_progressive\u00a0=\u00a00\u00a0for\u00a0non\u00a0progressive\u00a0modes,\u00a01\u00a0for\u00a0progressive\u00a0modes.\n\nrgb\u00a0=\u00a01,\u00a0only\u00a0declared\u00a0on\u00a0the\u00a0modes\u00a0used\u00a0through\u00a0VGA.\n\ncomposite_sync=1,\u00a0only\u00a0declared\u00a0on\u00a0the\u00a0PAL/NTSC\u00a0non\u00a0progressive\u00a0modes.\n\ninterlace_factor\u00a0is\u00a0set\u00a0to\u00a01\u00a0when\u00a0mode\u00a0is\u00a0progressive\u00a0and\u00a02\u00a0when\u00a0it\u00a0is\u00a0not.\n\nFB_BASE\u00a0is\u00a0a\u00a0constant\u00a0for\u00a0the\u00a0framebuffer\u00a0base\u00a0address\u00a0on\u00a0libxenon,\u00a0but\u00a0we\nget\u00a0different\u00a0addresses\u00a0on\u00a0the\u00a0GPU\u00a0dumps.\n</code></pre> <p>These are the addresses that get that variables written at some stage of the initialization, in the order libxenon write them. I have take out the addresses that get fixed values written. As you can see, some addresses get written more than one time on the initialization process. Following are the values of the GPU dumps we currently own. We need to find a way to know if these dumps are valid as some values differ drastically from what we can read on libxenon's xenos.c and, if they are valid, why the are not the values expected.</p> <pre><code>0x6000,\u00a0mode-&gt;total_width\u00a0-\u00a01\n\n1024x768:\u00a0\u00a00x0000053f\n1280x1024:\u00a00x00000697\n1280x720:\u00a0\u00a00x00000671\n1920x1080:\u00a00x0000081f\n\n0x6010,\u00a0mode-&gt;total_height\u00a0-\u00a01\n\n1024x768:\u00a0\u00a00x00000325\n1280x1024:\u00a00x00000429\n1280x720:\u00a0\u00a00x000002ed\n1920x1080:\u00a00x00000456\n\n0x6004,\u00a0(mode-&gt;hsync_offset\u00a0&lt;&lt;\u00a016)\u00a0|\u00a0(mode-&gt;real_active_width\u00a0+\u00a0mode-&gt;hsync_offset)\n\n1024x768:\u00a0\u00a00x00eb04eb\n1280x1024:\u00a00x01250625\n1280x720:\u00a0\u00a00x00c705c7\n1920x1080:\u00a00x002d07ad\n\n0x6014,\u00a0(mode-&gt;vsync_offset\u00a0&lt;&lt;\u00a016)\u00a0|\u00a0(mode-&gt;active_height\u00a0*\u00a0interlace_factor\u00a0+\u00a0mode-&gt;vsync_offset)\n\n1024x768:\u00a0\u00a00x00230323\n1280x1024:\u00a00x00290429\n1280x720:\u00a0\u00a00x001902e9\n1920x1080:\u00a00x001c0454\n\n0x6030,\u00a0mode-&gt;is_progressive\u00a0?\u00a00\u00a0:\u00a01\n\nIt\u00a0is\u00a00x00000000\u00a0on\u00a0all\u00a0the\u00a0dumps.\n\n0x6120,\u00a0mode-&gt;width\n\nThis\u00a0address\u00a0gets\u00a0rewritten\u00a0later.\n\n0x6134,\u00a0mode-&gt;width\n\n1024x768:\u00a0\u00a00x000003c0\n1280x1024:\u00a00x000003c0\n1280x720:\u00a0\u00a00x00000500\n1920x1080:\u00a00x00000360\n\n0x6138,\u00a0mode-&gt;active_height\u00a0*\u00a0interlace_factor\n\nThis\u00a0address\u00a0gets\u00a0rewritten\u00a0later.\n\n0x6110,\u00a0FB_BASE\n\n1024x768:\u00a0\u00a00x1f78e000\n1280x1024:\u00a00x1f78e000\n1280x720:\u00a0\u00a00x1f6a8000\n1920x1080:\u00a00x01c5b000\n\n0x6120,\u00a0mode-&gt;width\n\n1024x768:\u00a0\u00a00x000003c0\n1280x1024:\u00a00x000003c0\n1280x720:\u00a0\u00a00x00000500\n1920x1080:\u00a00x00000360\n\n0x2840,\u00a0FB_BASE\n\n0x2844,\u00a0mode-&gt;width\n\nI\u00a0don't\u00a0know\u00a0what\u00a0hardware\u00a0is\u00a0in\u00a0charge\u00a0on\u00a0this\u00a0memory\u00a0addresses\n\n0x6584,\u00a0(mode-&gt;width\u00a0&lt;&lt;\u00a016)\u00a0|\u00a0(mode-&gt;active_height\u00a0*\u00a0interlace_factor)\n\nThis\u00a0address\u00a0gets\u00a0rewritten\u00a0later.\n\n0x65e8,\u00a0(mode-&gt;width\u00a0&gt;&gt;\u00a02)\u00a0-\u00a01\n\nThis\u00a0address\u00a0gets\u00a0rewritten\u00a0later.\n\n0x6528,\u00a0mode-&gt;is_progressive\u00a0?\u00a00\u00a0:\u00a01\n\nIt\u00a0is\u00a00x00000000\u00a0on\u00a0all\u00a0the\u00a0dumps.\n\n0x6584,\u00a0(mode-&gt;width\u00a0&lt;&lt;\u00a016)\u00a0|\u00a0(mode-&gt;height\u00a0*\u00a0interlace_factor)\n\n1024x768:\u00a0\u00a00x040002d0\n1280x1024:\u00a00x040002d0\n1280x720:\u00a0\u00a00x050002d0\n1920x1080:\u00a00x035401e0\n\n0x65e8,\u00a0(mode-&gt;width\u00a0/\u00a04)\u00a0-\u00a01\n\n1024x768:\u00a0\u00a00x000000ff\n1280x1024:\u00a00x000000ff\n1280x720:\u00a0\u00a00x0000013f\n1920x1080:\u00a00x000000d4\n\n0x6434,\u00a0mode-&gt;width\n\nIt\u00a0is\u00a00x00000000\u00a0in\u00a0all\u00a0dumps\u00a0(!?)\n\n0x6138,\u00a0mode-&gt;height\u00a0*\u00a0interlace_factor\n\n1024x768:\u00a0\u00a00x000002d0\n1280x1024:\u00a00x000002d0\n1280x720:\u00a0\u00a00x000002d0\n1920x1080:\u00a00x000001e0\n</code></pre>"},{"location":"NFS_Root/","title":"NFS Root","text":"<p>This tutorial assumes that you already have XeLL and Xenon Toolchain.</p>"},{"location":"NFS_Root/#install-and-setup-a-nfs-server","title":"Install and Setup a NFS Server","text":"<p>To do this you may have to edit your kernel on your host machine to enable nfs. For Gentoo: Instructions. For Debian/Ubuntu: Instructions Your /etc/exports should look like this:</p> <p><code>/mnt/nfsroot\u00a0192.168.1.*(rw,no_root_squash,no_subtree_check,async)</code></p> <p>Change the IP scheme and path to fit your configuration.</p> <p>Make the /mnt/nfsroot directory and copy the image.squashfs (from a LiveCD) into it:</p> <p><code>mkdir\u00a0/mnt/nfsroot</code> <code>cp\u00a0image.squashfs\u00a0/mnt/nfsroot/</code></p> <p>Then extract the squashfs as root by doing:</p> <p><code>unsquashfs\u00a0image.squashfs</code></p> <p>Now copy everything from the squashfs-root folder to /mnt/nfsroot by typing:</p> <p><code>cd\u00a0/mnt/nfsroot/squashfs-root\u00a0&amp;&amp;\u00a0cp\u00a0*\u00a0-vaR\u00a0/mnt/nfsroot</code></p> <p>Alternative: Debootstrap a fresh powerpc system (debian/ubuntu) and use it as NFSroot.</p> <p>Let the nfs-share re-export with:</p> <p><code>exportfs\u00a0-ra</code></p>"},{"location":"NFS_Root/#compile-the-kernel-that-you-want-to-use","title":"Compile the kernel that you want to use","text":""},{"location":"NFS_Root/#get-the-kernel-sources","title":"Get the kernel sources","text":"<p>You can get them from kernel.org 2.6.38.8 at time of writing (in the future this might change)</p>"},{"location":"NFS_Root/#get-the-patches-and-the-kernel-config","title":"Get the patches and the kernel config","text":"<p>You can get them from here.</p> <p>NOTE: At the time of writing v0.11.1 was the latest. Make sure that your kernel config and your patch are the same version.</p>"},{"location":"NFS_Root/#extract-the-kernel","title":"Extract the kernel","text":"<p>With the following command:</p> <p><code>tar\u00a0-xvjf\u00a0linux-2.6.38.8.tar.bz2</code></p>"},{"location":"NFS_Root/#patch-the-kernel","title":"Patch the kernel","text":"<p>With the following commands:</p> <p><code>cd\u00a0linux-2.6.38.8</code> <code>#\u00a0assumes\u00a0that\u00a0the\u00a0patch\u00a0is\u00a0in\u00a0the\u00a0directory\u00a0above\u00a0the\u00a0kernel\u00a0folder\u00a0that\u00a0you\u00a0just\u00a0changed\u00a0into</code> <code>patch\u00a0-p1\u00a0--dry-run\u00a0&lt;../patch-2.6.38.8-xbox0.11.1.diff</code> <code>#\u00a0if\u00a0the\u00a0dry-run\u00a0didn't\u00a0show\u00a0any\u00a0errors\u00a0do\u00a0the\u00a0following:</code> <code>patch\u00a0-p1\u00a0&lt;../patch-2.6.38.8-xbox0.11.1.diff</code></p>"},{"location":"NFS_Root/#copy-and-edit-the-kernel-config-file","title":"Copy and Edit the kernel config file","text":"<p>Copy the kernel config to the extracted linux-kernel folder:</p> <p><code>#\u00a0The\u00a0'.'\u00a0in\u00a0front\u00a0of\u00a0the\u00a0filename\u00a0is\u00a0there\u00a0on\u00a0purpose!</code> <code>cp\u00a0/path/to/xenon-config\u00a0/path/to/extracted/linux-2.6.38.8/.config</code></p> <p>Look for a line similar to this:</p> <p><code>CONFIG_CMDLINE=\"root=/dev/nfs\u00a0video=xenonfb\u00a0nfsroot=192.168.1.100:/mnt/nfsroot\u00a0rw\u00a0ip=dhcp\u00a0panic=60\"</code></p> <p>Edit the NFSroot to be your IP address and adjust the path correctly.</p> <p>Alternative: Use kboot.conf to pass a custom CMDLINE to the Server. If you want to do this you set:</p> <p><code>CONFIG_CMDLINE_BOOL=n</code> <code>CONFIG_CMDLINE=n</code></p>"},{"location":"NFS_Root/#build-the-kernel","title":"Build the kernel","text":"<p>Do the following:</p> <p><code>make\u00a0ARCH=powerpc\u00a0CROSS_COMPILE=xenon-\u00a0menuconfig</code></p> <p>Load up your config file that you just edited and then exit and run the following command:</p> <p><code>make\u00a0ARCH=powerpc\u00a0CROSS_COMPILE=xenon-\u00a0all</code></p> <p>You might get an error if so you might need to edit arch/powerpc/kernel/pci_64.c line 149 and change the lh to llh both occurrences.</p> <p>Rerun the last command and you should have a kernel. It will be in arch/powerpc/boot/zImage.xenon</p>"},{"location":"NFS_Root/#configure-xell-to-boot-from-your-computer-via-tftp","title":"Configure Xell to boot from your computer via tftp","text":"<p>To do this you need to recompile Xell. I assume that you already have a toolchain, I used the one from libxenon. You will need to edit the Xell source file network.c changing the default IP address to your IP address. Then compile Xell.</p>"},{"location":"NFS_Root/#setup-tftp","title":"Setup tftp","text":"<p>For Gentoo and 'atftpd' just type:</p> <p><code>emerge\u00a0-v\u00a0atftp</code></p> <p>Then edit the atftp config file:</p> <p><code>nano\u00a0/etc/conf.d/atftp</code></p> <p>I changed mine to look like this:</p> <p><code>TFTPD_ROOT=\"/tftpboot\"</code></p> <p>just edit this line and leave the rest the way it is as it is already correct.</p> <p>For Debian/Ubuntu use the following: Instructions (Sections: Set up DHCP server and Setup a TFTP server</p> <p>When done with that make the matching tftp directory (if it doesn't exist already) and put your linux-kernel into it, rename it xenon.</p> <p>NOTE: XeLL assumes a path like /tftpboot/xenon in its standard configuration. If your tftp-daemon has a path like /var/lib/tftpboot/ set up you need to make a subdir tftpboot in there. Final path would look like:</p> <p><code>/var/lib/tftpboot/tftpboot/</code></p> <p>Now if everything worked correctly you should be able to boot your 360 via NFS.</p> <p>NOTE: It's recommended that the TFTP-Server is the one who serves the DHCP Responses and no other DHCP Server is in your network so XeLL can find the TFTP Server Adress.</p> <p>NOTE(2): it is also possible to do this without a (linux) dhcpd server setup, using a router if you have a router that supports it (ddwrt, cisco, possibly some residential grade routers) by forwarding all tftp requests to your tftp server.</p> <p>for ddwrt: enable DNSmasq</p> <p><code>Go\u00a0to\u00a0your\u00a0Web-Interface\u00a0and\u00a0log\u00a0in</code> <code>Go\u00a0to\u00a0Setup-&gt;Basic\u00a0Setup</code> <code>Make\u00a0sure\u00a0that</code> <code>DHCP\u00a0Type\u00a0=\u00a0DHCP\u00a0Server</code> <code>DHCP\u00a0Server\u00a0=\u00a0Enable</code> <code>Use\u00a0DNSMasq\u00a0for\u00a0DHCP\u00a0=\u00a0Checked</code> <code>Use\u00a0DNSMasq\u00a0for\u00a0DNS\u00a0=\u00a0Checked</code></p> <p>Go to Administration-&gt;Services</p> <p><code>LAN\u00a0Domain\u00a0=</code> <code>DNSMasq\u00a0=\u00a0Enabled</code> <code>Local\u00a0DNS\u00a0=\u00a0Enabled</code> <p>in DNSmasq additional options:</p> <p><code>domain=lan-name-here</code> <code>local=/lan-name-here/</code> <code>expand-hosts</code> <code>dhcp-option=66,\"tftp-server-address-here\"</code></p> <p>Or edit /tmp/dnsmasq.conf with the correct settings (the above settings) adding cisco conf next</p>"},{"location":"Old_Main_Page/","title":"Old Main page","text":"<p>Free60 is a project towards porting GNU/Linux, BSD, Darwin and related open-source operating systems to the Microsoft Xbox 360 video game console.     - 3-core PowerPC, 3.2 GHz     - 512 MB of RAM     - ATI graphics     - (optional) 20 GB hard drive     - DVD drive     - 3x USB 2.0     - 100 MBit Ethernet     - TV/VGA support</p>"},{"location":"Old_Main_Page/#status","title":"Status","text":""},{"location":"Old_Main_Page/#run-code","title":"Run Code","text":"<p>You can run your own code on Xbox 360 systems with kernel versions 4532 and 4548. If you own a box manufactured before 2007, upgrade to one of these versions, but to no later one.</p>"},{"location":"Old_Main_Page/#linux-bootloader","title":"Linux Bootloader","text":"<p>A preliminary second-stage boot loader exists.</p>"},{"location":"Old_Main_Page/#linux-kernel","title":"Linux Kernel","text":"<p>Patches for the Linux kernel to support a large part of the Xbox 360 hardware exist. As long as you're waiting for a convenient way to boot, you can set up your cross compiler environment.</p>"},{"location":"Old_Main_Page/#linux-distributions","title":"Linux Distributions","text":"<p>Several LiveCD variants and installation howtos for Debian-etch, Ubuntu 7.04 and Ubuntu 7.10 are available.</p>"},{"location":"Old_Main_Page/#documentation","title":"Documentation","text":""},{"location":"Old_Main_Page/#first-steps","title":"First Steps","text":"<p>Try it out now</p> <p>How to test out linux (almost) without altering your system.</p>"},{"location":"Old_Main_Page/#hardware","title":"Hardware","text":"<ul> <li>CPU</li> <li>GPU</li> <li>R6T3</li> </ul>"},{"location":"Old_Main_Page/#software","title":"Software","text":"<ul> <li>Kernel</li> <li>Hypervisor</li> </ul>"},{"location":"Old_Main_Page/#misc","title":"Misc","text":"<ul> <li>Videos</li> <li>FAQ</li> </ul>"},{"location":"Old_Main_Page/#communication","title":"Communication","text":"<p>There are several ways for you to get in touch with the people behind Free60 and for sharing information between users. We are an open project and therefore explicitly invite anybody to contact us and to help.</p>"},{"location":"Old_Main_Page/#irc","title":"IRC","text":"<p>29 Sep 2007: 3D Acceleration work has started: tmbinc has released an initial version of his 'gpu' library. It does not yet follow a standard API (like OpenGL), but allows you to play with the 3D GPU.</p> <p>8 May 2007: Updated LiveCD ready: Stonersmurf mastered the updated LiveCD including the latest kernel patches. The Download is 621MB in size. See the Release Notes for details. Here is the Press Release</p> <p>1 May 2007: We now have a fix for Samsung users We will soon release an updated LiveCD. If you want to build your own kernel, see Linux Kernel Development for patches against linux-2.6.21.</p> <p>1 Apr 2007: X.org driver and a new LiveCD No April Fools' Day joke. We have released a preliminary X.org driver and Cpasjuste has built a new LiveCD which makes use of it. Unfortunately, support for Samsung drives and sound drivers are still missing.</p> <p>30 Mar 2007: Gentoo Minimal LiveCD Cpasjuste has combined the Kernel patches and latest Xell into a LiveCD. The download is about 90MB in size and since it uses the readcd boot method, you may soon be able to boot it without soldering a serial connection to your Xbox 360 mainboard.</p> <p>20 Mar 2007: Linux Bootloader available tmbinc has come up with a Linux Bootloader, which handles CPU initialization and loads the Linux Kernel either from network or CDROM.</p> <p>8 Mar 2007: First Linux patchset available Felix Domke posted a patchset for the Linux Kernel 2.6.20 Kernel to the Linux-PPC mailing list.</p> <p>1 Mar 2007: Hypervisor privilege-escalation vulnerability Some \"Anonymous Hacker\"; published a security advisory that will make it possible to run alternative operating systems on the Xbox 360.</p> <p>30 Dec 2006: Homebrew mock-up at 23C3 An \"Anonymous Hacker\" showed a Xbox 360 running unsigned code at 23C3 conference. See more in the Videos section.</p> <p>7 Mar 2006: CPU Datasheet More great work from [Speedy22] this time he has created a datasheet for the Xbox 360's CPU. It can be found here.</p> <p>Microsoft, Xbox, Xbox 360 (and probably some more) are registered trademarks by Microsoft Corp. No affiliation between the Free60 Project and Microsoft Corp. exists or is implied. All other trademarks and copyrights are property of their respective owners.</p> <p>Please note that all information on this website is for informational purpose only and is provided AS IS. Everything you do with this information is on your own risk.</p> <p>If you believe anything on this site violates any law or any of your rights, please contact us so that we can find a quick solution.</p> <p>Everything done on this project is for the sole purpose of writing interoperable software under Sect. 1201 (f) Reverse Engineering exception of the DMCA.</p> <p>Category:Template documentation</p>"},{"location":"Other_OS_Loader/","title":"Other OS Loader","text":"<p>The following has been written on April 1st, 2010. Happy April fool's day!</p> <p>In a leaked private e-mail to current Free60 project maintainer Georg Lukas, Microsoft Interactive Entertainment Business has stated to release a dashboard update for the Xbox 360 allowing to boot an \"Other OS\", similar to the functionality recently disabled in the PS3 by Sony:</p> <pre><code>From: xxx &lt;xxx@ieb.microsoft.com&gt;\nTo: Georg Lukas &lt;georg@op-co.de&gt;\nSubject: Loading other Operating Systems on the Xbox 360\n\nHello,\n\ndue to the recent policy change at Sony and the hacker attempts to patching our\nDashboard Software for illegal activities, we have decided to add a feature to\nthe Xbox 360 dashboard to allow booting other operating systems from USB media.\n\nThe \"Other OS\" feature will be run in a hypervisor VM context, restricting\nhardware access to the GPU and preventing the boot-up of a patched dashboard.\n\nWe would like to ask you for your help in choosing the minimum PCI memory ranges\nrequired for booting up and working with a Linux OS.\n\nPlease contact us ASAP, as we are planning to deploy this feature in the Summer\n2010 dashboard update.\n\nKind regards,\nXXX\n</code></pre> <p>Category: Template documentation</p>"},{"location":"POST/","title":"POST","text":"<p>During bootup the XBox 360 issues several POST Codes on a special 8-bit bus for diagnostic purposes.</p> <p>POST stands for power on self test. Its a bus created to help debug the xbox boot up process. In the bootloaders there is code that updates the number represented by the bus so it is possible to see at which point the bootloader is executing and where it hangs if an error occured.</p> <p>The reset glitch hack uses the post codes to track the progress of initialization and know when to assert the reset signal. In RGH1, it waits for when the second bootloader(CB) starts verifying the integrity check of the hash of the fourth bootloder(CD). When the bootloaders were updated starting on 14717, they removed the post codes from the bootloaders and added a few tricks like random delays to prevent glitchers from being able to tell when the xbox is checking the hash.</p>"},{"location":"POST/#pinout","title":"Pinout","text":"<p>On Phat consoles the pinout is as follows:</p> DBG_WN_POST_OUT0/BIT7 FT6U8 DBG_WN_POST_OUT1/BIT6 FT6U2 DBG_WN_POST_OUT2/BIT5 FT6U3 DBG_WN_POST_OUT3/BIT4 FT6U4 DBG_WN_POST_OUT4/BIT3 FT6U5 DBG_WN_POST_OUT5/BIT2 FT6U6 DBG_WN_POST_OUT6/BIT1 FT6U7 DBG_WN_POST_OUT7/BIT0 FT6U1 <p>Voltage levels are 1.2V for PHAT / 1.8V for SLIM</p>"},{"location":"POST/#reading-the-post-bus","title":"Reading the POST bus","text":"<p>The POST bus holds the last code's bits all the time. So we can read it with simple multimeter. To assemble bits to the byte, join them together like that (BIT ORDER 76543210):</p> <pre><code>For Example:\nbit7,bit6,bit5,bit4,bit3,bit2,bit1,bit0\n\n00111010 = 0x3A = CD auth success\n</code></pre>"},{"location":"POST/#writing-to-the-post-bus","title":"Writing to the POST Bus","text":"<p>Writing to the POST Bus is easy:</p> <p>Just write you 8 bit shifted by 56 Bit left to memory location 0x8000 0200 0006 1010:</p> <pre><code>; load address in r7\nli  %r7,0x200\noris  %r7,%r7,0x8000\nrldicr  %r7,%r7,32,31\nori %r7,%r7,0x1010\noris  %r7,%r7,6\n\n; write POST code\nli  %r3, 0x12\nrldicr  %r3, %r3, 56, 7\nstd %r3, 0(%r7)\n</code></pre> <p>The address is given in real mode, so you need to be careful when paging is enabled.</p>"},{"location":"POST/#meaning-of-different-post-codes","title":"Meaning of different POST Codes","text":"Domain Code Enum Description JTAG &amp; 0x10 Payload started RGH 0x11 Payload has copied XeLL to the RAM from NAND and executed it 1BL 0x10 - 1BL started 0x11 FSB_CONFIG_PHY_CONTROL Execute FSB function1 0x12 FSB_CONFIG_RX_STATE Execute FSB function2 0x13 FSB_CONFIG_TX_STATE Execute FSB function3 0x14 FSB_CONFIG_TX_CREDITS Execute FSB function4 0x15 FETCH_OFFSET Verify CB offset 0x16 FETCH_HEADER Copy CB header from NAND 0x17 VERIFY_HEADER Verify CB header 0x18 FETCH_CONTENTS Copy CB into protected SRAM 0x19 HMACSHA_COMPUTE Generate CB HMAC key 0x1A RC4_INITIALIZE Initialize CB RC4 decryption key 0x1B RC4_DECRYPT RC4 decrypt CB 0x1C SHA_COMPUTE Generate hash of CB for verification 0x1D SIG_VERIFY RSA signature check of CB hash 0x1E BRANCH Jump to CB 1BL 0x81 PANIC - MACHINE_CHECK Panics 0x82 PANIC - DATA_STORAGE 0x83 PANIC - DATA_SEGMENT 0x84 PANIC - INSTRUCTION_STORAGE 0x85 PANIC - INSTRUCTION_SEGMENT 0x86 PANIC - EXTERNAL 0x87 PANIC - ALIGNMENT 0x88 PANIC - PROGRAM 0x89 PANIC - FPU_UNAVAILABLE 0x8A PANIC - DECREMENTER 0x8B PANIC - HYPERVISOR_DECREMENTER 0x8C PANIC - SYSTEM_CALL 0x8D PANIC - TRACE 0x8E PANIC - VPU_UNAVAILABLE 0x8F PANIC - MAINTENANCE 0x90 PANIC - VMX_ASSIST 0x91 PANIC - THERMAL_MANAGEMENT 0x92 - 1BL is executed on wrong CPU thread (panic) 0x93 PANIC - TOO_MANY_CORES 1BL is executed on wrong CPU core (panic) 0x94 PANIC - VERIFY_OFFSET CB offset verification failed 0x95 PANIC - VERIFY_HEADER CB header verification failed 0x96 PANIC - SIG_VERIFY CB RSA signature verification failed 0x97 PANIC - NONHOST_RESUME_STATUS 0x98 PANIC - NEXT_STAGE_SIZE Size of next stage is out-of-bounds CB_A/2BL 0xD0 CB_A entry point, copy self to 0x8000.0200.0001.C000 and continue from there (Slim 0xD1 READ_FUSES Copy fuses from SoC for CB_B decryption excl.) 0xD2 VERIFY_OFFSET_CB_B Verify CB_B offset 0xD3 FETCH_HEADER_CB_B Copy CB_B header from NAND for verification 0xD4 VERIFY_HEADER_CB_B Verify CB_B header 0xD5 FETCH_CONTENTS_CB_B Copy CBB into memory at 0x8000.0200.0001.0000 (old location of CB_A) 0xD6 HMACSHA_COMPUTE_CB_B Create HMAC key for CD decryption 0xD7 RC4_INITIALIZE_CB_B Initialize CD RC4 key using HMAC key 0xD8 RC4_DECRYPT_CB_B RC4 decrypt CD 0xD9 SHA_COMPUTE_CB_B Compute hash of CD for verification 0xDA SHA_VERIFY_CB_B MemCmp computed hash with expected one (where rgh2 glitches) 0xDB BRANCH_CB_B Jump to CB_B CB_A 0xF0 PANIC - VERIFY_OFFSET_CB_B CBB offset verification fail Panics 0xF1 PANIC - VERIFY_HEADER_CB_B CBB header verification fail 0xF2 PANIC - SHA_VERIFY_CB_B CBB security hash comparison fail 0xF3 PANIC - ENTRY_SIZE_INVALID_CB_B CBB size check fail (must be less than 0xC000) CB/2BL 0x20 - CB entry point, initialize SoC 0x21 INIT_SECOTP Initialize secopt, verify lockdown fuses 0x22 INIT_SECENG Initialize security engine 0x23 INIT_SYSRAM Initialize EDRAM 0x24 VERIFY_OFFSET_3BL_CC 0x25 LOCATE_3BL_CC 0x26 FETCH_HEADER_3BL_CC 0x27 VERIFY_HEADER_3BL_CC 0x28 FETCH_CONTENTS_3BL_CC 0x29 HMACSHA_COMPUTE_3BL_CC 0x2A RC4_INITIALIZE_3BL_CC 0x2B RC4_DECRYPT_3BL_CC 0x2C SHA_COMPUTE_3BL_CC 0x2D SIG_VERIFY_3BL_CC 0x2E HWINIT Hardware initialization 0x2F RELOCATE Setup tlb entries, relocate to ram 0x30 VERIFY_OFFSET_4BL_CD Verify CD offset 0x31 FETCH_HEADER_4BL_CD Copy CD header from NAND for verification 0x32 VERIFY_HEADER_4BL_CD Verify CD header 0x33 FETCH_CONTENTS_4BL_CD Copy CD from nand 0x34 HMACSHA_COMPUTE_4BL_CD Create HMAC key for CD decryption 0x35 RC4_INITIALIZE_4BL_CD Initialize CD RC4 key using HMAC key 0x36 RC4_DECRYPT_4BL_CD RC4 decrypt CD with key 0x37 SHA_COMPUTE_4BL_CD Compute hash of CD for verification 0x38 SIG_VERIFY_4BL_CD RSA signature check of CD hash 0x39 SHA_VERIFY_4BL_CD MemCmp computed hash with expected one 0x3A BRANCH Setup memory encryption and jump to CD 0x3B PCI_INIT Initialize PCI CB 0x9B PANIC - VERIFY_SECOTP_1 Secopt fuse verification fail Panics 0x9C PANIC - VERIFY_SECOTP_2 Secopt fuse verification fail2 0x9D PANIC - VERIFY_SECOTP_3 Secopt fuse verification console type? fail 0x9E PANIC - VERIFY_SECOTP_4 Secopt fuse verification console type? fail 0x9F PANIC - VERIFY_SECOTP_5 Secopt fuse verification console type? fail 0xA0 PANIC - VERIFY_SECOTP_6 CB revocation check failed 0xA1 PANIC - VERIFY_SECOTP_7 Panic after 0x21 0xA2 PANIC - VERIFY_SECOTP_8 Panic after 0x21 0xA3 PANIC - VERIFY_SECOTP_9 Panic after 0x21 0xA4 PANIC - VERIFY_SECOTP_10 Failed SMC HMAC 0xA5 PANIC - VERIFY_OFFSET_3BL_CC 0xA6 PANIC - LOCATE_3BL_CC 0xA7 PANIC - VERIFY_HEADER_3BL_CC 0xA8 PANIC - SIG_VERIFY_3BL_CC 0xA9 PANIC - HWINIT Hardware initialization failed 0xAA PANIC - VERIFY_OFFSET_4BL_CD Failed to verify CD offset 0xAB PANIC - VERIFY_HEADER_4BL_CD Failed to verify CD header 0xAC PANIC - SIG_VERIFY_4BL_CD 0xAD PANIC - SHA_VERIFY_4BL_CD CD security hash comparison fail 0xAE PANIC - UNEXPECTED_INTERRUPT CB exception, unknown interrupt vector 0xAF PANIC - UNSUPPORTED_RAM_SIZE 0xB0 PANIC - VERIFY_CONSOLE_TYPE Secopt fuse verification console type? fail CD/4BL 0x40 - Entrypoint of CD, setup memory paging 0x41 VERIFY_OFFSET Verify offset to CE 0x42 FETCH_HEADER Copy CE header from NAND for verification 0x43 VERIFY_HEADER Verify CE Header 0x44 FETCH_CONTENTS Read CE from nand into memory 0x45 HMACSHA_COMPUTE Create HMAC key for CE decryption 0x46 RC4_INITIALIZE Initialize CE RC4 key using HMAC key 0x47 RC4_DECRYPT RC4 decrypt CE 0x48 SHA_COMPUTE Compute hash of CE for verification 0x49 SHA_VERIFY MemCmp computed hash with expected one (where rgh1 glitches) 0x4A LOAD_6BL_CF 0x4B LZX_EXPAND LZX Decompress CE 0x4C SWEEP_CACHES 0x4D DECODE_FUSES Decode fuses 0x4E FETCH_OFFSET_6BL_CF Load CF (kernel patches) offset 0x4F VERIFY_OFFSET_6BL_CF Verify CF offset 0x50 LOAD_UPDATE_1 Load CF1/CG1 (patch slot 1) if version &amp; header checks pass 0x51 LOAD_UPDATE_2 Load CF2/CG2 (patch slot 2) if version &amp; header checks pass 0x52 BRANCH Startup kernel/Hypervisor 0x53 DECRYT_VERIFY_HV_CERT Decrypt and verify hypervisor certificate CD 0xB1 PANIC - VERIFY_OFFSET CE decryption failed Panics 0xB2 PANIC - VERIFY_HEADER Failed to verify CE header 0xB3 PANIC - SHA_VERIFY CE hash comparison fail 0xB4 PANIC - LZX_EXPAND CE LZX decompression failed 0xB5 PANIC - VERIFY_OFFSET_6BL CF verification failed 0xB6 PANIC - DECODE_FUSES Fuse decryption/check failed 0xB7 PANIC - UPDATE_MISSING CF decryption failed, patches missing. 0xB8 PANIC - CF hash auth failed CE 0xC1 LZX_EXPAND_1 LDICreateDecompression failed CF 0xC2 LZX_EXPAND_2 CG size verification failed Panics 0xC3 LZX_EXPAND_3 Header / patch fragment info check failed 0xC4 LZX_EXPAND_4 Unexpected LDI fragment type 0xC5 LZX_EXPAND_5 LDISetWindowData failed 0xC6 LZX_EXPAND_6 LDIDecompress failed 0xC7 LZX_EXPAND_7 LDIResetDecompression failed 0xC8 SHA_VERIFY CG auth failed Hypervisor 0x58 INIT_HYPERVISOR Hypervisor Initialization begin /HV 0x59 INIT_SOC_MMIO Initialize SoC MMIO 0x5A INIT_XEX_TRAINING Initialize XEX training 0x5B INIT_KEYRING Initialize key ring 0x5C INIT_KEYS Initialize keys 0x5D INIT_SOC_INT Initialize SoC Interrupts 0x5E INIT_SOC_INT_COMPLETE Initialization complete HV Panics 0xFF PANIC - FATAL Fatal error Kernel 0x60 INIT_KERNEL Initialize kernel 0x61 INIT_HAL_PHASE_0 Initialize hardware abstraction layer (phase 0) 0x62 INIT_PROCESS_OBJECTS Initialize process objects 0x63 INIT_KERNEL_DEBUGGER Initialize kernel debugger 0x64 INIT_MEMORY_MANAGER Initialize memory manager 0x65 INIT_STACKS Initialize stacks 0x66 INIT_OBJECT_SYSTEM Initialize object system 0x67 INIT_PHASE1_THREAD Initialize phase 1 thread 0x68 INIT_PROCESSORS Initialize processors 0x69 INIT_KEY_VAULT Initialize keyvault 0x6A INIT_HAL_PHASE_1 Initialize hardware abstraction layer (phase 1) 0x6B INIT_SFC_DRIVER Initialize SFC (Flash controller) 0x6C INIT_SECURITY Initialize security 0x6D INIT_KEY_EX_VAULT Initialize keyvault (extended portion) 0x6E INIT_SETTINGS Initialize settings 0x6F INIT_POWER_MODE Initialize power mode 0x70 INIT_VIDEO_DRIVER Initialize video driver 0x71 INIT_AUDIO_DRIVER Initialize audio driver 0x72 INIT_BOOT_ANIMATION Initialize boot animation + XMADecoder &amp; XAudioRender Init 0x73 INIT_SATA_DRIVER Initialize SATA driver 0x74 INIT_SHADOWBOOT Initialize shadowboot 0x75 INIT_DUMP_SYSTEM Initialize dump system 0x76 INIT_SYSTEM_ROOT Initialize system root 0x77 INIT_OTHER_DRIVERS Initialize other drivers 0x78 INIT_STFS_DRIVER Initialize STFS driver 0x79 LOAD_XAM Load XAM"},{"location":"POST/#credits","title":"Credits","text":"<p>Retrieved from (https://www.xdevwiki.tk/index.php?title=POST_Codes&amp;oldid=156)</p>"},{"location":"Pre-release_differences/","title":"Hardware","text":""},{"location":"Pre-release_differences/#motherboard","title":"Motherboard","text":"<p>Extra unnamed header used for TITAN board, near ROL board connector.</p>"},{"location":"Pre-release_differences/#titan-board","title":"TITAN Board","text":"<p>Some board used for CPU debugging (?) Has DIP switches which have unknown functions LED lights for indicating something DIP switches are set to 4 down, 3 up, 2 down, 1 down (from a China XEDK), although this can be random.</p>"},{"location":"Pre-release_differences/#flash","title":"Flash","text":""},{"location":"Pre-release_differences/#pre-1839","title":"Pre-1839","text":"<p>CPU key and 1BL key set to 00...00 (16 bytes of 00's)</p>"},{"location":"Pre-release_differences/#pre-1838","title":"Pre-1838","text":"<p>1640 seems to include some strings to do with xshell \"\\Device\\Harddisk0\\Partition1\\dashboard.xbx\", \"\\Device\\Harddisk0\\Partition1\\xshell.xex\", 1746 doesn't have a single mention Bootloader names are different, instead of SB/SC/SD/SE/SF/SG it's S2/S3/S4/S5/S6/S7 Kernel seems to have version field blanked out in the SE section, and different magic bytes on decompression. ECC data is different: *2 bytes to indicate block number, but second byte has 0xF0 added to it, XOR that byte with 0xF0 to get true number</p> <ul> <li>Doesn't indicate where the FS blocks are</li> <li>Doesn't seem to have bad block management... probably does though</li> </ul> <p>Uses a whole different file system for storing the dashboard files, instead of SFCX it uses FATX Loads more files inside FATX NANDs: * drivers.xex * xnet.xex * xlivebase.xex * xgi.xex * uvbase.xex * musicplayer.xex (not sure if this is there normally) * gamercard.xex * gamercard.xzp * livecommon.xzp * spa.bin * common.xzp * huduiskin.xzp * processdump.xex * rrbkgnd.bmp * saferec.bmp * recovery.ttf</p>"},{"location":"Pre-release_differences/#file-formats","title":"File Formats","text":""},{"location":"Pre-release_differences/#pre-1861","title":"Pre-1861","text":"<p>XEX1 format for xex files instead of XEX2... xorloser where are you?</p>"},{"location":"Pre-release_differences/#pre-1839_1","title":"Pre-1839","text":"<p>Keyvault is different (e.g. console serial is 0x18 bytes?!) Keyvault also has different device keys, which stops wireless controllers from working Also, console security certificate is incomplete-ish: * Part number set to 12345678901 * No manufacturing date? * Console type is weird, 0x80000002, normally when it ends in 02 it's retail :S</p> <p>Category: Hardware Category: System Software</p>"},{"location":"Rawflash/","title":"Rawflash","text":""},{"location":"Rawflash/#nfo","title":"NFO","text":"<pre><code>place \"nandflash.bin\" on the root of a usb device\nstart 2stage xell and shut off when prompted (replug power if you changed SMC)\n- by default it checks blocks before writing, and will NOT overwrite or erase any block with ecc/other issues (perfect for *** images with auto remaps)\n\nsmall change to libxenon was required to silence non-error messages\n\ntested on falcon, trinity and jasper 256\n\nv4: fix page offsets for bad block checks on big blocks (fixes problems when nandmu is present)\nv3: re-re-refix bad block skipping so it skips it in both the dump and flash instead of just in the dump\nv2: add big block support\nv1: initial version\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"SMBus_Controller/","title":"Overview","text":"<p>All non-PC components of the Xbox console are connected through an I\u00b2C/SMbus interface. I\u00b2C/SMBus is a slow low-cost serial bus with each device having a unique 7-bit ID. (Wikipedia has informative articles about I\u00b2C (http://en.wikipedia.org/wiki/I2c) and SMBus (http://en.wikipedia.org/wiki/SMBus), you might want to check them out.)</p> <p>There are only two operations of an SMBus controller: write and read. Writing means that an 8 bit command code and an 8 or 16 bit operand are sent to an SMBus device. Reading means that an 8 bit command code is sent to the device and an 8 or 16 bit answer is expected.</p> <p>The controller for the SMBus interface in the Xbox is a PCI device with the DevID 01B4 and it is built into MPCX southbridge.</p>"},{"location":"SMBus_Controller/#smbus-controller-port-layout","title":"SMBus Controller Port Layout","text":"<p>Port</p> <p>Description</p> <p>0xc000</p> <p>Status bit 0: abort bit 1: collision bit 2: protocol error bit 3: busy bit 4: cycle complete bit 5: timeout</p> <p>0xc002</p> <p>Control bit 2-0: cycle type bit 3: start bit 4: enable interrupt bit 5: abort</p> <p>0xc004</p> <p>Address</p> <p>0xc006</p> <p>Data</p> <p>0xc008</p> <p>Command</p> <p>This is very similar (but not identical) to the AMD756/AMD766/AMD768 SMBus controllers. The lm_sensors project includes GPLed Linux kernel code for it since version 2.6.4 (kernel/busses/i2c-amd756.c).</p>"},{"location":"SMBus_Controller/#smbus-controller-programming","title":"SMBus Controller Programming","text":"<p>The following two routines illustrate how to read and write data from and to an SMBus device:</p> <p><code>int\u00a0SMBusWriteCommand(unsigned\u00a0char\u00a0slave,\u00a0unsigned\u00a0char\u00a0command,\u00a0int\u00a0isWord,\u00a0unsigned\u00a0short\u00a0data)\u00a0{</code> <code>again:</code> <code>_outp(0xc004,\u00a0(slave&lt;&lt;1)&amp;0xfe);</code> <code>_outp(0xc008,\u00a0command);</code> <code>_outpw(0xc006,\u00a0data);</code> <code>_outpw(0xc000,\u00a0_inpw(0xc000));</code> <code>_outp(0xc002,\u00a0(isWord)\u00a0?\u00a00x0b\u00a0:\u00a00x0a);</code> <code>while\u00a0((_inp(0xc000)\u00a0&amp;\u00a08));\u00a0/*\u00a0wait\u00a0while\u00a0busy\u00a0*/</code> <code>if\u00a0(_inp(0xc000)\u00a0&amp;\u00a00x02)\u00a0goto\u00a0again;\u00a0/*\u00a0retry\u00a0transmission\u00a0*/</code> <code>if\u00a0(_inp(0xc000)\u00a0&amp;\u00a00x34)\u00a0return\u00a00;\u00a0\u00a0/*\u00a0fatal\u00a0error\u00a0*/</code> <code>return\u00a01;</code> <code>}</code> <code>int\u00a0SMBusReadCommand(unsigned\u00a0char\u00a0slave,\u00a0unsigned\u00a0char\u00a0command,\u00a0int\u00a0isWord,\u00a0unsigned\u00a0short\u00a0*data)\u00a0{</code> <code>again:</code> <code>_outp(0xc004,\u00a0(slave&lt;&lt;1)|0x01);</code> <code>_outp(0xc008,\u00a0command);</code> <code>_outpw(0xc000,\u00a0_inpw(0xc000));</code> <code>_outp(0xc002,\u00a0(isWord)\u00a0?\u00a00x0b\u00a0:\u00a00x0a);</code> <code>while\u00a0((_inp(0xc000)\u00a0&amp;\u00a08));\u00a0/*\u00a0wait\u00a0while\u00a0busy\u00a0*/</code> <code>if\u00a0(_inp(0xc000)\u00a0&amp;\u00a00x02)\u00a0goto\u00a0again;\u00a0/*\u00a0retry\u00a0transmission\u00a0*/</code> <code>if\u00a0(_inp(0xc000)\u00a0&amp;\u00a00x34)\u00a0return\u00a00;\u00a0\u00a0/*\u00a0fatal\u00a0error\u00a0*/</code> <code>*data\u00a0=\u00a0_inpw(0xc006);</code> <code>return\u00a01;</code> <code>}</code></p> <p>To avoid busy waiting of the CPU, the SMBus controller can also issue an interrupt when the operation is complete, by setting bit #4 in the control port when initiating the transfer.</p>"},{"location":"SMBus_Controller/#xbox-smbus-devices","title":"Xbox SMBus Devices","text":"<p>The following four devices are connected to the Xbox SMBus:</p> <p>Device Hardware Address Software Address PIC16LC 0x10 0x20 Conexant CX25871 Video Encoder 0x45 0x8a ADM1032 System Temperature Monitor 0x4c 0x98 Serial EEPROM 0x54 0xa8 Do not confuse the hardware with the software addresses: The software ID is the hardware ID shifted by one bit left. The code above expects the hardware ID.</p> <p>Actually, these addresses are not literally accurate; you find that the hardware address is 0x54 for the EEPROM: the actual address of the EEPROM on the i2c bus is 1010 (0xa), however, you will also notice that 0x54 is 1010100 in binary, and it seems that this 100 is also appended onto the other devices as well (although their software address is naturally read as say 10101000 - obviously because of the left shifting, however, it could be speculated that it would be possible to communicate with devices over the SMBus that are connected via i2c, so long as you knew their base address.</p> <p>Retrieved from \"http://www.xbox-linux.org/wiki/SMBus_Controller\"</p> <p>Category: Xbox_Hardware</p>"},{"location":"Serial_Console/","title":"Serial Console","text":"<ol> <li>REDIRECT UART</li> </ol>"},{"location":"Timing_Attack/","title":"Timing Attack","text":"<p>Valid as of December 7th 2007</p> <p>The timing attack is used allow machines with kernel 4552 or higher to downgrade to a vulnerable kernel. The purpose of the timing attack is to find the required hash values for the altered CB section in a base kernel (1888). The lockdown counter in the CB section is changed to a higher value to allow the base kernel (1888) to bypass the restrictive lockdown counter check during boot-up. The check is what makes it impossible to just flash the NAND and downgrade to a vulnerable kernel.</p> <p>The community at XboxHacker made this project possible, Arnezami found the Timing Attack vector and figured out the basic concept, and Robinsod built the necessary downgrader hardware and measurement software required to perform the attack.</p>"},{"location":"Timing_Attack/#purpose","title":"Purpose","text":"<p>A good explanation by arnezami 1:</p> <p><code>[With\u00a0the\u00a0CPU\u00a0key]\u00a0can\u00a0we\u00a0not\u00a0resign\u00a0the\u00a0essential\u00a0parts\u00a0of\u00a0the\u00a0HV,\u00a0or\u00a0anything\u00a0else,\u00a0with\u00a0a\u00a0modified\u00a0bootloader?</code> <code>All\u00a0executable\u00a0code\u00a0on\u00a0the\u00a0xbox\u00a0is\u00a0(one\u00a0way\u00a0or\u00a0another)\u00a0signed\u00a0by\u00a0a\u00a0RSA\u00a0key.\u00a0MS\u00a0has\u00a0the\u00a0private\u00a0RSA\u00a0key\u00a0and\u00a0thats</code> <code>why\u00a0we\u00a0will\u00a0never\u00a0be\u00a0able\u00a0to\u00a0sign\u00a0our\u00a0own\u00a0executable\u00a0code.\u00a0This\u00a0is\u00a0what\u00a0prevents\u00a0us\u00a0from\u00a0running\u00a0anything\u00a0different</code> <code>than\u00a0what\u00a0MS\u00a0has\u00a0build\u00a0(like\u00a0the\u00a0kernel\u00a0and\u00a0bootloaders).\u00a0This\u00a0has\u00a0nothing\u00a0to\u00a0do\u00a0with\u00a0the\u00a0cpu\u00a0key.\u00a0The\u00a0only\u00a0thing\u00a0we</code> <code>can\u00a0do\u00a0with\u00a0the\u00a0cpu\u00a0key\u00a0is\u00a0choose\u00a0which\u00a0version\u00a0of\u00a0the\u00a0kernel/bootloader\u00a0we\u00a0want\u00a0to\u00a0run.\u00a0But\u00a0we\u00a0cannot\u00a0make\u00a0changes</code> <code>to\u00a0any\u00a0of\u00a0these\u00a0versions\u00a0themselves.</code></p> <p><code>Then\u00a0why\u00a0downgrade?</code> <code>Because\u00a0two\u00a0kernel\u00a0versions\u00a0MS\u00a0build\u00a0(4532,4548)\u00a0have\u00a0a\u00a0tiny\u00a0flaw.\u00a0And\u00a0when\u00a0we\u00a0have\u00a0our\u00a0cpu\u00a0key\u00a0we\u00a0can\u00a0choose\u00a0to</code> <code>run\u00a0these\u00a0(old)\u00a0kernels\u00a0and\u00a0exploit\u00a0them\u00a0by\u00a0running\u00a0a\u00a0patched\u00a0KK\u00a0game.\u00a0After\u00a0running\u00a0the\u00a0exploit\u00a0we\u00a0have\u00a0complete</code> <code>control\u00a0over\u00a0the\u00a0xbox\u00a0(but\u00a0not\u00a0before\u00a0that).\u00a0This\u00a0means\u00a0to\u00a0be\u00a0able\u00a0to\u00a0run\u00a0homebrew\u00a0or\u00a0linux\u00a0we\u00a0now\u00a0have\u00a0to\u00a0start\u00a0the</code> <code>game,\u00a0press\u00a0ok,\u00a0insert\u00a0a\u00a0disc\u00a0etc.</code><code>More</code></p> <p>Visual representation of the process:</p> <p>![Image:Timing attack visual representation.png]images/Timing_attack_visual_representation.png)</p>"},{"location":"Timing_Attack/#memcmp-flaw","title":"Memcmp Flaw","text":"<p>A memcmp function is used to check the CB-auth HMAC-hash value. The value is 16-bytes long and is done byte-by-byte wise. By changing one byte at a time it's possible to determine if a byte is the valid (true) by measuring the time to compare a false and a true value. Measuring each byte will in the end reveal the correct hash and the boot process can continue.</p> <p>The time differences for a valid and false value is about 2200 microseconds.</p> <p>Possibilities: 16 bytes * 256 different possibility for each byte, total 4096 tries. Statistically only half has to be tried, 2048 tries.</p>"},{"location":"Timing_Attack/#procedure","title":"Procedure","text":"<p>The official documentation by robinsod for the downgrader hardware and downgrading process can be downloaded from the Timing Attack thread over at XboxHacker.</p>"},{"location":"Timing_Attack/#dump-nand","title":"Dump NAND","text":"<p>Use Infectus or custom hardware (memorycard reader) to make a valid dump of the current NAND.</p> <ul> <li>Xbox 360 Infectus Kernel Dump</li> </ul> <p></p>"},{"location":"Timing_Attack/#patch-cb","title":"Patch CB","text":"<p>Get a plain 1888 base kernel and patch the CB lockdown counter with the LDV (LockDownValue) from the CF section in the NAND dump.</p> <ol> <li>Get the 1888 base kernel from the \"usual places\".</li> <li>Download     Degraded.exe     to automate the build of a new 1888 image with the SMC, Keyvault,     CB, CD and CE sections from the NAND dump. The LDV (fuse count) will     be corrected for CB (which is why you need to find a new hash) and     the hash value is set to all zeroes.</li> </ol> <p>An external 1888 base kernel is needed because essential system files for 1888 is overwritten in the 4552 update and later, making it impossible to use the NAND dump to create a new 1888 image.</p> <p>In Degraded.exe click 'Settings', set the 1BL Key to 'DD88AD0C9ED669E7B56794FB68563EFA', select the folder where the 1888 file system is located, and set 'File System Start' to '39'.</p> <p></p> <p>Select the NAND dump file under 'Flash Dump' and click 'Build Downgrader Image'.</p> <p></p> <ul> <li>Downgrading Tools</li> </ul>"},{"location":"Timing_Attack/#flash-image","title":"Flash Image","text":"<p>Flash the new 1888 base kernel build to the NAND.</p> <p>Connect Infectus chip to the Xbox 360 again, erase and flash the new patched 1888 base kernel image.</p> <ul> <li>Xbox 360 Infectus Kernel Dump</li> </ul> <p></p>"},{"location":"Timing_Attack/#attack-hash","title":"Attack Hash","text":"<p>Attack the HMAC-hash value using the timing hardware and DGTool.</p> <ol> <li>Build the downgrader hardware and connect a     serial port cable and power/ground (3.3v or 5v) from the 360 or an     external power supply (USB) to the downgrader hardware.</li> <li>Connect the USB cable to the Infectus chip. The Infectus is required     to flash the NAND page for the CB section with a new value for each     new guess (every ~2 seconds).</li> <li>Create a folder with the 3 following files; DGTool.exe, Infectus.dll     and SiUSBXp.dll. Move the 1888 image to this folder too, e.g.     Infectus_5787_downgraded_1888.bin.</li> <li>Open a new command-prompt, by Start -&gt; Run -&gt; 'cmd'. Change     directory (cd) to the folder where the DGTool.exe is located.</li> <li>DGTool normally only needs 2 arguments to start; one being the COM-     or serial port the downgrader hardware is connected to and the other     is the filename of the patched 1888 image.</li> </ol> <p><code>DGTool.exe\u00a01\u00a0Infectus_5787_downgraded_1888.bin</code></p> <p>Enter the command above and press enter. Now power on the Xbox 360 and wait for the 3 red lights to start blinking, aka Red Ring Of Death (RROD). Press enter once more to start the timing process. Let it run for a little over an hour (around 1 hour 10 minutes seems to be normal) and the correct hash value will hopefully be discovered. If successful the last line of text should state 'BOOT!'.</p> <ul> <li>Xbox 360 Downgrader Hardware</li> </ul> <p></p>"},{"location":"Timing_Attack/#upgrade-kernel","title":"Upgrade Kernel","text":"<p>Once you can boot the 1888 base kernel, you can apply the vulnerable 4532 or 4548 update to use the King King exploit.</p> <p>Download the 4532 HD DVD update, extract the files into a folder, and burn the content on a regular CD-R. Insert the CD-R into the Xbox 360 and you will be prompted that a update is required.</p> <p></p> <p></p>"},{"location":"Timing_Attack/#get-cpu-key","title":"Get CPU Key","text":"<p>Boot a modified King Kong game disc and launch Gentoo Linux to get the CPU Key.</p> <ol> <li>Patch the King Kong game image with the King Kong     exploit and burn it to a DVD+R Dual     Layer disc.</li> <li>Burn the latest Gentoo Xenon release (as of writing beta2) from     free60.org to a CD-R and insert the disc     after pressing 'Start' on the modified King Kong disc.</li> <li>Download the     dump32     application to dump the fusesets to find the CPU Key of the machine.</li> </ol> <pre><code>wget\u00a0http://home.x-pec.com/~ivc/sites/ivc/xbox360/files/arnezamidump32.tgz\ntar\u00a0zxvf\u00a0arnezamidump32.tgz\ncd\u00a0arnezamidump32\nsudo\u00a0./dump32\n</code></pre> <p></p> <p>Save the FUSES.TXT file to a USB memorystick, upload it to yousendit.com, mail it to yourself, or use the 'scp' or 'ftp' utility to transfer it over the network to a computer.</p> <p>The CPU Key is found by combining line 3 + 5 in the FUSES.TXT file.</p> <p>It is now possible to upgrade to latest kernel (as of writing 5787) and then downgrade to a lower version again using the 360 Flash Tool. Insert the correct CPU Key in the 360 Flash Tool and patching the LDV (LockDownValue) in the CB/CE/CF section to that of the latest update.</p> <ul> <li>Kernel</li> <li>King Kong Hack</li> </ul>"},{"location":"Timing_Attack/#results","title":"Results","text":"<p>All of my runs can be found on the page below.</p> <ul> <li>Xbox 360 Timing Attack Results</li> </ul>"},{"location":"Timing_Attack/#speculation","title":"Speculation","text":"<p>arnezami:</p> <p><code>MS\u00a0cannot\u00a0fix\u00a0this\u00a0problem\u00a0by\u00a0simply\u00a0changing\u00a0the\u00a0memcmp\u00a0function\u00a0in\u00a0a\u00a0future\u00a0kernel\u00a0version.\u00a0Thats\u00a0not</code> <code>gonna\u00a0help\u00a0them.\u00a0The\u00a0weakness\u00a0is\u00a0that\u00a0the\u00a0byte-wise\u00a0memcmp\u00a0function\u00a0is\u00a0in\u00a0the\u00a01888\u00a0kernel/bootloader</code> <code>(and\u00a0they\u00a0cannot\u00a0change\u00a0that\u00a0one\u00a0anymore\u00a0of\u00a0course).</code><code>2</code></p> <p>tmbinc:</p> <p><code>sure,\u00a0microsoft\u00a0can\u00a0change\u00a0the\u00a02BL,\u00a0and\u00a0burn\u00a0a\u00a0fuse\u00a0(of\u00a0the\u00a0fuseline\u00a02)\u00a0so\u00a0that\u00a0an\u00a0old\u00a02BL\u00a0doesn't\u00a0work\u00a0anymore...</code><code>3</code></p> <p>arnezami:</p> <p><code>Ah.\u00a0Right.\u00a0If\u00a0they\u00a0can\u00a0indeed\u00a0burn\u00a0these\u00a0fuses\u00a0at\u00a0row\u00a02\u00a0than\u00a0you\u00a0wouldn't\u00a0be\u00a0able\u00a0to\u00a0run\u00a0any\u00a0of\u00a0the\u00a0lower</code> <code>kernel\u00a0versions\u00a0anymore.</code><code>4</code></p> <p><code>Been\u00a0thinking\u00a0about\u00a0this.\u00a0I'm\u00a0now\u00a0pretty\u00a0sure\u00a0when\u00a0row\u00a02\u00a0of\u00a0the\u00a0fuses\u00a0is\u00a0burned\u00a0your\u00a0xbox\u00a0won't\u00a0be\u00a0able\u00a0to</code> <code>downgrade\u00a0or\u00a0run\u00a0homebrew\u00a0anymore\u00a0(it\u00a0appears\u00a0the\u00a0fuse\u00a0count\u00a0number\u00a0is\u00a0indeed\u00a0RSA\u00a0signed).</code><code>5</code></p> <p>surrido:</p> <p><code>you\u00a0could\u00a0if\u00a0it\u00a0makes\u00a0you\u00a0happy\u00a0wire\u00a0a\u00a0switch\u00a0to\u00a0the\u00a0R6T3\u00a0and\u00a0keep\u00a0it\u00a0on\u00a0while\u00a0being\u00a0in\u00a0live\u00a0and\u00a0turn\u00a0it</code> <code>of\u00a0when\u00a0you\u00a0receive\u00a0an\u00a0update.</code><code>6</code></p> <p>tmbinc:</p> <p><code>No,\u00a0a\u00a0switch\u00a0at\u00a0R6T3\u00a0doesn't\u00a0help.\u00a0It's\u00a0not\u00a0the\u00a0resistor\u00a0which\u00a0presence\u00a0can\u00a0be\u00a0detected,\u00a0but\u00a0the\u00a0result</code> <code>to\u00a0the\u00a0fuse\u00a0(burned\u00a0or\u00a0not).</code></p> <p><code>So\u00a0his\u00a0question\u00a0is\u00a0completely\u00a0valid:\u00a0If\u00a0you\u00a0remove\u00a0the\u00a0resistor,\u00a0you\u00a0could\u00a0end\u00a0up\u00a0with\u00a0an\u00a0unbootable\u00a0box</code> <code>after\u00a0the\u00a0next\u00a0update.\u00a0But\u00a0at\u00a0least\u00a0you\u00a0could\u00a0restore\u00a0a\u00a0previous\u00a0flash.\u00a0(If\u00a0you\u00a0want,\u00a0you\u00a0could\u00a0*then*</code> <code>re-attach\u00a0the\u00a0resistor,\u00a0and\u00a0update\u00a0again,\u00a0of\u00a0course\u00a0loosing\u00a0the\u00a0possibility\u00a0to\u00a0downgrade).</code><code>7</code></p>"},{"location":"Timing_Attack/#current-situation","title":"Current Situation","text":"<p>The last 2007 fall update, 6683, is still vulnerable and can be downgraded by timing attacking the HMAC-hash value. The update is still vulnerable because the CB (2BL) section of the kernel did not change after the update, only the main CE/CF sections. No other fuses than the obligatory fuseline 7 (to match the LockDownValue in CE/FE) were blown.</p> <p>The latest revisions of the Xbox 360, the Falcon, has a newer basekernel and CB section, 1921, and this version is patched against the memcmp-vulnerability 8. Making timing attack on these machines impossible until another vulnerability is found.</p> <p>This might suggest that only newer machines from factory can be patched to fix the memcmp-function in CB.</p>"},{"location":"Timing_Attack/#references","title":"References","text":"<ul> <li>Original Wiki page - Thx ivc!</li> <li>Timing Attack</li> <li>Timing Attach - Thanks and stupid questions</li> </ul>"},{"location":"Utilities/","title":"Utilities","text":""},{"location":"Utilities/#utilities","title":"Utilities","text":""},{"location":"Utilities/#lflash","title":"Lflash","text":""},{"location":"Utilities/#description","title":"Description:","text":"<p>A NAND Flasher for xbox360, currently only working with 16MB NAND. For use with Linux. Official Site: www.free60.org</p> <p>Download: Free60 GIT</p>"},{"location":"Utilities/#dumpana","title":"Dumpana","text":""},{"location":"Utilities/#description_1","title":"Description:","text":"<p>Tool for dumping ANA (Graphic Scaler Chip) registers. For use with Linux.</p> <p>Official Site: www.free60.org</p>"},{"location":"Utilities/#download","title":"Download:","text":"<ul> <li>Free60 GIT</li> </ul>"},{"location":"Utilities/#rawflash-v2","title":"Rawflash v2","text":""},{"location":"Utilities/#description_2","title":"Description:","text":"<p>A tool for flashing rawimages (already properly remapped) to NAND, directly via LibXenon application</p> <p>Official Site: http://www.libxenon.org, by cOz</p>"},{"location":"Utilities/#forum-discussion","title":"Forum Discussion:","text":"<p>libxenon.org archive</p>"},{"location":"Utilities/#download_1","title":"Download:","text":"<p>libxenon.org archive</p> <p>Category: Homebrew Software</p>"},{"location":"Xenon_%28Disambiguation%29/","title":"Xenon (Disambiguation)","text":"<p>Xenon is a codename used many times during the Xbox 360's development, and mentions of it can still be found in some 360 files.</p> <p>Xenon may refer to:</p> <ul> <li>Xenon, the codename for the Xbox 360 before it was announced.</li> <li>Xenon (Motherboard), the original Xbox 360 motherboard and case.</li> <li>Xenon (CPU), the CPU used by the Xbox 360.</li> </ul>"},{"location":"Xenon_%28Disambiguation%29/#see-also","title":"See also","text":"<ul> <li>Xenos, the GPU used by the Xbox 360</li> </ul> <p>Hardware</p>"},{"location":"ZLX_Browser/","title":"ZLX Browser","text":""},{"location":"ZLX_Browser/#nfo","title":"NFO","text":"<pre><code>The browser is built with the [ZLX_Library](../ZLX Library) and is included with it.\n</code></pre> <p>Homebrew_Software</p>"},{"location":"Development/Cross_Compiler/","title":"Cross Compiler","text":"<p>The Xbox 360 CPU is based on IBM's Power Architecture. Unless you have a machine with PowerPC CPU and Linux running (such as an older Mac or a PS3), you need to set up a cross compiler toolchain in order to compile code like the Linux Kernel for your Xbox 360.</p> <p>A typical cross compiler toolchain for the GNU compiler collection usually consists of three major parts:</p> <ul> <li>the GNU binutils package</li> <li>the gcc compiler</li> <li>a implementation of the standard C library (can be left out if you   only want to cross compile the Linux kernel)</li> </ul> <p>Compiling a compiler on its own platform is already a quite complex task, compiling a compiler for a different platform adds even more caveats as not all versions of binutils, gcc and glibc work together well.</p>"},{"location":"Development/Cross_Compiler/#using-the-xenon-toolchain","title":"Using the Xenon Toolchain","text":"<p>The easiest way to set up a complete cross compiler toolchain is the Xenon Toolchain. Its using current gcc and does not take as long as crossotool to compile.</p>"},{"location":"Development/Cross_Compiler/#dan-kegels-crosstool","title":"Dan Kegel's crosstool","text":"<p>An alternative method is to use Dan Kegel's crosstool. Especially the author has already tried lots of combinations of binutils, GCC and glibc to mark the working ones. A complete documentation of crosstool can be found at the crosstool website. For a quick start, we will summarize the instructions from the crosstool-howto:</p> <ol> <li> <p>Preparations: Make sure you have the following basic UNIX tools    installed (with the variety of Linux distributions available, you never    know...):</p> <ul> <li>wget</li> <li>tar</li> <li>bzip2</li> <li>bison</li> <li>flex</li> <li>make</li> <li>gcc &amp; friends (targeting your own platform)</li> </ul> </li> <li> <p>Download and unpack the crosstool scripts. E.g. in your home directory type:</p> </li> </ol> <pre><code>wget\u00a0http://kegel.com/crosstool/crosstool-0.43.tar.gz\ntar\u00a0-xzvf\u00a0crosstool-0.43.tar.gz\n</code></pre> <ol> <li>Create the target directories for your cross compilation tools and make them writable for your user. We are using the default which is <code>/opt/crosstool</code>. You will probably need to be root for that so either <code>su</code> before typing these commands and replace <code>$USER</code> with your username or use <code>sudo</code> like in the example:</li> </ol> <pre><code>sudo\u00a0mkdir\u00a0/opt/crosstool\nsudo\u00a0chown\u00a0$USER\u00a0/opt/crosstool\n</code></pre> <ol> <li>Run the compilation script for the powerpc target.</li> </ol> <pre><code>cd\u00a0crosstool-0.43/\n./demo-powerpc-970.sh\n</code></pre> <ol> <li> <p>Get a drink, go for a walk or use the time to remove the resistor R6T3 from the mainboard of your Xbox 360... Compilation of your cross compiler will just take a while.</p> </li> <li> <p>When finished, you may want to add your cross compiler binaries to your PATH environment variable.</p> </li> </ol> <pre><code>export\u00a0PATH=$PATH:/opt/crosstool/gcc-4.1.0-glibc-2.3.6/powerpc64-unknown-linux-gnu/bin\n</code></pre> <p>You're done. Feel free to configure and compile your Linux Kernel.</p> <p>Category: Development</p>"},{"location":"Development/Dumpana/","title":"Dumpana","text":"<p>Dumpana is a tool made by tmbinc for dumping the Xbox's ANA Chip to create new Modesetting for additional Video-Modes. It's a linux tool.</p>"},{"location":"Development/Dumpana/#source","title":"Source","text":"<p>The source is available on the free60 GIT Repository in the tools section.</p> <p>Category: Development</p>"},{"location":"Development/Finding_the_right_timing/","title":"Finding the right timing for the reset glitch hack","text":""},{"location":"Development/Finding_the_right_timing/#getting-memcmp-post-length-in-ticks","title":"Getting memcmp POST length in ticks","text":"<p>First step is to know how long the memcmp POST will last while slowed down. No reset pulse should be sent for this. Using hardware that can read the POST bus and measure time in a precise way, measure the time between memcmp POST start and 'hash compare failed' final POST (eg on fats, between POST 39 and POST AD) with the next bootloader failing hash check.</p> <p>An ARM7 based Olimex LPC-H2148 was used for this task.</p> <p>It could look like that:</p> <pre><code>for(;;)\n{\n\u00a0\u00a0post\u00a0=\u00a0post_read();\n\u00a0\u00a0if\u00a0(post\u00a0==\u00a0prev_post)\u00a0then\u00a0continue;\n\n\u00a0\u00a0if(post\u00a0==\u00a0MEMCMP_POST)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0t_start\u00a0=\u00a0get_tick();\n\n\u00a0\u00a0\u00a0\u00a0while(\u00a0post_read()\u00a0==\u00a0MEMCMP_POST\u00a0);\n\n\u00a0\u00a0\u00a0\u00a0memcmp_post_length=get_tick()-t_start;\n\n\u00a0\u00a0\u00a0\u00a0print(memcmp_post_length);\n\u00a0\u00a0}\n\n\u00a0\u00a0prev_post=post;\n}\n</code></pre> <p>Make sure you note memcmp post length ;)</p>"},{"location":"Development/Finding_the_right_timing/#using-random-timing-over-the-full-post-length","title":"Using random timing over the full POST length","text":"<p>Now you need the hardware to send a reset pulse after a random amount of time in memcmp POST, but no more than previously found memcmp POST length.</p> <p>It could look like that:</p> <pre><code>for(;;)\n{\n\u00a0\u00a0post\u00a0=\u00a0read_post();\n\u00a0\u00a0if\u00a0(post\u00a0==\u00a0prev_post)\u00a0then\u00a0continue;\n\n\u00a0\u00a0if(post\u00a0==\u00a0MEMCMP_POST)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0t_start\u00a0=\u00a0get_tick();\n\u00a0\u00a0\u00a0\u00a0t_rand\u00a0=\u00a0rand()\u00a0%\u00a0MEMCMP_POST_LENGTH;\n\n\u00a0\u00a0\u00a0\u00a0while(\u00a0get_tick()&lt;\u00a0t_start+t_rand\u00a0);\n\n\u00a0\u00a0\u00a0\u00a0ppc_send_reset_pulse();\n\n\u00a0\u00a0\u00a0\u00a0print(t_rand);\n\u00a0\u00a0}\n\n\u00a0\u00a0prev_post=post;\n}\n</code></pre> <p>Using a hacked smc that reboots infinitely it will take a good amount of time, but it should end up glitching properly.</p> <p>Make sure you note the timing that glitched ;)</p>"},{"location":"Development/Finding_the_right_timing/#refining-the-timing-accounting-for-bell-like-curve","title":"Refining the timing, accounting for bell-like curve","text":"<p>So now we have one timing that glitches, but we don't know if it's really the 'sweet spot' or if we were just lucky. What needs to be done now is to get the timing of some more successes, I think it's safe to use a smaller random range around previously found glitch timing. my get_tick() function runs at 60Mhz, I found it was safe to make the range -+50 ticks around previously found glitch timing</p> <p>It could look like that:</p> <pre><code>for(;;)\n{\n\u00a0\u00a0post\u00a0=\u00a0read_post();\n\u00a0\u00a0if\u00a0(post\u00a0==\u00a0prev_post)\u00a0then\u00a0continue;\n\n\u00a0\u00a0if(post\u00a0==\u00a0MEMCMP_POST)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0t_start\u00a0=\u00a0get_tick();\n\u00a0\u00a0\u00a0\u00a0t_rand\u00a0=\u00a0PREV_GLITCH_TIMING\u00a0-\u00a050\u00a0+\u00a0(rand()\u00a0%\u00a0100);\n\n\u00a0\u00a0\u00a0\u00a0while(\u00a0get_tick()&lt;\u00a0t_start+t_rand\u00a0);\n\n\u00a0\u00a0\u00a0\u00a0ppc_send_reset_pulse();\n\n\u00a0\u00a0\u00a0\u00a0print(t_rand);\n\u00a0\u00a0}\n\n\u00a0\u00a0prev_post=post;\n}\n</code></pre> <p>You'll need the timing of at least 20-30 successes. Averaging those timings should give you the sweet spot (aka final timing), because empirically we found that success rate vs timing is a bell-like curve.</p> <p>Make sure ... you got it ;)</p> <p>PS: Those pseudo-code examples don't show the slowdown code for the sake of clarity.</p> <p>Category: Development</p>"},{"location":"Development/Free60_Git_Repository/","title":"Free60 Git repository","text":"<p>The Free60 git repository was hosted by sourceforge - it switched to github recently. You can download the latest source with the following commands</p> <p>LibXenon</p> <pre><code>git\u00a0clone\u00a0git://github.com/Free60Project/libxenon.git\n</code></pre> <p>XeLL <pre><code>git\u00a0clone\u00a0git://github.com/Free60Project/xell.git\n</code></pre></p> <p>For other repositories take a look at the webinterface of github: https://github.com/Free60Project</p> <p>For LibXenon projects - check out the appropriate Github organization: https://github.com/LibxenonProject</p> <p>Category: Development</p>"},{"location":"Development/LibHomebrew/","title":"LibHomebrew","text":"<p>libhomebrew is the idea to create an abstract homebrew library, unifying access to different hardware, making it easy to port homebrew from one console to another. Please help making this idea real!</p> <p>(Some more background about the idea can be found here)</p>"},{"location":"Development/LibHomebrew/#libhomebrew-basic-idea","title":"libhomebrew: Basic Idea","text":"<p>For every (hacked) hardware, there is a homebrew lib / toolchain:</p> <ul> <li>Libxenon for guess what ;)</li> <li>libogc for Wii,     GameCube</li> <li>OpenXDK for Xbox 1</li> <li>devkitPro is a toolchain for GameBoy     Advance, GP32, Playstation Portable and GameCube.</li> <li>SDL is not technically a homebrew lib, but     has been ported to many many platforms.</li> <li>many others I forgot here</li> </ul> <p>The point is: Every community is hacking their own homebrew library, reinventing/forking functionality for libc, peripherals (USB, SD/SDHC, NAND, ..), functionality (libz, libmad, ..), storage (FAT32), networking (lwip, TCP/IP, DHCP, ...), etc.</p> <p>It would be really great to have a generic homebrew lib! Such a lib would contain backends / modules / hardware abstraction layers, which are specific to the hardware you want to deploy, and plentiful functionality on top of these modules.</p> <p>All it would take to support homebrew on a new device would be writing some HAL code, et voila: all the homebrew apps based on libhomebrew run on your new shiny device.</p>"},{"location":"Development/LibHomebrew/#scope","title":"Scope","text":"<p>Homebrew libraries tend to cover these common areas:</p> <ul> <li>Input (joystick, buttons)</li> <li>Graphics (2d, 3d -- framebuffer?)</li> <li>Sound -- waveform, synthesized, mp3/ogg, etc</li> <li>Storage -- FAT, SD</li> <li>Networking -- TCP/IP, UDP</li> <li>USB?</li> </ul> <p>These would be good areas to start with.</p>"},{"location":"Development/LibHomebrew/#what-has-to-be-done","title":"What has to be done?","text":"<p>First, we need some coders from different homebrew scenes to sit together and find similarities in their projects.</p> <p>Then we need them to write the code ;-)</p> <p>Ok ok, all that needs to be done is an abstract interface on top of the existing homebrew libraries. Thats not so much to do after all. Then we can merge the different forks of generic functionality code together and remove it from the backends. Easy, eh?</p>"},{"location":"Development/LibHomebrew/#why-not-taking-linux","title":"Why not taking Linux?","text":"<p>That might actually be an option, however the Linux kernel is rather bloated with its lengthy boot-up times, drivers for things you don't quite need for homebrew and other aspects.</p> <p>Plus, sometimes you want a base which is not locking you in on GPL.</p> <p>However, you could add Linux as a HAL backend to libhomebrew instead!</p> <p>Linux advantage is there is already a lot of software available. So getting the little stuff missing in Linux working -decent video driver to get HDMI output and 1920x1080 support, initializing CPUs to fullspeed, perhaps a nice, easy installer- will be a nice middle step while we get better homebrew. XBox 360 Linux XMBC DVBT HD Tuner can be a sexy combination that will take too much effort doing from scratch, for example.</p>"},{"location":"Development/LibHomebrew/#why-not-taking-l4","title":"Why not taking L4?","text":"<p>It has been suggested to use the L4 Microkernel for aspects like multi-threading / scheduling / task switching. It has to be evaluated if it is possible to add L4 as a library without building the whole system on top of it.</p>"},{"location":"Development/LibHomebrew/#why-not-taking-libpayload","title":"Why not taking Libpayload?","text":"<p>Libpayload is part of the coreboot project. It is an abstraction library meant for easy deployment of code in boot-loader-comparable environments. It is focused mainly on x86, but looks like a promising ground. It contains its own libc implementation, whereas most homebrew projects are using newlib instead.</p> <p>Category: Homebrew Software Category: Development</p>"},{"location":"Development/List_of_development_tools/","title":"List of development tools","text":"<p>These Development Tools can help you develop legal homebrew applications and games for the Xbox 360. The most important tool for Xbox 360 development is Xenon Toolchain, a port of the GCC toolchain along with supporting system libraries. The development tools listed below make development easier or to add additional functionality.</p>"},{"location":"Development/List_of_development_tools/#core-development","title":"Core development","text":"Title Description Xenon_Toolchain GCC Cross Compiler and associated utilities LibXenon Library to interact with Xbox 360 specific Hardware"},{"location":"Development/List_of_development_tools/#framework-libraries","title":"Framework libraries","text":"Title Description Author Placeholder Placeholder Description Placeholder"},{"location":"Development/List_of_development_tools/#libraries","title":"Libraries","text":"Title Description Author Placeholder Placeholder Description Placeholder"},{"location":"Development/List_of_development_tools/#ported-libraries","title":"Ported Libraries","text":"Title Description Ported by libext2fs Ext2FS driver (ported from libext2fs-wii) Ced2911 libntfs NTFS driver using NTFS-3G (ported from libntfs-wii) Ced2911 libfat FAT filesystem driver Ced2911"},{"location":"Development/List_of_development_tools/#resources","title":"Resources","text":"Title Description Author Placeholder Placeholder Description Placeholder <p>Category: Development</p>"},{"location":"Development/Run_Code/","title":"Run Code","text":"<p>This is outdated! Use JTAG Hack or Reset Glitch Hack!</p> <p>Thanks to the work of \"Anonymous Hacker\" and \"Crawler360\", it is now possible to run your own code on an Xbox 360 with full (hypervisor) privileges.</p> <p>This page describes what you need in order to run your own code on your Xbox 360.</p>"},{"location":"Development/Run_Code/#kernel-version","title":"Kernel Version","text":"<p><code>You\u00a0need\u00a0an\u00a0Xbox\u00a0with\u00a0a\u00a0kernel\u00a0version\u00a0of\u00a04532\u00a0or\u00a04548.</code></p> <p>You can check your kernel version in \"System -&gt; Console Settings -&gt; System Info\". The line at the bottom contains your kernel version in the format K:2.0.nnnn.0, where nnnn is your four digit kernel version.</p> <p>If your kernel version is older, you can update to one of these versions. Do not update to a version newer than 4548! You won't be able to downgrade! If you already have a newer version, there is nothing you can do right now.</p> <p>If you buy an Xbox, make sure that its manufacturing date is before 09 January 2007, so that the kernel version is 4548 or older. You can see the manufacturing date (\"MFR Date\") through the carton without opening it.</p> <p>If you have a pre-4532 kernel, you need to get the file HD_DVD_10-2006.zip from somewhere, check the MD5SUM to be cd4db8e2c94266ab73513c361dd5b8f6 (important!), burn it to a CD, and insert the CD into your Xbox 360. The program will update your machine to kernel version 4532. This file is an authentic Microsoft update application, but is not available on Microsoft's servers any more. If you own an Xbox, it should be legal for you to download and run this application. We are not linking to it here, but it is very easy to get.</p> <p>In any case, you should remove the resistor R6T3 on the mainboard, to prevent the efuse to be blown, which once blown is making downgrades to \\&lt;4552 impossible.</p>"},{"location":"Development/Run_Code/#modified-drive","title":"Modified Drive","text":"<p>The DVD drive in your Xbox 360 needs to be modified to report non-game media as if it were game media. As this is the same modification that is needed for running copied games, it won't be reproduced here. A lot of good information on this is to be found elsewhere.</p> <p>Please note that besides the potential illegal (check your country's law!) modification of the drive's firmware, you can also hotswap the game disc after it has been authenticated.</p>"},{"location":"Development/Run_Code/#king-kong","title":"King Kong","text":"<p>You need a modified version of the game \"King Kong\" (either PAL or NTSC version) on a DVD. Obviously, for legal reasons, you need to own the game. Fortunately, the game has been one of the launch games, and used copies are easily available and very affordable.</p> <p>Since the information on how to dump a game can be used for piracy, it won't be described here, but it is easily available elsewhere.</p> <p>There are two King Kong patches available right now. The first was the one by Crawler360: Launch the modified game, press START on the title screen, and a very simple loader will be launched that allows uploading your code through a serial cable. There is a newer patch in the wild by xorloser, which allows booting directly from CDROM.</p> <p>The patcher currently does not work with the newer \"classics\" version of \"King Kong\" (barcode number 3 307210 240156), as it has a somewhat different structure but the patcher looks at \"hardcoded\" positions in the ISO - so it results in an \"ID error\" (you can check using a XDVDFS dump - the new one includes e.g. a file called \"GammaAdjust.raw\" which is not on the first and original DVD with barcode number 3 307210 206695 for the PAL version).</p>"},{"location":"Development/Run_Code/#serial-cable","title":"Serial Cable","text":"<p>The loader from Crawler360 requires a serial cable as described in Speedy22's docs. Note that the Xbox 360 serial port works with 3V levels and cannot be attached to a PC serial port directly. Even if you are working with xorloser's loader, a serial cable can be very useful for debugging purposes.</p> <p>Category: Development Category: Homebrew Software Category: Hardware Category: Support</p>"},{"location":"Development/Starting_Homebrew_Development/","title":"Starting Homebrew Development","text":""},{"location":"Development/Starting_Homebrew_Development/#requirements","title":"Requirements","text":"<ul> <li>Linux/MAC OS/Mingw (a virtual machine will just do fine)</li> <li>Installed Xenon Toolchain and     LibXenon of course</li> <li>LibXenon pulled from Free60 Git Repository</li> <li>Knowledge of C/C++</li> </ul>"},{"location":"Development/Starting_Homebrew_Development/#getting-into-it","title":"Getting into it","text":"<p>A little tutorial which explains how to setup NetBeans in Linux to develop LibXenon applications: Setup your PC for LibXenon Programming [PDF]</p> <p>You could start looking at a code example and write a program which (almost) everbody starts with: Hello World :)</p> <p>Category: Homebrew Software Category: Development</p>"},{"location":"Development/System_Calls/","title":"System Calls","text":"<p>The means for unprivileged code to query the Hypervisor for privileged tasks.</p>"},{"location":"Development/System_Calls/#making-a-system-call","title":"Making a System Call","text":"<p>Anywhere in unprivileged code you can make a system call by loading r0 with the call ID and executing the 'sc' instruction. Some system calls take additional parameters in r3-r9</p> <pre><code>    # Send 0xFF to POST output\n    li r3, 0xFF\n    li r0, 0xD\n    sc\n    blr\n</code></pre>"},{"location":"Development/System_Calls/#system-call-table","title":"System Call Table","text":"File Structure ID 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F 0x20 0x21 0x22 0x23 0x24 0x25 0x26 0x27 0x28 0x29 0x2A 0x2B 0x2C 0x2D 0x2E 0x2F 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x3A 0x3B 0x3C 0x3D 0x3E 0x3F 0x40 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4A 0x4B 0x4C 0x4D 0x4E 0x4F 0x50 0x51 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5A 0x5B 0x5C 0x5D 0x5E 0x5F 0x60 0x61 0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69 0x6A 0x6B 0x6C 0x6D 0x6E 0x6F 0x70 0x71 0x72 0x73 0x74 0x75 0x76"},{"location":"Development/UART/","title":"UART","text":"<p>The XBox 360 has an UART in the Southbridge.</p>"},{"location":"Development/UART/#registers","title":"Registers","text":"<p>To configure the UART, write to register <code>0x8000 0200 EA00 101C</code> (real mode)</p> Register value Configuration 0xE6010000 115200,8,N,1 0xB2010000 38400,8,N,1 0x63010000 19200,8,N,1 <p>To send a byte, do a 32 bit write to <code>0x8000 0200 EA00 1014</code>. After you sent something to the serial port, the status should be read from <code>0x8000 0200 EA00 1018</code>.</p>"},{"location":"Development/UART/#sample-code","title":"Sample code","text":"<p>Init UART speed:</p> <pre><code>    li        %r7, 0x0200\n    oris      %r7, %r7, 0x8000\n    sldi      %r7, %r7, 32\n    oris      %r7, %r7, 0xEA00\n    #ori       %r7, %r7, 0x101C\n    lis       %r8, 0\n    oris       %r8, %r8, 0xE601       # 115200,8,N,1\n    stw       %r8, 0x101C(%r7)\n</code></pre> <p>Send char '!' to the serial port (UART):</p> <pre><code>    li %r8, '!'\n    slwi %r8, %r8, 24\n    stw %r8, 0x1014(%r7)        # send the character\n    sync\n    isync\n1:\n    lwz %r8, 0x1018(%r7)        # wait until character is sent\n    rlwinm. %r8, %r8, 0, 6, 6\n    beq 1b\n</code></pre> <p>Get char from the serial port (UART):</p> <pre><code>     lis %r4, 0x8000\n     ori %r4, %r4, 0x200\n     rldicr %r4, %r4, 32,31\n     oris %r4, %r4, 0xEA00\n1:\n     lwz %r8, 0x1018(%r4)\n     rlwinm %r7, %r8, 0,8,5\n     cmplwi %r7, 0             # check the status of the UART before input\n     bne 1b\n     rlwinm. %r7, %r8, 0,7,7\n     beq 1b\n     lwz %r3, 0x1010(%r4)      # input char from address 8000 0200 EA00 1010\n     srwi %r3, %r3, 24\n</code></pre>"},{"location":"Development/UART/#serial-console","title":"Serial Console","text":"<p>The Serial Console can be very useful when debugging the Linux Kernel or diagnosing the Boot Process.</p>"},{"location":"Development/UART/#diagram-fat","title":"Diagram FAT","text":""},{"location":"Development/UART/#diagram-all","title":"Diagram ALL","text":"<p>You can either use the GND pin on the header (might be difficult to solder for the inexperienced) or some alternative GND pin like the one from the Stereo DAC nearby the J2B1 header.</p> <p>Note that you will probably need a Level Shifter to connect the 3.3V RX/TX pins to your PC Serial Port (which usually uses +/-12V)</p> <p>The Level Shifter can be either powered from the standby 3.3V on pin 7 (always on) or better from the active 3.3V on pin 8 or from an external power source.</p> <p>It is also possible to use some cheap cell phone data cables as a PC interface.</p> <p>Category: Hardware Category: Development Category: Homebrew Software</p>"},{"location":"Development/Xenon_Toolchain/","title":"Xenon Toolchain","text":""},{"location":"Development/Xenon_Toolchain/#windows","title":"Windows","text":""},{"location":"Development/Xenon_Toolchain/#installing-cygwin","title":"Installing Cygwin","text":"<ol> <li>Download Cygwin. Once it's done,     run the installer. Set the Install Directory to C:\\Cygwin, or what     ever your root drive path is.</li> <li>When prompted for a server, select anyone, they all have the same     packages, but I would recommend xmission.</li> <li>Make sure you install the necessary devs libs:<ul> <li><code>GCC</code></li> <li><code>Make</code></li> <li><code>Git</code></li> <li><code>build-essential</code></li> <li><code>texinfo</code></li> <li><code>Etc.</code></li> </ul> </li> </ol>"},{"location":"Development/Xenon_Toolchain/#linux","title":"Linux","text":""},{"location":"Development/Xenon_Toolchain/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>libgmp3-dev</code></li> <li><code>libmpfr-dev</code></li> <li><code>libmpc-dev</code></li> <li><code>texinfo</code></li> <li><code>git-core</code></li> <li><code>build-essential</code></li> </ul>"},{"location":"Development/Xenon_Toolchain/#mac-os-x","title":"Mac OS X","text":""},{"location":"Development/Xenon_Toolchain/#prerequisites_1","title":"Prerequisites","text":"<ol> <li>Install Xcode.</li> <li>Install macports, then \"sudo port install mpfr gmp git-core wget\"</li> <li>sudo mkdir /usr/local/xenon; sudo chown -R $USER /usr/local/xenon</li> <li>Do the \"Building the Toolchain\" stuff from below.</li> </ol> <p>If you're running Xcode 3.2, get Apple to fix this bug. Workaround is to compile until it fails with the \"duplicate symbol\" error (check build.log), then do the mentioned workaround in gcc-4.4.0/gcc directory (changing Make-lang.in), then disable the rebuild of binutils, gcc (first stage) and newlib by setting</p> <pre><code>BUILD_BINUTILS=false\nBUILD_GCC=false\nBUILD_NEWLIB=false\nBUILD_GCC_SECOND=true\n</code></pre> <p>in the build-xenon-toolchain. Then retry the build. It should finish the build.</p>"},{"location":"Development/Xenon_Toolchain/#building-the-toolchain","title":"Building the Toolchain","text":"<p>Run the following commands through the console your using:</p> <pre><code>git\u00a0clone\u00a0&lt;git://github.com/Free60Project/libxenon.git&gt;\ncd\u00a0libxenon/toolchain\n./build-xenon-toolchain\u00a0toolchain\n</code></pre> <p>The toolchain should start building (Note: This might take some time).</p>"},{"location":"Development/Xenon_Toolchain/#full-process-of-installation","title":"Full process of installation","text":"<p>To give people a start who are not used to Linux but want to start coding, here it goes. In this example I am refering to Ubuntu/Debian.</p> <p>First we install dependencies</p> <pre><code>apt-get\u00a0install\u00a0libgmp3-dev\u00a0libmpfr-dev\u00a0libmpc-dev\u00a0texinfo\u00a0git-core\u00a0gettext\u00a0build-essential\n</code></pre> <p>Now we create the target directory for the Toolchain &amp; Libxenon and own it by the current user Note: If your distro has the \"su\" command to get superuser rights, get superuser before typing the commands in the following block. Note: If not, append \"sudo\" before those commands (example: \"sudo mkdir -p /usr/local/xenon\")</p> <pre><code>mkdir\u00a0-p\u00a0/usr/local/xenon\nchown\u00a0-R\u00a0your_regular_user:your_regular_user\u00a0/usr/local/xenon\n#\u00a0exit\u00a0the\u00a0superuser-environment\u00a0now!\n</code></pre> <p>Then we grab the toolchain from git and build it</p> <pre><code>git\u00a0clone\u00a0&lt;git://github.com/Free60Project/libxenon.git&gt;\ncd\u00a0libxenon/toolchain`\n./build-xenon-toolchain\u00a0toolchain\n</code></pre> <p>Note: If gcc building, 2nd stage, fails for you, do \"apt-get install libgmp4-dev\" and restart building process.</p> <p>Note for Ubuntu users: If you encounter in the build.log following error:</p> <p><code>configure:\u00a0error:\u00a0Building\u00a0GCC\u00a0requires\u00a0GMP\u00a04.2+,\u00a0MPFR\u00a02.3.2+\u00a0and\u00a0MPC\u00a00.8.0+.</code></p> <p>Do the following:</p> <pre><code>cd\u00a0gcc-4.6.1\nwget\u00a0&lt;ftp://ftp.gmplib.org/pub/gmp-5.0.2/gmp-5.0.2.tar.bz2&gt;\ntar\u00a0xvjf\u00a0gmp-5.0.2.tar.bz2\u00a0&amp;&amp;\u00a0mv\u00a0gmp-5.0.2\u00a0gmp\nwget\u00a0&lt;http://www.multiprecision.org/downloads/mpc-0.9.tar.gz&gt;\ntar\u00a0xvzf\u00a0mpc-0.9.tar.gz\u00a0&amp;&amp;\u00a0mv\u00a0mpc-0.9\u00a0mpc\u00a0\nwget\u00a0&lt;https://www.mpfr.org/mpfr-3.0.1/mpfr-3.0.1.tar.gz&gt;\ntar\u00a0xvzf\u00a0mpfr-3.0.1.tar.gz\u00a0&amp;&amp;\u00a0mv\u00a0mpfr-3.0.1\u00a0mpfr\ncd\u00a0..\n./build-xenon-toolchain\u00a0toolchain\n</code></pre> <p>At the end of compiling it will tell you to add paths to your ~/.bashrc - that's an improper solution. Rather do it the following way:</p> <pre><code>#\u00a0Get\u00a0superuser\u00a0rights\u00a0first!\ntouch\u00a0/etc/profile.d/devkitxenon.sh\nchmod\u00a0+x\u00a0/etc/profile.d/devkitxenon.sh\n#\u00a0Now\u00a0open\u00a0the\u00a0file\u00a0and\u00a0insert\u00a0the\u00a0two\u00a0export\u00a0lines\nnano\u00a0/etc/profile.d/devkitxenon.sh\n#\u00a0Insert\u00a0the\u00a0lines\u00a0below\u00a0in\u00a0the\u00a0text\u00a0editor!\n</code></pre> <pre><code>export\u00a0DEVKITXENON=\"/usr/local/xenon\"\nexport\u00a0PATH=\"$PATH:$DEVKITXENON/bin:$DEVKITXENON/usr/bin\"\n</code></pre> <p>Press Ctrl+O for saving the file and press ENTER if it asks for a filename Press Ctrl+X for closing nano</p> <p>Have fun compiling your code ;)</p> <p>Category: Development</p>"},{"location":"Development/Xenos_Framebuffer/","title":"Xenos Framebuffer","text":"<p>Xenosfb - Framebuffer Device Driver for Xbox 360 Xenos graphics chipset</p> <p>This X.org device driver supports the Xenos graphics chipset as it is built into the Microsoft Xbox 360 gaming console. It is based on the X.org fbdev generic framebuffer device driver. Thus, it relies on the fbdevhw driver as well as a working frambuffer device within /dev.</p> <p>This driver is in a very early stage and does only support graphics access through the framebuffer kernel device. No 2D or 3D acceleration is supported and changing resolution at runtime does not work. Currently the screen resolution is inherited from the settings in the Xbox 360 Dashboard.</p> <p>Please note that all hardware information that was used to develop this driver has been gained solely by reverse engineering and trial and error. No official documentation or SDK has been used.</p>"},{"location":"Development/Xenos_Framebuffer/#compiling","title":"Compiling","text":"<p>It has following dependencies:</p> <ul> <li>libtool</li> <li>m4</li> <li>automake</li> <li>autoconf</li> <li>pkg-config</li> <li>xorg-dev</li> <li>xutils-dev</li> <li>x11-xserver-utils</li> <li>x11proto-randr-dev</li> <li>libxrandr-dev</li> </ul> <p>Probably some of these packages contain each other.</p> <p>Extract the sourcecode and make sure autogen.sh has the executable flag set. Start the compiling process by executing</p> <p><code>./autogen.sh</code></p> <p>After successful Compiling you will find the driver-module in *builddir*/src/.libs/xenosfb_drv.so Copy it to /usr/lib/xorg/modules/drivers/ Also make sure /etc/X11/xorg.conf holds at least the following:</p> <p><code>Section\u00a0\"Device\"</code> <code>Identifier\u00a0\u00a0\u00a0\u00a0\"Generic\u00a0Video\u00a0Card\"</code> <code>Driver\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"xenosfb\"</code> <code>Option\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"UseFBDev\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"true\"</code> <code>EndSection</code></p> <p>Category: Development Category: Linux</p>"},{"location":"Development/LibXenon/","title":"LibXenon","text":""},{"location":"Development/LibXenon/#summary","title":"Summary","text":"<p>libXenon is a library for writing programs for the Xbox 360, without using any existing code as a basis. That means that the resulting binaries should be free code, and don't contain stuff which would be illegal to distribute. This also means that you don't have to rely on Linux, which gives some advantages regarding system utilization.</p>"},{"location":"Development/LibXenon/#getting-libxenon","title":"Getting libXenon","text":"<p>libXenon is work-in-progress, and is available from Free60 Git Repository</p> <p>You can check out the source code using git with the following command:</p> <p><code>git\u00a0clone\u00a0git://github.com/Free60Project/libxenon.git</code></p> <p>(Windows users may want to try TortoiseGit)</p>"},{"location":"Development/LibXenon/#installing-libxenon","title":"Installing libXenon","text":"<p>To use libXenon you need a proper installation of Xenon Toolchain first. You just go into the toolchain-directory which holds <code>build-xenon-toolchain</code> and execute:</p> <p><code>./build-xenon-toolchain\u00a0libxenon</code></p> <p>This will download and install a fresh copy of libXenon Libraries to the <code>$DEVKITXENON</code>-path (Which should be defined in your ~/.bashrc already! - See bottom of Xenon Toolchain-page if it isn't!)</p>"},{"location":"Development/LibXenon/#support","title":"Support","text":"<p>libXenon (or devkitxenon) stuff is best discussed in the IRC or Discord</p>"},{"location":"Development/LibXenon/#sample-code","title":"Sample Code","text":"<p>Example code illustrating libXenon use can be found on the LibXenon Examples page.</p> <p>Category: Homebrew Software Category: Development</p>"},{"location":"Development/LibXenon/Examples/","title":"LibXenon examples","text":""},{"location":"Development/LibXenon/Examples/#xmenu-source-code-by-cpasjuste","title":"XMENU source code by cpasjuste","text":"<p>Download: libxenon.org</p>"},{"location":"Development/LibXenon/Examples/#genesis-plus-sms-plus-source-code-by-ced2911","title":"Genesis Plus + SMS Plus source code by ced2911","text":"<p>Genesis Plus: http://www.multiupload.com/6QYQL218GB</p> <p>SMS Plus: http://www.multiupload.com/62T7RVYB5A</p>"},{"location":"Development/LibXenon/Examples/#controller-button-test-code-by-ced2911","title":"Controller Button test code by ced2911","text":"<p>Source Code (incl. Makefile): Download</p> <pre><code> #include &lt;stdio.h&gt;\n #include &lt;stdlib.h&gt;\n #include &lt;input/input.h&gt;\n #include &lt;xenos/xenos.h&gt;\n #include &lt;console/console.h&gt;\n\n void mainInit()\n {\n    //init\n    xenos_init();\n    console_init();\n\n    kmem_init();\n    usb_init();\n    usb_do_poll();\n }\n int main()\n {\n    mainInit();\n    printf(\"Test\\n\");\n\n    struct controller_data_s oldc;\n    while(1)\n    {\n        struct controller_data_s c;\n        if (get_controller_data(&amp;c, 0))\n        {\n\n            if((c.a)&amp;&amp;(!oldc.a))\n            {\n                printf(\"a pushed\\n\");\n            }\n            if((!c.a)&amp;&amp;(oldc.a))\n            {\n                printf(\"a released\\n\");\n            }\n            oldc=c;\n        }\n        usb_do_poll();\n    }\n    return 0;\n }\n</code></pre>"},{"location":"Development/LibXenon/Examples/#compiling-libxenon-code","title":"Compiling LibXenon Code","text":"<p>All of these samples/programs include a Makefile, so its easy to compile them with the Toolchain.</p> <pre><code>cd\u00a0into_the_directory\nmake\u00a0CROSS_COMPILE=xenon-\n</code></pre> <p>When you are writing your own programs you can just take the Makefile from this HelloWorld application, put it in your sourcecode-folder and move all the sourcecode-files of your project into a folder \"source\" so the Makefile can find them.</p> <p>Category: Homebrew Software Category: Development</p>"},{"location":"Hacks/King_Kong_Hack/","title":"King Kong Hack (outdated)","text":""},{"location":"Hacks/King_Kong_Hack/#1-you-need-an-xbox-with-a-kernel-version-of-4532-or-4548","title":"1. You need an Xbox with a kernel version of 4532 or 4548","text":"<p>You can check your kernel version in \"System -&gt; Console Settings -&gt; System Info\". The line at the bottom contains your kernel version in the format K:2.0.nnnn.0, where nnnn is your four digit kernel version. The kernel version can be older (lower number) than 4532 or 4548, but not newer (higher number). If you already have a newer version, there is nothing you can do right now. If you buy an Xbox, make sure that its manufacturing date is before 09 January 2007, so that the kernel version is 4548 or older. You can see the manufacturing date (\"MFR Date\") through the carton without opening it. Note, I have just got a new UK core pack with a MFG date of 19th June 2007, with all the new heatsink inside and the kernel version was one of the 2000 ones, so very old kernel on brand new xbox 360s. Note, I have just bought a premium pack with a MFG date of 16th May 2006, and the kernel version was 5759, so a new kernel on a 2006's Xbox 360.</p> <p>Source: Run_Code</p>"},{"location":"Hacks/King_Kong_Hack/#2-upgrading-the-kernel-to-4532","title":"2. Upgrading the kernel to 4532","text":"<p>If your kernel version is older than 4532 or 4548, you can update to one of these versions. Do not update to a version newer than 4598! You won't be able to downgrade! If you have a pre-4532 kernel, you need to get the file HD_DVD_10-2006.zip, check the MD5SUM to be cd4db8e2c94266ab73513c361dd5b8f6 (important!), burn it to a CD, and insert the CD into your Xbox 360. The program will update your machine to kernel version 4532. This file is an authentic Microsoft update application, but is not available on Microsoft's servers any more. If you own an Xbox, it should be legal for you to download and run this application. IMPORTANT: If you use a HDD and previously canceled a XBOX Live Update request, then you must remove the HDD to prevent the Kernel updater using the cached Kernel Updater, which is newer then the Kernel 4532! If you don't remove the HDD, then the Kernel Updater will use the cached Kernel Updater from the HDD and not from the CD!</p> <p>Source: Run_Code</p> <p>Download: Here</p>"},{"location":"Hacks/King_Kong_Hack/#3-flashing-the-dvd-rom-drive","title":"3. Flashing the DVD-ROM Drive","text":"<p>Different tactics depending on the DVD model in your box. There are some excellent Firmware Flashing Tutorials on the net, which we won't link here for site policy reasons. This does mean opening your Xbox 360 as such warranty is void, Microsoft are known to be working on a way of checking this and banning any flashed Xbox 360's from Xbox Live.</p>"},{"location":"Hacks/King_Kong_Hack/#4-buy-king-kong-and-make-an-image","title":"4. Buy King Kong and make an image","text":"<p>There are two versions of King Kong available. The patcher currently does not work with the newer \"classics\" version of \"King Kong\". If in doubt, buy the oldest version you can get. Backing up won't be covered here for site policy reasons, but the net is your friend again.</p>"},{"location":"Hacks/King_Kong_Hack/#5-patch-your-king-kong-image","title":"5. Patch your King Kong image","text":"<p>There are two King Kong patches available right now. The first was the one by Crawler360: Launch the modified game, press START on the title screen, and a very simple loader will be launched that allows uploading your code through a serial cable. There is a newer patch in the wild by xorloser, which allows booting directly from CDROM.</p> <p>Patch your King Kong ISO with either the windows exe or compile the source for Linux. If you're using the windows patch, you will need to download cygwin1.dll and put it into your windows/system32 folder. Then make sure shader.bin, the exe, and your King Kong ISO are in the same folder and run: win_patch.exe  or ./linux_patch  After your ISO is patched, burn it like a normal game. <p>Source: Included readme</p> <p>Download: Here</p>"},{"location":"Hacks/King_Kong_Hack/#6-get-linux","title":"6. Get Linux","text":"<p>\u201dThis LiveCD is based on the BETA Gentoo LiveCD. It includes our X.org framebuffer driver and a Gnome Desktop environment. Download size is around 600MB.\u201d</p> <p>Use the BETA v2 release or later in case you have a Samsung drive. Hitachi drive users do not need to care. You may use re-writeable medias for the distributions as they may improve now in short distances... :-)</p> <p>Source: LiveCD</p> <p>Download: Here</p>"},{"location":"Hacks/King_Kong_Hack/#7-get-it-started","title":"7. Get it started","text":"<p>Switch on your Xbox 360, and load up the patched King Kong, and press start on the title screen. Wait until the tray opens. Insert the Linux CD. Close the tray. A few second later, you should be greeted by some penguins.</p>"},{"location":"Hacks/King_Kong_Hack/#8-install-it-to-harddisk-optional","title":"8. Install it to Harddisk (optional)","text":"<p>Guide: Here</p> <p>Debian etch install Script (Recommended)</p> <p>Ubuntu 7.10 install Script</p> <p>Category: Support</p>"},{"location":"Hacks/NAND_Bad_Blocks/","title":"Bad Blocks","text":""},{"location":"Hacks/NAND_Bad_Blocks/#what-is-a-block","title":"What is a BLOCK?","text":"<p>A block is the smallest logically addressable unit of data that a specified device can transfer in an input/output operation. For XBOX 360s that is either 16KB or 128KB.</p>"},{"location":"Hacks/NAND_Bad_Blocks/#what-is-a-bad-block","title":"What is a BAD BLOCK?","text":"<p>Bad Blocks are blocks that contain one or more invalid bits whose reliability is not guaranteed. Bad Blocks may be present when the device is shipped, or may develop during the lifetime of the device.</p>"},{"location":"Hacks/NAND_Bad_Blocks/#how-to-determine-bad-blocks","title":"How to determine BAD BLOCKS?","text":"<p>In one block there are n Pages, all have a fixed size of 528 Bytes (nomatter if the Block is 16K or 128K). Every Page has 16 Byte big ECC data at its end. The block itself does not have ECC data, only the pages have! In theory the whole block gets filled with zeros if its bad, practicly it's not like that. So, if the first 12 Bytes of the page's ECC data is nulled, the page is marked bad, so the whole block is aswell. The remaining 4 Bytes of the ECC is the CRC Data. If the first 12 Bytes of ECC is 0xFF the page has no data (empty, but NOT faulty) and if it hold anything else than 0x00 or 0xFF then the page is filled with data.</p>"},{"location":"Hacks/NAND_Bad_Blocks/#what-happens-when-a-bad-block-develops","title":"What happens when a BAD BLOCK develops?","text":"<p>There are two methods to replace the block.</p> <ul> <li> <ol> <li>Skip Block Method</li> </ol> </li> <li> <ol> <li>Reserve Block Method</li> </ol> </li> </ul>"},{"location":"Hacks/NAND_Bad_Blocks/#how-does-the-reserve-block-method-work","title":"How does the Reserve Block Method work?","text":"<p>Blocks are not skipped but rather they are re-directed to a Reserved Block Area used specifically for Bad Block replacement. The Reserved Block Area also stores/saves the Bad Block Table that keeps track of the re-mapped \u201cdeveloped Bad Blocks\u201d. Which method does the XBOX employ?</p> <p>Short answer both. In 16MB nands the XBOX exclusively uses the Reserve Block Method, while in 256MB or 512MB nands it uses both. The MU area of the nand uses the Skip Block Method, while the area where the dash and kernel are stored uses the Reserve Block Method.</p>"},{"location":"Hacks/NAND_Bad_Blocks/#xbox-16mb-nand-block-management","title":"XBOX 16MB NAND BLOCK Management","text":"<p>If you noticed in the memory table above any Badblocks encountered are consecutively moved to the Reserved BadBlock Area. The first Bad Block(0x168) is moved to Block 0x3FF in the reserved area, the next(0x1F6) is moved to 0X3FE, and it continues until all Bad Blocks have been remapped.</p>"},{"location":"Hacks/NAND_Bad_Blocks/#when-i-read-my-nand-i-have-badblocks-where-is-that-data-stored","title":"When I read my nand I have Badblocks where is that data stored?","text":"<p>When reading your nand any Badblocks would have already been remapped to the reserve area. This is important to keep in mind, specifically when you encounter Badblocks where crucial data is kept such as blocks 0x001(Key Vault), 0x3DE(First Config Block), and 0x3DF(Second Config Block).</p>"},{"location":"Hacks/NAND_Bad_Blocks/#how-would-i-remap-the-badblocks-in-the-diagram-with-nandpro","title":"How would I remap the BadBlocks in the diagram with nandpro?","text":"<p>Assuming your attempting to flash the latest release of XBReboot named as \u2018xbr.bin\u2019. And have made a full-backup and have already injected your Key Vault and Configuration Blocks into \u2018xbr.bin\u2019. The commands would be as follow:</p> <pre><code>nandpro\u00a0xbr.bin:\u00a0-r16\u00a0badblock168.bin\u00a0168\u00a01\nnandpro\u00a0xbr.bin:\u00a0-w16\u00a0badblock168.bin\u00a03FF\u00a01\nnandpro\u00a0xbr.bin:\u00a0-r16\u00a0badblock1F6.bin\u00a01F6\u00a01\nnandpro\u00a0xbr.bin:\u00a0-w16\u00a0badblock1F6.bin\u00a03FE\u00a01\nnandpro\u00a0xbr.bin:\u00a0-r16\u00a0badblock23A.bin\u00a023A\u00a01\nnandpro\u00a0xbr.bin:\u00a0-w16\u00a0badblock23A.bin\u00a03FD\u00a01\nnandpro\u00a0xbr.bin:\u00a0-r16\u00a0badblock308.bin\u00a0308\u00a01\nnandpro\u00a0xbr.bin:\u00a0-w16\u00a0badblock308.bin\u00a03FC\u00a01\n</code></pre>"},{"location":"Hacks/NAND_Bad_Blocks/#if-using-xellous-to-flash-do-i-need-to-remap-badblocks","title":"If using XeLLous to flash do I need to remap Badblocks?","text":"<p>According to the XeLLous release notes no, it is suppose to be one of the main features of the update. That is not to say bugs might not be encountered. If you encounter suspicious issues, and believe it might be related to a bad flash, then I recommend flashing manually with nandpro or using trancy\u2019s XBR-Flash for Linux.</p>"},{"location":"Hacks/NAND_Bad_Blocks/#i-have-a-badblock-between-blocks-0x000-and-0x050-and-cant-boot-into-xell-free60-version","title":"I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (free60 version).","text":"<p>First of all ensure your using the free60 version of Xell. Next you will need to backup the location of the remapped BadBlocks like so (Remeber your first Badblock always goes to 3FF, and each following Badblock gets remapped as illustrated in the diagram):</p> <p><code>nandpro\u00a0lpt:\u00a0-r16\u00a0backup3FF.bin\u00a03FF\u00a01</code></p> <p>Assuming your first Badblock was at 0x010, you will need to remap the free60 Xell data that was intended to be stored in that block. Like this.</p> <p><code>nandpro\u00a0xell.bin:\u00a0-r16\u00a0xell10.bin\u00a010\u00a01</code> <code>nandpro\u00a0lpt:\u00a0-w16\u00a0xell10.bin\u00a03FF\u00a01</code></p> <p>Lastly the bad block needs to erased to prevent any corruption:</p> <p><code>nandpro\u00a0lpt:\u00a0-e16\u00a010\u00a01</code></p> <p>(EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.)</p>"},{"location":"Hacks/NAND_Bad_Blocks/#i-have-a-badblock-between-blocks-0x000-and-0x050-and-cant-boot-into-xell-rgh-team-xecuter-dgx-version","title":"I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (RGH / Team-Xecuter DGX version).","text":"<p>XeLL for RGH/DGX is written with +w16 ('+' to signify the recreation of ECC data) so you cannot simply -r16 from image_00000000.ecc (or DGX.ecc) as it's not seen by NANDPro as a valid VNAND.</p> <p>Therefore, the following steps must be carried out:</p> <p>Assuming your first Badblock was at 0x010,</p> <ol> <li>Make a copy of your original NAND</li> </ol> <p><code>copy\u00a0nanddump.bin\u00a0tempnand.bin</code></p> <ol> <li>Write the ECC to your NAND as per normal:</li> </ol> <p><code>nandpro\u00a0[LPT|USB]:\u00a0+w16\u00a0image_00000000.ecc.</code></p> <p>At this point you should confirm that you get an 'error xxx writing to xxx' message. This is perfectly normal.</p> <ol> <li>Write the ECC to tempnand.bin using NANDPro:</li> </ol> <p><code>nandpro\u00a0tempnand.bin:\u00a0+w16\u00a0image_00000000.ecc</code></p> <ol> <li>Read block 0x010 from your newly written-to VNAND:</li> </ol> <p><code>nandpro\u00a0tempnand.bin:\u00a0-r16\u00a0010.bin\u00a010\u00a01</code></p> <p>5. Write the block to the same place in the spare area as the original relocated bad block. If this is the first bad block, it should be 0x3FF but check using 360 Flash Dump Tool, xNANDHealer, J-Runner etc to ensure this is the case.</p> <p><code>nandpro\u00a0[LPT|USB]:\u00a0-w16\u00a0010.bin\u00a03FF</code></p> <p>Lastly the bad block needs to erased to prevent any corruption:</p> <p><code>nandpro\u00a0lpt:\u00a0-e16\u00a010\u00a01</code></p> <p>(EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.)</p> <p>--Xb0xGuru 15:19, 24 February 2013 (UTC)</p>"},{"location":"Hacks/NAND_Bad_Blocks/#xbox-256512mb-nand-block-management","title":"XBOX 256/512MB NAND BLOCK Management","text":""},{"location":"Hacks/NAND_Bad_Blocks/#understanding-256512-mb-memory-map-and-nandpros-translation","title":"Understanding 256/512 MB memory map, and Nandpro\u2019s translation:","text":"<p>The block size in 256/512 Nands is 132 KB (135168 Bytes). This is a little different then how Nandpro references and addresses blocks. No matter the Block size of your nand nandpro uses a block size of 16 KB that means that for every Badblock in the 256/512 MB nandpro will report 8 consecutive errors.</p> <p>If you noticed in the memory table above any Badblocks encountered are consecutively moved to the Reserved BadBlock Area. The first Badblock (0x0F8) is moved to Block 0xFF8 (16 KB) or Block 0x1FF (132 KB) in the reserved area, any consecutive Badblocks would of been moved to blocks 0xFF0 (16 KB) or Block 0x1FE (132 KB) and so forth.</p>"},{"location":"Hacks/NAND_Bad_Blocks/#when-i-read-my-nand-i-have-badblocks-where-is-that-data-stored_1","title":"When I read my nand I have Badblocks where is that data stored?","text":"<p>When reading your nand any Badblocks would have already been remapped to the reserve area. This is important to keep in mind, specifically when you encounter Badblocks where crucial data is kept such as blocks 0x001(Key Vault), 0xEF7(Config Block),.</p>"},{"location":"Hacks/NAND_Bad_Blocks/#how-would-i-remap-the-badblocks-in-the-diagram-with-nandpro_1","title":"How would I remap the BadBlocks in the diagram with nandpro?","text":"<p>Assuming your attempting to flash the latest release of XBReboot named as \u2018xbr.bin\u2019. And have made a full-backup and have already injected your Key Vault and Configuration Blocks into \u2018xbr.bin\u2019. The commands would be as follow:</p> <p><code>nandpro\u00a0xbr.bin:\u00a0-r16\u00a0badblockF8.bin\u00a0F8\u00a08</code> <code>nandpro\u00a0xbr.bin:\u00a0-w16\u00a0badblockF8.bin\u00a0FF8\u00a08</code></p> <p>Is 8 correct? Yes remember nandpro reference blocks in sizes of 16 KB, but 256/512 MB have a block size of 132 KB. 132/16 is equal to 8, that why you need to use 8.</p>"},{"location":"Hacks/NAND_Bad_Blocks/#if-using-xellous-to-flash-do-i-need-to-remap-badblocks_1","title":"If using XeLLous to flash do I need to remap Badblocks?","text":"<p>According to the XeLLous release notes no, it is suppose to be one of the main features of the update. That is not to say bugs might not be encountered. If you encounter suspicious issues, and believe it might be related to a bad flash, then I recommend flashing manually with nandpro or using trancy\u2019s XBR-Flash for Linux.</p>"},{"location":"Hacks/NAND_Bad_Blocks/#i-have-a-badblock-between-blocks-0x000-and-0x050-and-cant-boot-into-xell-free60-version_1","title":"I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (free60 version).","text":"<p>First of all ensure your using the free60 version of Xell. Next you will need to backup the location of the remapped BadBlocks like so (Remeber your first Badblock always goes to 0xFF8, and each following Badblock gets remapped to the spare):</p> <p><code>nandpro\u00a0lpt:\u00a0-r256\u00a0backupFF8.bin\u00a0FF8\u00a08</code></p> <p>Assuming your first Badblock was at 0x010 followed by seven more errors, you will need to remap the free60 Xell data that was intended to be stored in that block. Like this.</p> <p><code>nandpro\u00a0xell.bin:\u00a0-r16\u00a0xell10.bin\u00a010\u00a08</code> <code>nandpro\u00a0lpt:\u00a0-w16\u00a0xell10.bin\u00a0FF8\u00a08</code></p> <p>Lastly the bad block needs to erased to prevent any corruption:</p> <p><code>nandpro\u00a0lpt:\u00a0-e16\u00a010\u00a01</code></p> <p>(EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.)</p>"},{"location":"Hacks/NAND_Bad_Blocks/#i-have-a-badblock-between-blocks-0x000-and-0x050-and-cant-boot-into-xell-rgh-team-xecuter-dgx-version_1","title":"I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (RGH / Team-Xecuter DGX version).","text":"<p>XeLL for RGH/DGX is written with +w16 ('+' to signify the recreation of ECC data) so you cannot simply -r16 from image_00000000.ecc (or DGX.ecc) as it's not seen by NANDPro as a valid VNAND.</p> <p>Therefore, the following steps must be carried out:</p> <p>Assuming your first Badblock was at 0x010,</p> <p>1. Make a copy of your original NAND</p> <p><code>copy\u00a0nanddump.bin\u00a0tempnand.bin</code></p> <p>2. Write the ECC to your NAND as per normal:</p> <p><code>nandpro\u00a0[LPT|USB]:\u00a0+w16\u00a0image_00000000.ecc</code></p> <p>At this point you should confirm that you get an 'error xxx writing to xxx' message. This is perfectly normal.</p> <p>3. Write the ECC to tempnand.bin using NANDPro:</p> <p><code>nandpro\u00a0tempnand.bin:\u00a0+w16\u00a0image_00000000.ecc</code></p> <p>4. Read block 0x010 from your newly written-to VNAND:</p> <p><code>nandpro\u00a0tempnand.bin:\u00a0-r16\u00a0010.bin\u00a010\u00a08</code></p> <p>5. Write the block to the same place in the spare area as the original relocated bad block. If this is the first bad block, it should be 0x3FF but check using 360 Flash Dump Tool, xNANDHealer, J-Runner etc to ensure this is the case.</p> <p><code>nandpro\u00a0[LPT|USB]:\u00a0-w16\u00a0010.bin\u00a0FF8</code></p> <p>Lastly the bad block needs to erased to prevent any corruption:</p> <p><code>nandpro\u00a0lpt:\u00a0-e16\u00a010\u00a08</code></p> <p>(EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.)</p> <p>--Xb0xGuru 15:19, 24 February 2013 (UTC)</p> <p>Source: google-docs (archive.org mirror) &amp; XBH, posted by trancy</p> <p>Category: Hardware Category: System Software</p>"},{"location":"Hacks/NAND_Reading/","title":"NAND reading","text":"<p>This tutorial explains how to read the Xbox360's NAND/Flash via a PC's parallel/\"printer\" port in as clean and easy as possible a way. The same method is used to dump all models of the Xbox 360 (Xenon, Zephyr, Falcon, Opus, Jasper).</p> <p>Please keep quick &amp; dirty setups and speculation out or, in case some guesswork is really needed, flag them, so this article and the whole wiki can develop as trustworthy sources.</p> <p>There are guides to dump via USB, but compared to this it's quite expensive and easily found with a search. Maybe someone will add one later on.</p> <p>Moreover thanks to tmbinc, Tiros, Redline and all else involved (feel free to add their names) for their great work! :)</p>"},{"location":"Hacks/NAND_Reading/#requirements","title":"Requirements","text":"<p>First of all, you'll need soldering skills\u2014if you've never used a soldering iron before, you should train on a less expensive object. This skill level is similar to adding a modchip to a console.</p> <p>You'll need the following:</p> <ul> <li>Prerequisites:</li> </ul> <p>:*LPT (parallel) port (preferably supporting SPP)</p> <ul> <li>Components:</li> </ul> <p>:*1 \u00d7 diode BAT41 - There are several diodes you can use. People on xboxhacker.net had the best experiences with BAT41, others used N4148. I (kote) used PH4148.</p> <p>:*5 \u00d7 100\u2013120 \u03a9 resistors - not a must-have, but it'll protect your box</p> <p>:*LPT cable - Hollow connector housings will make your life easier. Alternatively, use a bare DB25 male connector and wire.</p> <ul> <li>Tools:</li> </ul> <p>:*Multimeter - (Voltmeter/Continuity)</p> <p>:*Soldering Iron</p> <p>:*A lot of patience and spare time ;) - A third hand will make your life easier, too</p> <ul> <li>Software</li> </ul> <p>:*32-bit OS/PC - The necessary PortIO(?-Guessing) driver is available for 32-bit systems only. There is a 64-bit port, however NandPro2 compatibility is unknown (22/08/2009). Since many 64-bit systems don't have a parallel port, this shouldn't affect many people.</p> <p>:*64-bit Update: Go here. Download 'Binaries only - x86 &amp; x64 DLLs and libs'. Extract inpout32.dll from Win32 folder to nandpro folder. Rename inpout32.dll to DLPortIO.dll (credit)</p> <p>:*NandPro - NandPro (by User:Tiros Tiros on xboxhacker.net - for reading out the NAND image.) seems to work with Windows Vista 32-bit and Windows 7 32-bit. Windows XP Compatibility Mode or running with administrator rights may be necessary. XP or earlier is preferred.</p> <p>:*Verifying NAND Dumps:</p> <p>::*File comparison Utility - MD5SUM, SHA1SUM, (Total Commander)</p> <p>::*360 Flash Tool - (there are different versions! The latest is V0.88a CD FIXED [22/08/2009])</p> <p>::*NAND Compare and Reconstruction Tool - (compare 2 nand images or reconstruct image from 3 bad reads)</p>"},{"location":"Hacks/NAND_Reading/#photos","title":"Photos","text":"<p>1 2 3</p>"},{"location":"Hacks/NAND_Reading/#steps","title":"Steps:","text":""},{"location":"Hacks/NAND_Reading/#preparing-the-cable","title":"Preparing the cable","text":"<p>First of all, there are different kinds of LPT cables out there. If you got one with at least one male DB25 connector, you will be fine. There are also cables with two DB25 connectors and possibilites to do it without any DB25 connector. However, this tutorial is supposed to be as universal as possible, so we will behave like there are only cables with one connector.</p> <p>Well, whatever is on the other end of your cable, cut it off. So you will get a cable with a DB25 connector at one side and loose wires on the other side.</p> <p>Now you need to trace the wires in the cable. If you've got a cable with openable plug housings, you're in luck: just open the housings and compare single wires with those on the loose end. Otherwise it's time for your continuity tester. You will need to know which wire goes to which pin at the end. Write down the colour of the wire attached to each pin. Since there are only seven needed wires, you don't have to trace every wire. The following pins need to be connected: 1, 2, 11, 14, 16, 17, 18. In case a pin isn't connected, just resolder a wire from an unneeded pin (e.g., 15) to the needed one (e.g., 14).</p> <p>I (some11) bought a LPT Cable (Nikkai LPT Parallel Printer Cable [L79BT]) from Maplins.</p> <p>http://i45.tinypic.com/29lhggk.jpg</p> <p>Here is the wire color map output:</p>   Pin     Color (Main/Second)     Pin     Color (Main/Second)   Pin 1   Yellow     Pin 13     Black   Pin 2   Pink Black   Pin 14   White     Pin 3     Pink     Pin 15     Grey Black     Pin 4     Orange Black   Pin 16   Grey     Pin 5     Orange White   Pin 17   Purple White     Pin 6     Orange   Pin 18   Purple     Pin 7     Red Black     Pin 19     Blue White     Pin 8     Red White     Pin 20     Blue     Pin 9     Red     Pin 21     Green (Different)     Pin 10     Brown White     Pin 22     Green Black   Pin 11   Brown     Pin 23     Green White     Pin 12     Black White     Pin 24     Green     Pin 25     Yellow Black   <p>After you've done that, you can cut the unneeded wires at the loose end so they won't bother you while soldering. Strip a small amount of insulation (5 mm should be plenty) from the end of each of the other wires, and twist the loose strands inside together. Tin each wire, so that you get nice and sweet clean wires.</p>"},{"location":"Hacks/NAND_Reading/#opening-the-xbox-360","title":"Opening the Xbox 360","text":"<p>http://www.anandtech.com/printarticle.aspx?i=2610</p>"},{"location":"Hacks/NAND_Reading/#preparing-and-soldering","title":"Preparing and Soldering","text":"<p>Once you have a clear view of the board, it's time to locate the solder pads of J1D2 (red) and J2B1 (blue).</p> <p>http://www.abload.de/img/locationnoqa.jpg</p> <p>You will have to establish the following connections:</p>   LPT(DB25)     Component     Xbox 360     DB25.1     resistor     J1D2.2     DB25.2     resistor     J1D2.3     DB25.11     diode     J1D2.4     DB25.14     resistor     J1D2.1     DB25.16     resistor     J2B1.6     DB25.17     resistor     J2B1.5     DB25.18     nothing     J1D2.6, J2B1.12, or a screwhole   <p>http://www.abload.de/img/connectiontableaolh.jpg</p> <p>This is how you count on a board: http://www.abload.de/img/howtocount5y02.jpg</p> <p>The square is always 1, in this case J2B1.1. Also, notice the white dot near pin 1 and the labels near pins 2, 12, and 13.</p> <p>\"Component\" means that you will have to add the resistor or diode between those two points. I suggest that you first solder the component on the board and after that the wire to the component. The diode's black ring has to be in the direction of the Xbox board. By \"screwhole\", we mean a screwhole. (The ground (or \"earth\") connection we're using is also present on J1D2.6 and J2B1.12, but those are difficult to solder.) Solder the wire from DB25.18 to one of those big reddish rings (where the long screws go through the DVD-ROM drive legs), and fix it with insulation tape (NOT DUCT TAPE! Otherwise you will damage your Xbox). '''It is important that you solder the diode directly to the board. It won't work if it's in the plug housing! ''' LPT (parallel port) connections are the same for Xenon, Zephyr, Falcon, Opus, and Jasper (but JTAG connections are different between Xenon motherboards and the other ones).</p> <p>New Xenon exploit diagram: http://i.imgur.com/Fdjmi.png</p> <p>Diagram (including LPT &amp; JTAG connections): https://web.archive.org/web/20111202124409/http://img710.imageshack.us/img710/31/spidiagramsandungas.png</p> <p>Another diagram (including LPT &amp; JTAG connections): https://web.archive.org/web/20111202142124/http://img12.imageshack.us/img12/4983/xenondiagram.jpg</p> <p>Slim diagram: http://imageshack.us/photo/my-images/32/lptslim.png/</p>"},{"location":"Hacks/NAND_Reading/#checklist","title":"Checklist","text":"<ul> <li>Is every wire connected to the correct pin?</li> <li>Are there any short circuits or doubly connected wires? (Watch out     for sprawling solder!)</li> <li>Have you taken everything out of the box that doesn't belong in     there?</li> </ul> <p>When you've checked that, plug the parallel cable into your turned-off computer, the power supply into your Xbox, and the power cable into the power outlet.</p>"},{"location":"Hacks/NAND_Reading/#setting-up-your-pc","title":"Setting up your PC","text":"<p>Turn on your PC. It's possible that your Xbox will turn on, too. Don't worry, just leave it turned on. As long as it doesn't start to smoke, smell, or anything else weird it will be fine. Later on, it should turn off the fans on its own, but the LEDs will remain blinking. If it doesn't turn on: don't worry, it doesn't have to be turned on while reading the NAND.</p> <p>Go to the BIOS settings and search for LPT mode settings. Tiros recommends SPP/Normal mode in his help file (Nandpro.txt), but the mode doesn't actually appear to matter. If you're having trouble in the next step, give a different mode a try. After you have done that, save settings and leave BIOS. Boot up Windows.</p> <p>Now the time has come to unpack NandPro2. In the archive you'll find port95nt.exe (driver) and some other files (e.g. NandPro.exe). Install the driver. If you're using Vista or higher, you might have to turn on XP Compatibility Mode, as already mentioned. To install it, just double-click on it and walk through the setup. There shouldn't be any error messages. Then: reboot.</p>"},{"location":"Hacks/NAND_Reading/#readingdumping-the-nand-twice-and-drinking-coffee","title":"Reading/Dumping the nand twice and drinking coffee.","text":"<p><code>Prepare\u00a0the\u00a0coffee.\u00a0;)</code></p> <p>Windows should have booted up now. Open up Windows Command Prompt (press Windows Key + R to open up Run. Type cmd and press Enter).</p> <p>Navigate to NandPro's installation directory by using common commands (cd, dir, and the TAB key for auto-completion). Then type nandpro.exe lpt: -r16 nand1.bin and press enter. If everything's fine, it should output this:</p> <p><code>Testing\u00a0LPT\u00a0device\u00a0address:0378\u00a0\u00a0\u00a0//\u00a0address\u00a0can\u00a0differ</code> <code>Using\u00a0LPT\u00a0device\u00a0at\u00a0address:0378\u00a0\u00a0//\u00a0address\u00a0can\u00a0differ</code> <code>FlashConfig:01198010\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0must\u00a0be\u00a0the\u00a0same\u00a0(except\u00a0Jasper\u00a0boards,\u00a0see\u00a0next\u00a0block)</code> <code>Starting\u00a0Block:0x000000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0Starting\u00a0and\u00a0ending\u00a0should\u00a0be\u00a0as\u00a0shown\u00a0here\u00a0if\u00a0you\u00a0want</code> <code>Ending\u00a0\u00a0\u00a0Block:0x0003FF\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0to\u00a0read\u00a0the\u00a0whole\u00a0flash\u00a0[you\u00a0want!\u00a0:p]</code></p> <p>If you get FlashConfig: 0012000 try soldering the diode directly to the motherboard instead on having it on the conector side. It worked for iD4rK, and others.</p> <p>The Flashconfig is dependant on the mainboard version, other valid values are:</p> <p><code>FlashConfig\u00a0-\u00a0System\u00a0Types</code> <code>01198010\u00a0-\u00a0Xenon,\u00a0Zephyr,\u00a0Opus,\u00a0Falcon</code> <code>00023010\u00a0-\u00a0Jasper\u00a016mb</code> <code>008A3020\u00a0-\u00a0Jasper\u00a0256mb</code> <code>00AA3020\u00a0-\u00a0Jasper\u00a0512mb</code></p> <p>Press any key to continue. It should start to count up addresses. If it starts to output stuff like \"Error 0 .. blah blah\" something's wrong. Recheck wiring, change LPT mode, or try a different computer. It is possible that there are one or two bad blocks on your NAND (error 25x), so don't worry if you get that error once or twice.</p> <p>Well, the reading (dumping) process will take about half an hour. So head to your coffee machine. ;) Unfortunately, we will need at least two dumps to check whether there are really no failures in your dump. So once NandPro has finished dumping, press the up arrow key (or retype the command), CHANGE THE FILENAME TO NAND2.BIN, press Enter, and dump it a second time. Get another coffee. Or turn on the TV. Maybe you have got a girlfriend?</p> <p>When NandPro2 has finished the second dump without errors close the command-line.</p>"},{"location":"Hacks/NAND_Reading/#checking-for-errors","title":"Checking for errors","text":"<p>First, open up both files with 360 Flash Tool. If it looks like in the picture beneath this, everything should be fine. If an error message \"Couldn't open file\" pops up, something went wrong.</p> <p>:*http://www.abload.de/img/360flashtool4ld2.jpg Second, start up Total Commander. Choose File -&gt; Compare by content. A new window will open. Select both files and click on compare. If they are identical: congratulations! You are done with this. =)</p> <p>If not, search for errors in wiring etc. or try a different PC.</p> <p>:*http://www.abload.de/img/totalcommander6zw7.jpg While 360 Flash Tool will show you the content of the NAND, it's not a conclusive check whether the integrity is good: it's possible to get a \"thumbs up\" from the utility even if you have corrupted (and more importantly, vital) blocks. A much better check is to run the resulted image through Degraded v1.1, which will highlight any errors.</p> <p>A NAND with bad blocks usually looks like this:</p> <p>:*https://web.archive.org/web/20111202132655/http://www.infectus.biz/INFECTUS-BOOK/Tutorial_Eng/Xbox360/Timing_Attack_Infectus/File/Bad_Block_DUMP.jpg</p> <p>Note in this example that the bad block information has been located elsewhere, so you *should* be okay. Even so, it's advisable to run a second dump through the utility and see whether this has a bad block (and relocated) in the exact same address. If this is the case, you should be good to go.</p> <p>A good NAND dump might look like this:</p> <p>:*https://web.archive.org/web/20111202140910/http://www.infectus.biz/INFECTUS-BOOK/Tutorial_Eng/Xbox360/Timing_Attack_Infectus/File/Degraded_1.jpg</p> <p>If you get this, great :) Your NAND dump is about as good as it's gonna be!</p> <p>NAND Compare and Reconstruction Tool A nice tool to check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps.</p> <p>- compare 2 nand images</p> <p>better than simply using md5 as it tells you which blocks are mismatched, which allows you to reread only those that are in error rather than the entire chip (speeding up the process) one use of this is when verifying a write by reading back the nand and comparing it against the original you wrote, if you get a bad block just reread that individual block, patch it into the full read and compare again (files are reread each time you click compare, no need to reselect the same files in the gui)</p> <p>- reconstruct image from 3 bad reads</p> <p>assumes that read errors don't occur in same place each time, which is true for some read errors (e.g. lpt timing problems), if there is a good reason why you can't read something then this may not be true this tool cannot recreate a nand out of nothing, if you give it 3 files full of zeros you'll get a recreated nand full of zeros, always look at a dump to make sure it looks correct (e.g. has a microsoft copyright at the top, once you've reconstructed a nand open it in 360 flash tool and make sure it reads ok there) the tool works by comparing blocks between the 3 files, any block found matching in 2 (or 3) of the files will be considered good, you will be warned if not all blocks can be recovered, in which case you'll need to get more reads or look for a good reason why your reads are so bad</p> <p>Official Site: http://www.xboxhacker.net/index.php?topic=13208.0</p> <p>Download: http://dwl.xbox-scene.com/xbox360pc/nandtools/NandCompare-v1.3.rar</p> <p>(images taken from http://www.infectus.biz/INFECTUS-BOOK/Tutorial_Eng/Xbox360/Timing_Attack_Infectus/pag3.htm)</p>"},{"location":"Hacks/Reset_Glitch_Hack/","title":"The Xbox 360 reset glitch hack","text":"<p>tmbinc said it himself, software based approaches of running unsigned code on the 360 mostly don't work, it was designed to be secure from a software point of view.</p> <p>The processor starts running code from ROM (1bl) , which then starts loading a RSA signed and RC4 crypted piece of code from NAND (CB).</p> <p>CB then initialises the processor security engine, its task will be to do real time encryption and hash check of physical DRAM memory. From what we found, it's using AES128 for crypto and strong (Toeplitz ?) hashing. The crypto is different each boot because it is seeded at least from:</p> <ul> <li>A hash of the entire fuseset.</li> <li>The timebase counter value.</li> <li>A truly random value that comes from the hardware random number     generator the processor embeds. on fats, that RNG could be     electronically deactivated, but there's a check for \"apparent     randomness\" (merely a count of 1 bits) in CB, it just waits for a     seemingly proper random number.</li> </ul> <p>CB can then run some kind of simple bytecode based software engine whose task will mainly be to initialise DRAM, CB can then load the next bootloader (CD) from NAND into it, and run it.</p> <p>Basically, CD will load a base kernel from NAND, patch it and run it.</p> <p>That kernel contains a small privileged piece of code (hypervisor), when the console runs, this is the only code that would have enough rights to run unsigned code. In kernel versions 4532/4548, a critical flaw in it appeared, and all known 360 hacks needed to run one of those kernels and exploit that flaw to run unsigned code. On current 360s, CD contains a hash of those 2 kernels and will stop the boot process if you try to load them. The hypervisor is a relatively small piece of code to check for flaws and apparently no newer ones has any flaws that could allow running unsigned code.</p> <p>On the other hand, tmbinc said the 360 wasn't designed to withstand certain hardware attacks such as the timing attack and \"glitching\".</p> <p>Glitching here is basically the process of triggering processor bugs by electronical means.</p> <p>This is the way we used to be able to run unsigned code.</p>"},{"location":"Hacks/Reset_Glitch_Hack/#the-reset-glitch-in-a-few-words","title":"The reset glitch in a few words","text":"<p>We found that by sending a tiny reset pulse to the processor while it is slowed down does not reset it but instead changes the way the code runs, it seems it's very efficient at making bootloaders memcmp functions always return \"no differences\". memcmp is often used to check the next bootloader SHA hash against a stored one, allowing it to run if they are the same. So we can put a bootloader that would fail hash check in NAND, glitch the previous one and that bootloader will run, allowing almost any code to run.</p>"},{"location":"Hacks/Reset_Glitch_Hack/#details-for-the-fat-hack","title":"Details for the fat hack","text":"<p>On fats, the bootloader we glitch is CB, so we can run the CD we want.</p> <p>cjak found that by asserting the CPU_PLL_BYPASS signal, the CPU clock is slowed down a lot, there's a test point on the motherboard that's a fraction of CPU speed, it's 200Mhz when the dash runs, 66.6Mhz when the console boots, and 520Khz when that signal is asserted.</p> <p>So it goes like that:</p> <ul> <li>We assert CPU_PLL_BYPASS around POST code 36 (hex).</li> <li>We wait for POST 39 start (POST 39 is the memcmp between stored hash     and image hash), and start a counter.</li> <li>When that counter has reached a precise value (it's often around 62%     of entire POST 39 length), we send a 100ns pulse on CPU_RESET.</li> <li>We wait some time and then we deassert CPU_PLL_BYPASS.</li> <li>The cpu speed goes back to normal, and with a bit of luck, instead     of getting POST error AD, the boot process continues and CB runs our     custom CD.</li> </ul> <p>The NAND contains a zero-paired CB, our payload in a custom CD, and a modified SMC image. A glitch being unreliable by nature, we use a modified SMC image that reboots infinitely (ie stock images reboot 5 times and then go RROD) until the console has booted properly. In most cases, the glitch succeeds in less than 30 seconds from power on that way.</p>"},{"location":"Hacks/Reset_Glitch_Hack/#details-for-the-slim-hack","title":"Details for the slim hack","text":"<p>The bootloader we glitch is CB_A, so we can run the CB_B we want.</p> <p>On slims, we weren't able to find a motherboard track for CPU_PLL_BYPASS. Our first idea was to remove the 27Mhz master 360 crystal and generate our own clock instead but it was a difficult modification and it didn't yield good results. We then looked for other ways to slow the CPU clock down and found that the HANA chip had configurable PLL registers for the 100Mhz clock that feeds CPU and GPU differential pairs. Apparently those registers are written by the SMC through an I2C bus. I2C bus can be freely accessed, it's even available on a header (J2C3). So the HANA chip will now become our weapon of choice to slow the CPU down (sorry tmbinc, you can't always be right, it isn't boring and it does sit on an interesting bus ;)</p> <p>So it goes like that:</p> <ul> <li>We send an i2c command to the HANA to slow down the CPU at POST code     D8 .</li> <li>We wait for POST DA start (POST DA is the memcmp between stored hash     and image hash), and start a counter.</li> <li>When that counter has reached a precise value, we send a 20ns pulse     on CPU_RESET.</li> <li>We wait some time and then we send an i2c command to the HANA to     restore regular CPU clock.</li> <li>The cpu speed goes back to normal, and with a bit of luck, instead     of getting POST error F2, the boot process continues and CB_A runs     our custom CB_B.</li> </ul> <p>When CB_B starts, DRAM isn't initialised so we chose to only apply a few patches to it so that it can run any CD, the patches are:</p> <ul> <li>Always activate zero-paired mode, so that we can use a modified SMC     image.</li> <li>Don't decrypt CD, instead expect a plaintext CD in NAND.</li> <li>Don't stop the boot process if CD hash isn't good.</li> </ul> <p>CB_B is RC4 crypted, the key comes from the CPU key, so how do we patch CB_B without knowing the CPU key? RC4 is basically:</p> <ul> <li>crypted = plaintext xor pseudo-random-keystream</li> </ul> <p>So if we know plaintext and crypted, we can get the keystream, and with the keystream, we can encrypt our own code. It goes like that:</p> <ul> <li>guessed-pseudo-random-keystream = crypted xor plaintext</li> <li>new-crypted = guessed-pseudo-random-keystream xor plaintext-patch</li> </ul> <p>You could think there's a chicken and egg problem, how did we get plaintext in the first place? Easy: we had plaintext CBs from fat consoles, and we thought the first few bytes of code would be the same as the new CB_B, so we could encrypt a tiny piece of code to dump the CPU key and decrypt CB_B!</p> <p>The NAND contains CB_A, a patched CB_B, our payload in a custom plaintext CD, and a modified SMC image. The SMC image is modified to have infinite reboot, and to prevent it from periodically sending I2C commands while we send ours.</p> <p>Now, maybe you haven't realised yet, but CB_A contains no checks on revocation fuses, so it's an unpatchable hack !</p>"},{"location":"Hacks/Reset_Glitch_Hack/#caveats","title":"Caveats","text":"<p>Nothing is ever perfect, so there are a few caveats to that hack:</p> <ul> <li>Even in the glitch we found is pretty reliable (25% success rate per     try on average), it can take up to a few minutes to boot to unsigned     code.</li> <li>That success rate seems to depend on something like the hash of the     modified bootloader we want to run (CD for fats and CB_B for     slims).</li> <li>It requires precise and fast hardware to be able to send the reset     pulse.</li> </ul>"},{"location":"Hacks/Reset_Glitch_Hack/#our-current-implementation","title":"Our current implementation","text":"<p>We used a Xilinx CoolRunner II CPLD (xc2c64a) board, because it's fast, precise, updatable, cheap and can work with 2 different voltage levels at the same time. We use the 48Mhz standby clock from the 360 for the glitch counter. For the slim hack, the counter even runs at 96Mhz (incremented on rising and falling edges of clock) The cpld code is written in VHDL. We need it to be aware of the current POST code, our first implementations used the whole 8 bits POST port for this, but we are now able to detect the changes of only 1 POST bit, making wiring easier.</p>"},{"location":"Hacks/Reset_Glitch_Hack/#finding-the-right-timing","title":"Finding the right timing","text":""},{"location":"Hacks/Reset_Glitch_Hack/#getting-memcmp-post-length-in-ticks","title":"Getting memcmp POST length in ticks","text":"<p>First step is to know how long the memcmp POST will last while slowed down. No reset pulse should be sent for this. Using hardware that can read the POST bus and measure time in a precise way, measure the time between memcmp POST start and 'hash compare failed' final POST (eg on fats, between POST 39 and POST AD) with the next bootloader failing hash check.</p> <p>An ARM7 based Olimex LPC-H2148 was used for this task.</p> <p>It could look like that:</p> <p><code>for(;;)</code> <code>{</code> <code>post\u00a0=\u00a0post_read();</code> <code>if\u00a0(post\u00a0==\u00a0prev_post)\u00a0then\u00a0continue;</code></p> <p><code>if(post\u00a0==\u00a0MEMCMP_POST)</code> <code>{</code> <code>t_start\u00a0=\u00a0get_tick();</code></p> <p><code>while(\u00a0post_read()\u00a0==\u00a0MEMCMP_POST\u00a0);</code> <code></code> <code>memcmp_post_length=get_tick()-t_start;</code></p> <p><code>print(memcmp_post_length);</code> <code>}</code></p> <p><code>prev_post=post;</code> <code>}</code></p> <p>Make sure you note memcmp post length ;)</p>"},{"location":"Hacks/Reset_Glitch_Hack/#using-random-timing-over-the-full-post-length","title":"Using random timing over the full POST length","text":"<p>Now you need the hardware to send a reset pulse after a random amount of time in memcmp POST, but no more than previously found memcmp POST length.</p> <p>It could look like that:</p> <p><code>for(;;)</code> <code>{</code> <code>post\u00a0=\u00a0read_post();</code> <code>if\u00a0(post\u00a0==\u00a0prev_post)\u00a0then\u00a0continue;</code></p> <p><code>if(post\u00a0==\u00a0MEMCMP_POST)</code> <code>{</code> <code>t_start\u00a0=\u00a0get_tick();</code> <code>t_rand\u00a0=\u00a0rand()\u00a0%\u00a0MEMCMP_POST_LENGTH;</code></p> <p><code>while(\u00a0get_tick()&lt;\u00a0t_start+t_rand\u00a0);</code></p> <p><code>ppc_send_reset_pulse();</code></p> <p><code>print(t_rand);</code> <code>}</code></p> <p><code>prev_post=post;</code> <code>}</code></p> <p>Using a hacked smc that reboots infinitely it will take a good amount of time, but it should end up glitching properly.</p> <p>Make sure you note the timing that glitched ;)</p>"},{"location":"Hacks/Reset_Glitch_Hack/#refining-the-timing-accounting-for-bell-like-curve","title":"Refining the timing, accounting for bell-like curve","text":"<p>So now we have one timing that glitches, but we don't know if it's really the 'sweet spot' or if we were just lucky. What needs to be done now is to get the timing of some more successes, I think it's safe to use a smaller random range around previously found glitch timing. my get_tick() function runs at 60Mhz, I found it was safe to make the range -+50 ticks around previously found glitch timing</p> <p>It could look like that:</p> <p><code>for(;;)</code> <code>{</code> <code>post\u00a0=\u00a0read_post();</code> <code>if\u00a0(post\u00a0==\u00a0prev_post)\u00a0then\u00a0continue;</code></p> <p><code>if(post\u00a0==\u00a0MEMCMP_POST)</code> <code>{</code> <code>t_start\u00a0=\u00a0get_tick();</code> <code>t_rand\u00a0=\u00a0PREV_GLITCH_TIMING\u00a0-\u00a050\u00a0+\u00a0(rand()\u00a0%\u00a0100);</code></p> <p><code>while(\u00a0get_tick()&lt;\u00a0t_start+t_rand\u00a0);</code></p> <p><code>ppc_send_reset_pulse();</code></p> <p><code>print(t_rand);</code> <code>}</code></p> <p><code>prev_post=post;</code> <code>}</code></p> <p>You'll need the timing of at least 20-30 successes. Averaging those timings should give you the sweet spot (aka final timing), because empirically we found that success rate vs timing is a bell-like curve.</p> <p>Make sure ... you got it ;)</p> <p>PS: Those pseudo-code examples don't show the slowdown code for the sake of clarity.</p>"},{"location":"Hacks/Reset_Glitch_Hack/#conclusion","title":"Conclusion","text":"<p>We tried not to include any MS copyrighted code in the released hack tools. The purpose of this hack is to run Xell and other free software, I (GliGli) did NOT do it to promote piracy or anything related, I just want to be able to do whatever I want with the hardware I bought, including running my own native code on it.</p>"},{"location":"Hacks/Reset_Glitch_Hack/#howto-for-slims","title":"HowTo (for slims)","text":""},{"location":"Hacks/Reset_Glitch_Hack/#required-software-and-hardware","title":"Required Software and Hardware","text":""},{"location":"Hacks/Reset_Glitch_Hack/#prerequisites","title":"Prerequisites","text":"<ul> <li>Installed Xilinx Lab Tools</li> </ul>"},{"location":"Hacks/Reset_Glitch_Hack/#software","title":"Software","text":"<ul> <li>Python and Pyton Crypto</li> <li>Impact (from Xilinx Lab Tools)</li> <li>NandPro (&gt;= v2.0e)</li> </ul>"},{"location":"Hacks/Reset_Glitch_Hack/#hardware","title":"Hardware","text":"<ul> <li>USB SPI Programmer to dump/flash the Xbox360's NAND</li> <li>XC2C64A CoolRunner-II CPLD (aka Digilent C-mod)</li> <li>Socket for the CPLD</li> <li>XilinX JTAG Programmer cable</li> <li>1x 220pF capacitor</li> <li>Soldering material</li> </ul>"},{"location":"Hacks/Reset_Glitch_Hack/#dumping-nand","title":"Dumping NAND","text":"<ul> <li>Use the following diagram to solder your USB SPI Programmer to     the Xbo360 motherboard.</li> </ul> <ul> <li>Open windows' command prompt and launch NandPro.</li> </ul> <ul> <li>Dump your nand twice by using the read command for 16MB NAND :</li> </ul> <p><code>nandpro\u00a0usb\u00a0:\u00a0-r16\u00a0nanddumpname.bin</code></p> <ul> <li>Compare the two dumps with the following command (you canuse MD5     Checksums too) :</li> </ul> <p><code>fc\u00a0/b\u00a0\u00a0nanddumpname.bin\u00a0nanddumpname2.bin</code></p> <p></p> <p>You should see something like FC : No difference found. If the two dumps don't match, do a new dump and check again.</p>"},{"location":"Hacks/Reset_Glitch_Hack/#installation-of-python-and-python-crypto","title":"Installation of Python and Python Crypto","text":"<ul> <li>Install Python 2.7 (32bit!) with the default settings :</li> </ul> <ul> <li>Install PyCrypto 2.3 with the default settings :</li> </ul> <p>To enable python in windows' command prompt, we will have to modify the environment variables .</p> <ul> <li>Go in Control Panel &gt; System &gt; Advanced system settings</li> </ul> <p></p> <ul> <li>Click on environnement variables</li> </ul> <p></p> <ul> <li>Click on new in system variable</li> </ul> <p></p> <ul> <li>Add this for the name and the value of the variable :</li> </ul> <p><code>PYTHONPATH</code> <code>%PYTHONPATH%;C:\\Python2.7\u00a0;</code></p> <p></p>"},{"location":"Hacks/Reset_Glitch_Hack/#creating-the-hackimage","title":"Creating the Hackimage","text":"<ul> <li>Download the gggggg-hack (Free60-Git Repository).</li> </ul> <ul> <li>Put your original NAND dump in the root of the gggggg-folder and     create an create a folder named \"ouput\" (in the root aswell).</li> </ul> <ul> <li>Open windows' command prompt again and navigate to the     gggggg-folder, then type this python command (don't forget to     modify it with your NAND dump name) :</li> </ul> <p><code>python\u00a0common\\imgbuild\\build.py\u00a0nanddumpname.bin\u00a0common\\cdxell\\CD\u00a0common\\xell\\xell-gggggg.bin</code></p> <p></p> <p>You should see the following</p> <p></p> <p>The file image_00000000.ecc is located in the output folder now.</p> <p></p> <ul> <li>Copy this file into your nandpro folder and navigate to the     folder via commandprompt again</li> </ul> <ul> <li>Use the following command to flash the image to your console's     NAND.</li> </ul> <p><code>nandpro\u00a0usb\u00a0:\u00a0+w16\u00a0image_00000000.ecc</code></p> <p>/!\\ Pay attention that you have to use the +w16 switch and not the -w16 one /!\\</p> <p></p> <p>The flashed file has a size of 50 blocks so you should see 004F when the flashing is done.</p>"},{"location":"Hacks/Reset_Glitch_Hack/#programming-the-cpld","title":"Programming the CPLD","text":"<p>Power your CPLD with 3.3V on pin 20 and GND on pin 21. There are many solution to do this ... here are some of them :</p> <ul> <li>Use an old DVD drive supply cable by cutting 5 and 6 cable (3.3V and     GND) and connect it to the a CK or the motherboard drive socket     OR Solder the pin 20 to the J2C1.8 point of the motherboard and     pin 21 (GND) to a point of the motherboard like the legs of the     various connector-metalcasing.</li> </ul> <p> </p> <ul> <li>Grab your LPT/USB XilinX JTAG programmer cable. Connect the cable     to the PC and the CPLD.</li> </ul> <p>(If you don't have one, you can use GliGli's schematic to build a LPT JTAG Programmer)</p> <p> </p> <ul> <li>Launch \"iMPACT\" (from XilinX Lab Tools) and let's start the     programming ... just follow the images.</li> </ul> <p>(You have to setup the compatibility mode only if your Programmer does not get detected right away)</p> <p> </p>"},{"location":"Hacks/Reset_Glitch_Hack/#wiring","title":"Wiring","text":"<ul> <li>On the CPLD, remove the Resistor R2 and connect R2's upper pad to     R1's lower pad.</li> </ul> <ul> <li>Place the CPLD on the motherboard like you see on the picture. We     recommend to use double coated tape + material to isolate the     CPLD.</li> </ul> <ul> <li>Use the following diagram to solder all needed connections. It's     recommended to use a socket!</li> </ul>"},{"location":"Hacks/Reset_Glitch_Hack/#enjoy","title":"ENJOY","text":"<ul> <li>You can now start your console normally and see XeLL boot within 2     minutes. You can now enjoy unsigned code on your slim.</li> </ul>"},{"location":"Hacks/Reset_Glitch_Hack/#credits-thanks","title":"CREDITS / THANKS","text":"<p>GliGli, Tiros: Reverse engineering and hack development. cOz: Reverse engineering, beta testing. Razkar, tuxuser, Ced2911: beta testing. cjak, Redline99, SeventhSon, tmbinc, anyone I forgot... : Prior reverse engineering and/or hacking work on the 360.</p> <p>Category: System Software Category: Hardware</p>"},{"location":"Hacks/SMC_Hack/","title":"The JTAG / SMC Hack","text":"<p>There is a new hack which can boot homebrew code in less than 5 seconds. See at the end of this document for a description how the hack works. For now, all we need to know is that this is a new way to exploit the well-known 4532 kernel, in a way which also works on updated machines, unless they have been updated by the summer '09 update. It also works on all hardware types.</p> <p>This document is a technical description meant for people who want to undestand the hack. If you don't understand a word, calm down - there probably will be future releaes, howtos etc.</p> <p>Please also notice that from a functional side, the result will be the same as the KK-hack; it's just much faster, works on more hardware and is more reliable. So it replaces the KK-hack, not less and not more.</p> <p>Technical details are available here.</p>"},{"location":"Hacks/SMC_Hack/#required-soldering","title":"Required Soldering","text":"<p>The SMC Hack requires bridging 3 points on the motherboard (for trigger the exploit by JTAG), as well as having a way to read and write with your Nand Flash</p> <p>The JTAG points are available for a number of consoles</p>"},{"location":"Hacks/SMC_Hack/#xenon","title":"Xenon","text":""},{"location":"Hacks/SMC_Hack/#falcon-zephyr-opus-jasper","title":"Falcon, Zephyr, Opus, Jasper","text":""},{"location":"Hacks/SMC_Hack/#reverse-jtag","title":"Reverse Jtag","text":"<ul> <li> <p>To read and write the Nand Flash (using SPI protocol by LPT and a printer cable), there is a friendly tutorial at NAND Reading</p> <p>There are other ways to read and write the Nand Flash that are valid (such as infectus modchip)</p> <ul> <li>All the diodes used in SPI and JTAG are \"switching diodes\" proposed     are: BAT41, 1N4148, or 1N4153</li> </ul> </li> </ul>"},{"location":"Hacks/SMC_Hack/#building-a-homebrew-kernel","title":"Building a Homebrew-Kernel","text":""},{"location":"Hacks/SMC_Hack/#from-scratch","title":"From scratch","text":""},{"location":"Hacks/SMC_Hack/#what-you-need","title":"What you need","text":"<ul> <li>Latest build.py Script from GIT</li> <li> <p>CB/CD-files matching for your Xbox Revision (called <code>CB.xxxx/CD.xxxx</code> here, where <code>xxxx</code> is the version)</p> <ul> <li>Xenon: 1921</li> <li>Zephyr: 4558</li> <li>Falcon: 5770</li> <li>Jasper: 6712, 6723</li> </ul> </li> <li> <p>Hacked SMC Code matching your Xbox Revision (called smc_hacked.bin here)     ATM only available for XENON / falcon / zephyr / opus(as of recently)</p> </li> <li>The 1888 Basekernel (called 1888image.bin here)</li> <li>Xbox 360 Dashboard Update Version 4532 (HD_DVD_10-2006.zip)</li> <li>wxPirs to extract xboxupd.bin from 4532-Update</li> <li>Compiled XELL (xell-1f.bin, also the same file named xell-backup.bin)</li> </ul>"},{"location":"Hacks/SMC_Hack/#how-to","title":"How-to","text":"<ol> <li> <p>Check out the latest free60-tools with GIT    <pre><code>git\u00a0clone\u00a0https://github.com/Free60Project/tools.git\n</code></pre></p> </li> <li> <p>Extract xboxupd.bin with WxPirs from the unzipped 4532-Dashboard-Update</p> </li> <li> <p>Copy the files xboxupd.bin, 1888image.bin, CB.xxxx/CB.xxxx, smc.hacked and the two XeLL files xell-1f.bin and xell-backup.bin to /tools/imgbuild/input (you need to create the folder first). Also create a folder \"output\" in /tools/imgbuild/</p> </li> <li> <p>Edit build.py to contain the Secret 1BL Key in this format   (Example-Key: 010F0E0C0ED669E7B56794FB68563EFA)     <pre><code>secret_1BL\u00a0=\u00a0\"\\x01\\x0F\\x0E\\x0C\\x0E\\xD6\\x69\\xE7\\xB5\\x67\\x94\\xFB\\x68\\x56\\x3E\\xFA\"\n</code></pre></p> </li> <li> <p>Start build.py with the following command     <pre><code>python\u00a0build.py\u00a0input/1888image.bin\u00a0input/CB.xxxx\u00a0input/CD.xxxx\u00a0input/xboxupd.bin\u00a0input/xell-backup.bin\u00a0input/xell-1f.bin\u00a0input/smc_hacked.bin\n</code></pre></p> <p>If everything works out the Script should output something similar to this</p> <pre><code>*\u00a0found\u00a0flash\u00a0image,\u00a0unpacking\u00a0and\u00a0decrypting...\n\u00a0ECC'ed\u00a0-\u00a0will\u00a0unecc.\n\u00a0Found\u00a02BL\u00a0(build\u00a01888)\u00a0at\u00a000008000\n\u00a0Found\u00a04BL\u00a0(build\u00a01888)\u00a0at\u00a00000e1e0\n\u00a0Found\u00a05BL\u00a0(build\u00a01888)\u00a0at\u00a0000138d0\n\u00a0*\u00a0found\u00a0(hopefully)\u00a0decrypted\u00a0CB\n\u00a0*\u00a0found\u00a0(hopefully)\u00a0raw\u00a0CD\n\u00a0*\u00a0found\u00a0update\n\u00a0Found\u00a06BL\u00a0(build\u00a04532)\u00a0at\u00a000000000\n\u00a0Found\u00a07BL\u00a0(build\u00a04532)\u00a0at\u00a0000044c0\n\u00a0*\u00a0found\u00a0XeLL\u00a0binary,\u00a0must\u00a0be\u00a0linked\u00a0to\u00a01c000000\n\u00a0*\u00a0found\u00a0XeLL\u00a0binary,\u00a0must\u00a0be\u00a0linked\u00a0to\u00a01c000000\n\u00a0*\u00a0found\u00a0decrypted\u00a0SMC\n\u00a0*\u00a0we\u00a0found\u00a0the\u00a0following\u00a0parts:\n\u00a0CB:\u00a01921\n\u00a0CD:\u00a01921\n\u00a0CE:\u00a01888\n\u00a0CF:\u00a04532\n\u00a0CG:\u00a04532\n\u00a0*\u00a0checking\u00a0if\u00a0all\u00a0files\u00a0decrypted\u00a0properly...\u00a0ok\n\u00a0*\u00a0checking\u00a0required\u00a0versions...\u00a0ok\n\u00a0*\u00a0Fixing\u00a0up\u00a0the\u00a0hacked\u00a0SMC\u00a0code\u00a0with\u00a0the\u00a0target\u00a0address\n\u00a0*\u00a0this\u00a0image\u00a0will\u00a0be\u00a0valid\u00a0*only*\u00a0for:\u00a0xenon\n\u00a0*\u00a0zero-pairing...\n\u00a0*\u00a0constructing\u00a0new\u00a0image...\n\u00a0*\u00a0base\u00a0size:\u00a070000\n\u00a0*\u00a0compiling\u00a0payload\u00a0stub\n\u00a0*\u00a0Flash\u00a0Layout:\n\u00a00x00000000..0x000001ff\u00a0(0x00000200\u00a0bytes)\u00a0Header\n\u00a00x00000200..0x000003ff\u00a0(0x00000200\u00a0bytes)\u00a0Exploit\n\u00a00x00000400..0x00000fff\u00a0(0x00000c00\u00a0bytes)\u00a0Padding\n\u00a00x00001000..0x00003fff\u00a0(0x00003000\u00a0bytes)\u00a0SMC\n\u00a00x00004000..0x00007fff\u00a0(0x00004000\u00a0bytes)\u00a0Keyvault\n\u00a00x00008000..0x000117ff\u00a0(0x00009800\u00a0bytes)\u00a0CB\u00a01921\n\u00a00x00011800..0x00016ebf\u00a0(0x000056c0\u00a0bytes)\u00a0CD\u00a01921\n\u00a00x00016ec0..0x0006cf2f\u00a0(0x00056070\u00a0bytes)\u00a0CE\u00a01888\n\u00a00x0006cf30..0x0006ffff\u00a0(0x000030d0\u00a0bytes)\u00a0Padding\n\u00a00x00070000..0x000744bf\u00a0(0x000044c0\u00a0bytes)\u00a0CF\u00a04532\n\u00a00x000744c0..0x000a33ff\u00a0(0x0002ef40\u00a0bytes)\u00a0CG\u00a04532\n\u00a00x000a3400..0x000bffff\u00a0(0x0001cc00\u00a0bytes)\u00a0Padding\n\u00a00x000c0000..0x000fffff\u00a0(0x00040000\u00a0bytes)\u00a0Xell\u00a0(backup)\n\u00a00x00100000..0x0013ffff\u00a0(0x00040000\u00a0bytes)\u00a0Xell\u00a0(main)\n\u00a0*\u00a0Encoding\u00a0ECC...\n\u00a0Written\u00a0into\u00a0output/image_00000000.ecc\n\u00a0!\u00a0please\u00a0flash\u00a0output/image_*.ecc,\u00a0and\u00a0setup\u00a0your\u00a0JTAG\u00a0device\u00a0to\u00a0do\u00a0the\u00a0DMA\u00a0read\u00a0from\u00a000000200\n</code></pre> </li> <li> <p>Finished! Your ready-to-be-flashed Image is located in the output-folder, called image_00000000.ecc</p> </li> </ol>"},{"location":"Hacks/SMC_Hack/#updating-a-hacked-image","title":"Updating a hacked image","text":""},{"location":"Hacks/SMC_Hack/#what-you-need_1","title":"What you need","text":"<ul> <li>Latest build.py Script from GIT</li> <li>Hacked Kernel-Image (hacked-image.bin)</li> <li>Xbox 360 Dashboard Update Version 4532 (HD_DVD_10-2006.zip)</li> <li>wxPirs to extract xboxupd.bin from 4532-Update</li> <li>Compiled XELL (xell-1f.bin)</li> </ul>"},{"location":"Hacks/SMC_Hack/#how-to_1","title":"How-to","text":"<ol> <li> <p>Checkout free60-tools, extract xboxupd.bin as described above.</p> </li> <li> <p>Copy files hacked-image.bin, xboxupd.bin and xell-1f.bin to /tools/imgbuild/ and create a folder \"output\" there.</p> </li> <li> <p>Start build.py with following command:   <pre><code>python\u00a0build.py\u00a0hacked-image.bin\u00a0xboxupd.bin\u00a0xell-1f.bin\n</code></pre></p> </li> <li> <p>Finished! Your updated hacked-image was written into the output directory and is ready to be flashed.</p> </li> </ol>"},{"location":"Hacks/SMC_Hack/#alternative","title":"Alternative","text":"<p>If you are using XeLL-compile after 31. August 09 you could use the USB-Update feauture.</p>"},{"location":"Hacks/SMC_Hack/#how-to_2","title":"How-to","text":"<ol> <li> <p>Format a compatible USB Drive to FAT16/32.</p> </li> <li> <p>Put 'xell-1f.bin' renamed to 'updxell.bin' into the Root of the USB Drive.</p> </li> <li> <p>Turn on XeLL-Xbox 360 with attached USB Drive.</p> </li> <li> <p>XeLL should recognize USB Drive and tell you '* found XeLL update. press power NOW if you don't want to update.'</p> </li> <li> <p>Wait for XeLL to tell you '*update done' and unplug the USB Drive so it won't upgrade on the next startup.</p> </li> <li> <p>Reboot Xbox 360 and enjoy a fresh XeLL.</p> </li> </ol>"},{"location":"Hacks/SMC_Hack/#extracting-smccbcd-from-a-hacked-image","title":"Extracting SMC/CB/CD from a hacked image","text":""},{"location":"Hacks/SMC_Hack/#what-you-need_2","title":"What you need","text":"<ul> <li>Latest build.py Script from GIT</li> <li>Hacked Kernel-Image (hacked-image.bin)</li> <li>Xbox 360 Dashboard Update Version 4532 (HD_DVD_10-2006.zip)</li> <li>wxPirs to extract xboxupd.bin from 4532 Update</li> </ul>"},{"location":"Hacks/SMC_Hack/#how-to_3","title":"How-to","text":"<ol> <li> <p>Checkout free60-tools, extract xboxupd.bin as described above</p> </li> <li> <p>Copy files hacked-image.bin and xboxupd.bin to /tools/imgbuild/ and create a folder \"output\" there</p> </li> <li> <p>Start build.py with following command</p> </li> </ol> <pre><code>python\u00a0build.py\u00a0hacked-image.bin\u00a0xboxupd.bin\n</code></pre> <ol> <li>Finished! Decrypted SMC, CB and CD data was written into the output directory</li> </ol>"},{"location":"Hacks/SMC_Hack/#build-a-full-16mb-image-out-of-the-small-one-created-by-build-script","title":"Build a full 16MB Image out of the small one created by build-script","text":"<p>Just use this simple command (input/backup.ecc is your nand backup, and output/full.ecc is a 16MB image you can flash)</p> <pre><code>cp\u00a0input/backup.ecc\u00a0output/full.ecc;\u00a0dd\u00a0if=output/image_00000000.ecc\u00a0of=output/full.ecc\u00a0conv=notrunc\n</code></pre>"},{"location":"Hacks/SMC_Hack/#using-the-1920to1921-script","title":"Using the 1920to1921 script","text":""},{"location":"Hacks/SMC_Hack/#what-you-need_3","title":"What you need","text":"<ul> <li>Latest 1920to1921.py Script from GIT</li> <li>decrypted 1921 CB (2BL)</li> <li>decrypted 1920 CD (4BL)</li> </ul>"},{"location":"Hacks/SMC_Hack/#how-to_4","title":"How-to","text":"<ol> <li> <p>Rename 1921 CB file to CB.1921 (no file extension) and 1920 CD to CD.1920</p> </li> <li> <p>Move both files to /tools/imgbuild/input/</p> </li> <li> <p>Start 1920to1921.py with following command:</p> </li> </ol> <pre><code>python\u00a01920to1921.py\u00a0xxxx\u00a0(where\u00a0xxxx\u00a0is\u00a0the\u00a0CD\u00a0Version\u00a0you\u00a0want\u00a0to\u00a0create,\u00a0i.e\u00a01921,\u00a04558,\u00a05770)\n</code></pre> <ol> <li>Finished! Script should tell you \"great, hash matches!\" and write the appropriative CD to the input folder.</li> </ol>"},{"location":"Hacks/SMC_Hack/#technical-details","title":"Technical details","text":"<p>To understand this new hack, let's first look at what made the KK exploit possible: A fatal bug in the Hypervisor's Syscall Handler, introduced in the 4532 kernel update. For more details, take a look at http://www.securityfocus.com/archive/1/461489/30/0/threaded which explains the problem in great detail.</p> <p>The KK exploit exploited the kernel bug by modifying an unsigned shader to do a series of so-called memory exports, an operation where the GPU can write the results of a pixel or vertex shader into physical memory. The shader was written to overwrite the Idle-thread context to make the kernel jump at a certain position in memory, with some registers nder our control. In order to control all registers, a second step was necessary, this time by jumping into the interrupt restore handler. This finally allows all CPU general purpose registers to be filled with etermined values. The program counter could be restored to a syscall instruction in the kernel, with register values prefilled so that they would trigger the exploit.</p> <p>The exploit basically allows jumping into any 32-bit address in hypervisor space. To jump into an arbitrary location, we just used a \"mtctr, bctr\"-register pair in hypervisor, which would redirect execution low into any 64-bit address. This is important, since we need to clear the upper 32bit (i.e.,set the MSB to disable the HRMO), since the code we want to jump to is in unencrypted memory.</p> <p>This code would usually load a second-stage loader, for example XeLL, into memory, and start it. XeLL would then attempt to catch all cpu threads (because just the primary thread is affected by our exploit), and load the user code, for example from DVD.</p> <p>So, the following memory areas are involved:</p> <ul> <li>Idle Thread context, at 00130360 in physical memory</li> </ul> <p>This stores the stack pointer (and some other stuff) when the idle thread was suspended. By changing the stack pointer, and then waiting for the kernel to switch to the idle thread, the stack pointer can be brought into our control. Part of the context switch is also a context restore, based on the new stack pointer.</p> <ul> <li>Context restore, part 1, arbitrary location, KK expl. uses 80130AF0</li> </ul> <p>The thread-context restore doesn't restore all registers, but let's us control the NIP (the \"next instruction\" pointer). We setup NIP to point to the interrupt context restore, which does a SP-relative load of most registers.</p> <ul> <li>Context restore, part 2, same base location as part 1</li> </ul> <p>We just re-use the same stack pointer, because the areas where the first context restore and the interrupt context restore load from do not overlap. The second context restore allows us to pre-set all registers with arbitrary 64 bit values.</p> <ul> <li>The HV offset, at 00002080 for syscall 0x46 on 4532</li> </ul> <p>Because of the HV bug, we can write this offset into unencrypted memory, giving us the possibility to jump into any location in the hypervisor space (i.e. with a certain \"encryption prefix\"). We usually write 00000350 here, which points to a \"mtctr %r4; bctr\" instruction pair in hypervisor, which lets us jump to %r4.</p> <ul> <li>Our loader code, at an arbitrary location</li> </ul> <p>This code will be executed from hypervisor. It's the first of our code which will be executed. %r4 on the syscall entry has to point to this code.</p> <p>Only the idle thread context and the HV offset have fixed addresses. It's easily possible to merge this so that only two distinct blocks needs to be written into memory, but it's not possible to merge this into a single block.</p> <p>Fortunately, the NAND controller allows doing DMA reads where the payload data is split from the \"ECC\"-data. Each page has 512 bytes of payload, and 16 bytes of ECC data. Thus, a single DMA read can be used to load all required memory addresses. We chose the Payload to read the Idle Thread Context, the Context Restores and the loader code. The ECC data will carry the HV offset.</p> <p>To do a DMA read, the following NAND registers need to be written:</p> <p>ea00c01c Address for Payload ea00c020 Adresss for ECC ea00c00c address inside NAND ea00c008 command: read DMA (07)</p> <p>The System Management Controller (SMC) is a 8051 core inside the Southbridge. It manages the power sequencing, and is always active when the Xbox 360 has (standby or full) power applied. It controls the frontpanel buttons, has a Realtime clock, decodes IR, controls temperatures and fans and the DVDROM tray. It talks with the frontpanel board to set the LEDs. When the system is running, the kernel can communicate with the SMC, for example to query the realtime clock, open the dvd-tray etc. This happens over a bidirectional FIFO (at ea001080 / ea001090). See the XeLL SMC code for details.</p> <p>The SMC can read the NAND, because it requires access to a special NAND page which contains a SMC config block. This block contains calibration information for the thermal diodes, and the thermal targets etc. The 8051 core has access to NAND registers, which are mapped into the 8051 SFRs. It uses the same protocol as the kernel uses, so it writes an address, does a \"READ\" command, and then reads the data out of the \"DATA\" registers.</p> <p>It could also do a \"READ (DMA)\"-command. So by hacking the SMC, we could make the box do the exploit, without any shader - the SMC can access the NAND controller all the time, even when the kernel is running (though it will likely interfere with the kernel). So, we just trigger the DMA read when the kernel has been loaded, and everything is fine.</p> <p>Right?</p> <p>Well, that would be too easy. While most NAND registers are mapped, the DMA address registers (1c, 20) are not. We can DMA, but only to the default address of zero (or wherever the kernel last DMAed into). Fail.</p> <p>The GPU, the (H)ANA (the \"scaler\" - which in fact doesn't scale at all, it's \"just\" a set of DACs, and, since Zephyr, a DVI/HDMI encoder), the Southbridge and the CPU have their JTAG ports exposed on the board. They are unpopulated headers, but the signals are there. CPU JTAG is a different (complex) story, and SB JTAG doesn't offset much funcationality. ANA JTAG is boring since the ANA doesn't sit on any interesting bus. That leaves GPU JTAG.</p> <p>GPU JTAG was reverse-engineered until a point where arbitrary PCI writes are possible, up to a certain point. So that makes it possible to talk to each PCI device in the system, including the NAND controller. So we can simply use THAT instead of the SMC to start the DMA?</p> <p>Right?</p> <p>Well, not quite. The problem is that the \"VM code\", the code which does a lot of system initialization, like the memory (that code is also responsible for generating the 01xx \"RROD\"-Errors), sets a certain bit in some GPU register, which disables the JTAG interface. The VM code is executed way before the kernel is active. So this is fail, too.</p> <p>But the combination works - by programming the DMA target address via JTAG, and launching the attack via SMC. The attack can be launched as soon as the kernel is running, and quite early, it does query the SMC for the RTC. We abuse this call to start the attack instead, which is a perfect point for us.</p> <p>But how do we run an exploitable kernel at all? Most machines are updated already. Let me refresh your knowledge about the boot process again:</p>"},{"location":"Hacks/SMC_Hack/#1bl-bootrom","title":"1BL (Bootrom)","text":"<p>Buried deep inside the CPU die, this ~32kb of ROM code is responsible for reading the 2BL from NAND-flash and decrypts it into the embedded SRAM in the CPU. It verifies the hash of the decrypted image with a signed block at the beginning of the 2BL, and will stop execution if this hash mismatches. This code also contains a number of test functions, which can be activated by pulling the 5 \"POST IN\"-pins, which are available on the backside of the PCB. None of these tests looks particulary interesting (from an exploitation perspective) - they mostly seem to be related to the FSB (the bus between CPU and GPU). This code is fixed, and all systems use identical code here.</p>"},{"location":"Hacks/SMC_Hack/#2bl-cb","title":"2BL (\"CB\")","text":"<p>This code is usually located at 0x8000 in NAND flash. It's decrypted by 1BL, and runs from internal SRAM.</p> <p>It does a basic hardware initialization, and contains the \"fuse check code\", which verifies the \"2BL version\". The fuses store the expected version. The 2BL stores a \"Version\" and a \"AllowedMask\" (=bitfield), and this is usually stored at address 0x3B1 / 0x3B2..0x3B3.</p> Xenon Zephyr Falcon Jasper 2 0003 1888, 1901, 1902 4 1920 \"new zeropair code\" 5 0010 1921 4558 5760,5761,5770 6712 TA-fixed <p>It then verifies the pairing information stored in the 2BL header. Part of this verification is a checksum check of the NAND area which was used to load the SMC code from.</p> <p>It also contains a virtual machine and some code to run on this machine. The virtual machine code, which is pretty complicated, does the following things:</p> <ul> <li>Initialisation of the PCI-Bridge</li> <li>Disable the GPU PCIE JTAG test port</li> <li>initialize the serial port</li> <li>talk to the SMC to clear the \"handshake\"-bit</li> <li>initialize memory</li> <li>hopefully not: generate RROD if memory init fails</li> </ul> <p>After that, the external (512MB) memory will be initialized and usable. 2BL then decrypts the 4BL into this memory. Memory encryption will already be enabled - no executable code is *ever* written unencrypted.</p>"},{"location":"Hacks/SMC_Hack/#4bl-cd","title":"4BL (\"CD\")","text":"<p>This code is responsible for checking and unpacking 5BL, as well as applying update patches. First, the fuses are read to determine the console \"Update Sequence\", a number which basically counts the number of updates installed. Since updates are, in the same way as 2BL, paired to a console, this allows to configure the console in a way that no old update will be used. So each update slot stores the maximum value of burned fuses (well, essentially the exact value). The base kernel also has an associated value, usually zero, but this can be changed in the 2BL pairing data block. This is what the timing-attack increments, in order to revert to the 1888 kernel.</p>"},{"location":"Hacks/SMC_Hack/#5bl-hvkernel","title":"5BL (\"HV/Kernel\")","text":"<p>The HV and kernel are merged into a single image, which is compressed with a proprietary algorithm (LDIC).</p>"},{"location":"Hacks/SMC_Hack/#6bl-cf-7bl-cg","title":"6BL (\"CF\"), 7BL (\"CG\")","text":"<p>This is part of a system upgrade. Each console has a so-called \"Base Kernel\", which is the 1888 kernel which was available on launch back in 2005. Then there are two \"update slots\" - areas of 64k each (128k on Jasper), which contain a 6BL and 7BL. 6BL is code which applies the update, using a clever delta-compression. 7BL is the actual delta-compressed update, essentially a binary diff.</p> <p>Oh, updates are &gt;64k. So only the first 64k are actually stored in the update slots, the rest is stored in the filesystem as a special file. Since 6BL doesn't contain a filesystem parser, a blockmap is added in 6BL which points to the sectors which contain the rest of the update.</p>"},{"location":"Hacks/SMC_Hack/#zero-pairing","title":"Zero-Pairing","text":"<p>Now there is a special situation: If the 2BL pairing block is all-zero, the pairing block will not be checked. However, a bit is set so that the kernel doesn't boot the dashboard binary, but a special binary called \"MfgBootLauncher\", where \"Mfg\" probably stands for \"Manufacturing\". So this is a leftover of the production process, where the flash image is used on all hardware, probably also before any CPU-key has been programmed.</p> <p>By abusing this feature, this allows us easily to produce a flash image which runs on all hardware. However, 4BL won't look at update slots when it detects this mode, so we end up in the 1888 base kernel. And we can't run the dashboard, so it's impossible to escape this mode.</p> <p>Previously, this has been deemed very uninteresting, because first the 1888 isn't exploitable by the KK exploit, and second because it's impossible to run the KK game anyway.</p> <p>However, starting with 2BL version 1920, an interesting thing happened: The encryption key for 4BL is generated with the help of the CPU-key now. That means that without the CPU-key, it's not possible to decrypt the 4BL anymore. Note that each 2BL has exactly a single valid 4BL binary - 2BL contains a hardcoded hash for the 4BL, and doesn't use RSA.</p> <p>However, zero'ed pairing data is detected, the CPU-key is NOT used in this process, like it was previously. That also means that you cannot just zero-out the pairing data anymore - the 4BL would be decrypted with the wrong key then. Instead you need to decrypt the 4BL (which requires knowing the CPU key), and re-encrypt it with the old algorithm.</p> <p>However, 1920 was suspectible to the timing attack - so a CPU-key recovery was possible on one console, which allowed us to decrypt the 1920 4BL. That 4BL shows a very intersting change: Whenever zero-pairing is detected, the update slots are not ignored anymore. Instead, if the update-slots are zero-paired as well, they are applied.</p> <p>This change allows us to boot any kernel, provided we have a (1920 and up) 2BL/4BL set which runs on that machine. This is very important, because we can build up an image now which runs into the 4532 kernel, regardless on how many update fuses are set. However, the 2BL revocation process must be passed, so we are not completely independent of the fuses, still. But since we use zero-pairing, the SMC hash doesn't matter anymore (there are other ways to work around the SMC hash problem, like the TA, but we get this for free). Still, we boot into the MfgBootLauncher (into the 4532 version now, which does a red/green blinking thingie - you'll notice once you see it, it's very unique and doesn't look like any RROD or so). But thanks to the SMC/JTAG hack described above, this allows us to launch our attack from this state.</p> <p>Newer consoles (which have the TA fix) don't run 1920 anymore. They run, for example, 1921. The problem is that we cannot run HV code on these machines, so we don't know the CPU key. However, when comparing the 1921 and 1920 2BL (which we can still decrypt), the only change is the addition of the timing attack fix (i.e. replacing two memcmp instances with a memdiff function). Also, we know the expected hash value of the decrypted 4BL. Based on a 1920 4BL, and the guess what has changed functionally, and the new size of the 4BL, we were able to guess the modifications, which yields an image which passes the 2BL hash check. Note that this is not a hash collision - we did merely derive the exact image by applying the changes between 1920 2BL and 1921 2BL into 1920 4BL, yielding the 1921 4BL.</p> <p>The 1921 2BL theoretically runs on all machines so far, even TA-proof ones. But it crashes on Zephyr, Falcon and Jasper. The reason is the VM code, which doesn't cover the different GPUs (Xenon has 90nm GPU, Zephyr and Falcon have 80nm, Jasper has 60nm, so there are 3 GPU revisions in total).</p> <p>But the step from 1921 to, say, 4558, is even smaller. It's just the different version number, plus a slight difference in the memcpy code, which again can be ported over from 2BL.</p> <p>Jasper's 67xx is a different thing, since this code adds support for the largeblock flash used in \"Arcade\"-Jasper units. We have used some magic to retrieve this code.</p> <p>So we now have ALL 4BL versions. Isn't that great? It means that ALL machines can run the 4532 kernel. The good news is also that the 4532 kernel supports falcon consoles, and runs long enough to also work on jasper consoles (because we exploit way before the different GPU is touched at all).</p>"},{"location":"Hacks/SMC_Hack/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Hacks/SMC_Hack/#q-the-power-supply-goes-red-when-plugging-in-power","title":"Q: \"The power supply goes red when plugging in power!\"","text":"<p>A: You shorted a power pin, probably V33_SB, the one attached to the NAND flash. Carefully look for solder residues. Use a lot of flux and a properly-heated soldering iron.</p>"},{"location":"Hacks/SMC_Hack/#q-the-power-supply-stays-yellow-when-i-press-the-power-button-and-nothing-else-happens","title":"Q: \"The power supply stays yellow when I press the power button, and nothing else happens.\"","text":"<p>A: The SMC code is invalid. This can be a misconnected flashrom, an illegal image, a bad flash or simply a bad SMC code. Verify:</p> <ul> <li>Electrical connections first.</li> <li>Did you flash with the proper ECC settings? The flash images we are     working with usually contain raw ECC information, i.e. 512+16 bytes     per sector. Make sure your flash programmer is not modifying these     16 bytes, but writing those as they are.</li> <li>Have you used the right SMC image?</li> </ul>"},{"location":"Hacks/SMC_Hack/#q-the-fans-run-at-full-speed-immediately","title":"Q: \"The fans run at full speed immediately.\"","text":"<p>A: This is very likely a bad SMC config sector. Did you flash all the parts generated by the image creation tool at the proper position? Note that offsets are given as payload offsets, not counting ECC bytes. Usually this matches what your average NAND programmer tells you, but in case you re-assembled these into a single image, take care to properly convert the offsets.</p>"},{"location":"Hacks/SMC_Hack/#q-i-get-e79","title":"Q: \"I get E79\"","text":"<p>A: This means that, congratulations, your console is still booting into a kernel, and just cannot go further (which was to be exepcted, given that there is no filesystem anymore). You're almost there, but for some reasons, the DMA attack didn't run. This can be either that you didn't used a patched SMC, or that the target address wasn't inserted properly.</p>"},{"location":"Hacks/SMC_Hack/#q-console-powers-on-but-i-get-a-black-screen","title":"Q: \"Console powers on, but I get a black screen.\"","text":"<p>A: Well, there are many reasons here again. First, wait some time (~1 minute), and see if you get a RROD. If you do, the VM code failed to handshake with the SMC (error code XXXX), which usually means that it crashed, and the SMC watchdog triggered until it retried too often. Did you use the proper 2BL/4BL image for your machine type? Did you use a recent enough SMC version? Since the VM code took more and more time (from roughly a half second in 1888 to several seconds in 1920), the SMC code was modified to time out later. Be sure to use a known-good SMC version, if possible, based on the version which was installed before. If you don't get a RROD, please try checking your POST code. You can do this via CPU jtag, or by measuring the 8 POST pins.</p> <p>Post code 6C:</p> <ul> <li>The exploit failed, somehow.</li> </ul> <p>Post code 10:</p> <ul> <li>Our code is running! That's great, but it failed copying the     XeLL-payload from flash. Try booting into the alternate loader (see     below in the \"exploit loader\" section), or reflash.</li> </ul> <p>Post code 11:</p> <ul> <li>Exploit code ran, and jumped into XeLL. XeLL crashed. Try alternate     loader, or do serial upload for recovery, if you really screwed up     both the primary and secondary loader. (You failed, in that case.)</li> </ul> <p>Post codes &gt;= 0x80:</p> <ul> <li>Those are errors from the bootloader. Please check the disassembly     of those loaders to see what's wrong exactly. It shouldn't happen     unless you have a bad flash.</li> </ul> <p>Post code 0xA0:</p> <ul> <li>Your 2BL didn't want to run on your hardware due to the 2BL     revocation fuses. Use a more recent 2BL/4BL set for your hardware.     If you're already running {1921, 4558, 5770, 6712} then you're out     of luck. Your box was already updated to a newer 2BL, which likely     fixed what we used to exploit. Restore R6T3, restore the flash     image, and use this console for playing games. Get another console,     and try again.</li> </ul> <p>Please note that some hardware elements are not properly initialized at the early time of the exploit. This affects:</p> <p>CPU:</p> <ul> <li>The CPU is initialized in low-power mode, where it runs at     quarter-speed.</li> </ul> <p>Setting the CPU power mode is possible, of course, but needs to be reverse-engineered from the corresponding hypervisor syscall.</p> <p>GPU:</p> <ul> <li>A full screen setup is required, including the programming of the     ANA-chip. Code is available for setting up a 640x480 VGA mode,     support for other resolutions needs to be added.</li> <li>EDRAM must be \"trained\". This is what fails when the E-74 error is     displayed. The code is rather complex, and has been     reverse-enginnered, but doesn't run properly yet. However, it has     been shown to work a bit, and can likely be tweaked to work     properly.</li> </ul> <p>SATA:</p> <ul> <li>SATA likely needs some reset sequence. Linux kernel does this fine,     but XeLL doesn't work.</li> </ul> <p>All of these issues are expected to be fixed.</p> <p>This hack can also be used to reboot into a Microsoft kernel, in order to keep the possibility of playing games locally. This is not within the scope of this document, and is actually not related to this hack at all. This hack allows you the execution of software - and YOU decide what software that should be. It could be linux, your favourite emulator, or a rebooter.</p> <p>Note that we do not support patching the Microsoft kernel for piracy under any circumstances. Also, playing on LIVE with a modified console won't be possible without getting banned, ever. There are already challenges in place which detect any unauthorized modification. We urge you to not abuse this hack for piracy.</p>"},{"location":"Hacks/SMC_Hack/#exploit-loader","title":"EXPLOIT LOADER","text":"<p>The first own code which is executed is a small loader, which operates in the following way:</p> <ul> <li>If a character is present on the serial port, it will be read.<ul> <li>if that character is '@', we will enter serial upload mode.</li> <li>if that character is ' ', we will use the backup bootloader</li> </ul> </li> <li>if not serial upload mode:<ul> <li>POST 0x10</li> <li>read bootloader from flash (either backup or normal)</li> <li>POST 0x11</li> <li>run</li> </ul> </li> <li>serial upload mode:<ul> <li>output '&gt;'</li> <li>receive characters</li> <li>after 10 consecutive 'x', stop upload</li> <li>output '!'</li> <li>run</li> </ul> </li> </ul> <p>This allows some kind of recovery if you want to update the in-flash bootloader.</p> <p>The used addresses are the following:</p> <ul> <li>FLASH_BASE is the location in flash of the backup bootloader,</li> <li>FLASH_BASE + 0x40000 is the location of the main bootloader,</li> <li>CODE_BASE is the memory address of the bootloader in ram.</li> </ul> <p>By default, the following memory map is used:</p> <p>00000000..00100000: SMC, KV, CB, CD, CE, CF, CG, backup bootloader 00100000..00140000: main bootloader 00140000..00f7c000: empty space 00f7c000 : smc config block 00ffc000 : exploit buffer</p> <p>But this can be tweaked.</p> <p>Category: System Software Category: Hardware</p>"},{"location":"Hacks/SPI_Programmer/","title":"General","text":"<p>To communicate with the Flash Controller you need a device which is capable of the Xbox 360's SPI Protocol. There are ready-to-use devices you can buy or, if you aren't afraid of soldering your own hardware, DIY homebrew devices. Basically: Get the device programmed (if needed) and solder it according to the Diagram to your Xbox's mainboard - you can start reading/writing to your NAND after installing the needed drivers.</p>"},{"location":"Hacks/SPI_Programmer/#diy-homebrew","title":"DIY / Homebrew","text":""},{"location":"Hacks/SPI_Programmer/#lpt-spi-programmer","title":"LPT SPI Programmer","text":"<p>This type of programmer isn't really recommended as it's awfully slow and can probably cause high failure rates.</p> <p>Description coming later...</p>"},{"location":"Hacks/SPI_Programmer/#usb-spi-programmer","title":"USB SPI Programmer","text":"<p>Needed material:</p> <ul> <li>1x 50X100 PCB</li> <li>1x 12 MHz Resonator</li> <li>1x 220nF Capacitor</li> <li>1x 100nF Capacitor</li> <li>1x 10 kOhm Resistor</li> <li>6x 100 Ohm Resistor</li> <li>1x 1 Row x 10 Pin - 2,54mm Pin Headers (male)</li> <li>1x 1 Row x 10 Pin - 2,54mm Pin Headers (female)</li> <li>1x PIC 18F2455-I/SP</li> <li>1x USB Conector (female)</li> <li>1x Matching USB Cable</li> <li>Wire</li> </ul> <p>Program the PIC with your favorite PIC Programmer (Can be build or bought - for building one yourself the \"ART2003\" is recommended) with the latest \"Picflash\" HEX file. </p>"},{"location":"Hacks/SPI_Programmer/#lpc2148","title":"LPC2148","text":"<p>Description coming later...</p>"},{"location":"Hacks/SPI_Programmer/#at90usb162-programmer","title":"AT90USB162 Programmer","text":"<p>Description coming later...</p>"},{"location":"Hacks/SPI_Programmer/#ready-to-use","title":"Ready to use","text":"<p>There are several ready-to-use professional products like: Team Xecuter NAND-X, Maximus 360NandFlasher, Matrix SPI Programmer etc. They arrive preprogrammed and can be used directly with Software like NANDPro to interact with the NAND Flash.</p>"},{"location":"Hardware/","title":"Hardware","text":"<p>RF Module</p> <p>Run Code</p> <p>Southbridge</p> <p>Stereo DAC</p> <p>Trinity</p> <p>UART</p> <p>USB</p> <p>Webcam</p> <p>Wifi Adapter</p> <p>Xbox 360 Motherboard</p> <p>Xenon</p> <p>Xenon (CPU)</p> <p>Xenon (Motherboard)</p> <p>Xenos (GPU)</p> <p>Zephyr</p>"},{"location":"Hardware/8051_8052/","title":"8051 / 8052","text":"<p>The 8051/8052 is an 8-bit microcontroller developed by Intel in 1980. The 8051/8052 is used in the Xbox 360. It is known as the SMC. It controls the front panel lights, DVD tray, fans, temperature sensors, etc.</p> <p>Category: Hardware</p>"},{"location":"Hardware/Fusesets/","title":"Understanding the Xbox 360's Fusesets","text":"<p>The Xbox 360's Xenon CPU has 768 bits of eFUSE, a technology invented by IBM, and implemented in some of it's processors. eFUSEs are hardware fuses on the CPU, and can be \"blown\" to a binary value (1 being blown, and 0 being un-blown) in the Xbox 360, there are 768 fuses, that make up the fusesets. Though each fuseset can be blown individually, they are blown in groups of 8 to make a hexadecimal value for the CPU key, and fuseline 00, instead of a binary value, which is what XeLL will actually display. Technically, there are only 192 viewable fuses.</p>"},{"location":"Hardware/Fusesets/#what-they-look-like","title":"What They Look Like","text":"<p>Once you aquire the fusesets (From either XeLL or dump32 in Linux) they look like this:</p> <pre><code>fuseset 00: C0FFFFFFFFFFFFFF\nfuseset 01: 0F0F0F0F0F0F0FF0\nfuseset 02: 0F00000000000000\nfuseset 03: 9FB0174015744DAF\nfuseset 04: 9FB0174015744DAF\nfuseset 05: D569BAD6958DAE9D\nfuseset 06: D569BAD6958DAE9D\nfuseset 07: FFFF000000000000\nfuseset 08: 0000000000000000\nfuseset 09: 0000000000000000\nfuseset 10: 0000000000000000\nfuseset 11: 0000000000000000\n</code></pre>"},{"location":"Hardware/Fusesets/#their-real-binary-values","title":"Their Real Binary Values","text":"<p>If you were actually reading the fuses, they would look like this (0 being an un-burned fuse, and 1 being a burned fuse) There should be 768 ones and zeros here, hence the \"768 Bits\" of eFUSE. This doesn't mean anything, but is just to show how the eFUSE's are actually set up.</p> <pre><code>Fuseset 00: 1100011111111111111\nFuseset 01: 0101010101010110\nFuseset 02: 0100000000000000\nFuseset 03: 1001111110110000000101110100000000010101011101000101000000000000\nFuseset 04: 1001111110110000000101110100000000010101011101000101000000000000\nFuseset 05: 1101010101101001101110101101011010010101100011011011000000000000\nFuseset 06: 1101010101101001101110101101011010010101100011011011000000000000\nFuseset 07: 1111000000000000\nFuseset 08: 0000000000000000\nFuseset 09: 0000000000000000\nFuseset 10: 0000000000000000\nFuseset 11: 0000000000000000\n</code></pre>"},{"location":"Hardware/Fusesets/#fusesets-00-and-01","title":"Fusesets 00 and 01","text":"<p>These are burned at the factory, after the console is manufactured, they show whether the console is a devkit or not. They also disable CPU JTAG after the console's flash is programed.</p> <pre><code>Retail fuseset 01: 0F0F0F0F0F0F0FF0\nDevkit fuseset 01: 0F0F0F0F0F0F0F0F\n</code></pre>"},{"location":"Hardware/Fusesets/#fuseset-02","title":"Fuseset 02","text":"<p>This is the lockdown counter for the 2BL/CB (The 2nd Bootloader, stored in NAND Flash) One of these are burned everytime the console updates it's bootloader (Which isn't very often) this is the reason that there is no way to recover a JTAG that has been updated to 2.0.8***.0, even is you have the CPU key, (2BL is encrypted with the CPU/1BL key, but is signed with Microsoft's private key so you can't change the lockdown counter in the NAND. The bootloader will fail signature checks, and panic)</p>"},{"location":"Hardware/Fusesets/#fusesets-03-06","title":"Fusesets 03-06","text":"<p>These make up the CPU key. These start out as all zero's, and are burned presumably at random when the console boots for the first time, they are used to encrypt the keyvault, and the bootloader sections. The CPU key is unique to each console, and is sometimes refered to as the \"per-box key\" To find the CPU key, add fusesets 03, and 05, OR 04 and 06. For example, this console's CPU key would be <code>9FB0174015744DAFD569BAD6958DAE9D</code>.</p>"},{"location":"Hardware/Fusesets/#fusesets-07-11","title":"Fusesets 07-11","text":"<p>These make up the console's \"Lockdown Counter.\" They are blown after each dashboard update starting with the update from 4532/4548 to 4598. They prevent a previous version of the dashboard from being run on an updated console. There are enough eFUSEs in this section for Microsoft to update the console roughly 80 times. The lockdown counter of this console is at FFFF00000..., this means that it has received 4 dashboard updates since 2.0.4548.0 ran on it. Microsoft originally intended to only blow an eFUSE when a system update patched a critical vulnerability (Like the Hypervisor vulnerability in 4532 and 4548) but has now decided to blow an eFUSE with every update since the update to 4598. In the NAND's 6BL(CF) section, there is another lockdown counter that should(Under normal circumstances) match the fuselines on the CPU. If it doesn't match, the console will panic on boot, and will show a RRoD. Now, here's the good part! If we know the CPU key of the console, we can decrypt the 6BL, and change the lockdown counter in the NAND to match the one on the console, and therefore run an older dashboard. Since the 6BL isn't signed with Microsoft's private key, we can edit it as we please, so long as we have our CPU key.</p>"},{"location":"Hardware/Fusesets/#dumping-the-fusesets","title":"Dumping the fusesets","text":"<p>This is how the bootloaders do it</p> <pre><code>QWORD getFuseline(DWORD fuse)\n{\n    if ((fuse * 0x40) &lt; 0x300)\n        return *(QWORD*)0x8000020000020000ULL + ((fuse * 0x40) &lt;&lt; 3);\n    return 0;\n}\n\nvoid DumpFuses()\n{\n    QWORD fuses[12] = { 0 };\n\n    printf(\"Fuses:\\n\");\n    for (int i = 0; i &lt; 12; i++)\n    {\n        fuses[i] = getFuseline(i);\n        printf(\"Fuse [%02d]: %016llX\\n\", i, fuses[i]);\n    }\n}\n</code></pre> <p>Category: System Software Category: Hardware</p>"},{"location":"Hardware/Level_Shifter/","title":"Level shifter","text":""},{"location":"Hardware/Level_Shifter/#build-your-own","title":"Build your own","text":"<p>To be able to debug LibXenon / XeLL stuff you want most likely a LVTTL, here is how you build one:</p> <p>You need: 1x MAX3232 IC 5x 0,1uF Caps 1x 9-pin D-Sub Port Solder all according to this picture. </p> <p>Now you just hook it up like on the diagram showed on this page: Serial Console</p> <p>Category: Hardware</p>"},{"location":"Hardware/R6T3/","title":"R6T3","text":"<p>R6T3 is the label of a resistor on the mainboard of the Xbox 360, it supplies the necessary voltage for the Xenon (CPU) to burn the so-called eFuses. Burned eFuses prevent older firmwares (any older rev. than 4552) from running on your Xbox 360, thus eliminating the possibility to downgrade to an earlier version of the kernel. The Resistor itself is located in the field T-6. It is a 10k Ohm (10,000Ohm) SMT resistor (Case 0402) functioning as part of a current limiting circuit.</p> <p></p> <p>The eFuse circuit uses a dual BJT array part MBT3904. The datasheet says:</p> <p>Q1 has</p> <ul> <li>Pin 3 - collector</li> <li>Pin 4 - emmiter</li> <li>PIn 5 - base</li> </ul> <p>Q2 has</p> <ul> <li>Pin 1 - emmiter</li> <li>Pin 2 - base</li> <li>PIn 6 - collector</li> </ul> <p>From looking at the board traces, R6T3 is the collector resistor to Q2. The collector pin enables the LDO that provides the voltage for the eFuse burning. The base of Q2 is tied to the collector of Q1. When Q2 is on, the voltage at the collector is logic LO and the LDO is disabled (logic LO at the enable pin). Q2 turns on when the base is logic HI, which means Q1 must be off, so the voltage will pull high through the Q1 collector resistor.</p>"},{"location":"Hardware/R6T3/#important-note","title":"Important Note","text":"<ul> <li>The removal of R6T3 will cause an E80 system error if the NXE update     is installed.</li> <li>Replacing the resistor with the original or with another 10K Ohm     resistor usually fixes the error state.</li> <li>Given the difficulty in surface mounting a resistor as small as     R6T3, simply holding a 10K Ohm in place while the 360 is powering up     after giving a E80 will typically allow normal operation from then     on.</li> <li>Care must be taken not to bridge the gap without a resistor in place     as this may cause system damage.</li> </ul>"},{"location":"Hardware/R6T3/#alternative-to-removing-r6t3","title":"Alternative to Removing R6T3","text":"<p>For people who find removing R6T3 too difficult can follow one of the two solution:</p> <p>if U6T1 is present </p> <p>if U6T2 is present  Shorting pin 6 to pin 1 (C to E) of the transistor pack, or pin 6 (C) to any convenient ground. Thats only one jumper, ena pin cant go hi, since its grounded.</p>"},{"location":"Hardware/R6T3/#external-links","title":"External Links","text":"<ul> <li>Just discussing possible alternatives to removing R6T3 at XboxHacker</li> <li>HIGH RES R6T3 IMAGE</li> </ul>"},{"location":"Hardware/R6T3/#slim-version","title":"Slim Version","text":"<p>The slim version of R6T3 on the trinity motherboard is R4R1. It is located right next to the x-clamp on the bottom of the motherboard. Some people have reported removing the resistor will not throw an error on startup, but will throw an error if the console tries to update. </p> <p>Category: Hardware</p>"},{"location":"Hardware/Accessories/Chatpad/","title":"Chatpad","text":"<p>The Xbox 360 Chatpad is a small keyboard designed to plug into the base of an Xbox 360 Gamepad via the headset jack.</p> <p>It is available in the Xbox 360 Messenger Kit.</p> <p>Category: Hardware</p>"},{"location":"Hardware/Accessories/GamePad/","title":"Gamepad","text":""},{"location":"Hardware/Accessories/GamePad/#speculation","title":"Speculation","text":"<ul> <li>Rumors that both the wired gamepad and wireless dongle share the     same interface, but probably won't have the same USB device IDs.</li> <li>The last six bytes of the input descriptor are for analog face     buttons. The information on the web is contradictory. I know that     the controller did have pressure sensitive face buttons originally.     Some web sites now say that it does not, so they must have been     scrapped. Others say that it still does have them. If it does not     the bytes are just a relic, but if the controler does have the     analog buttons then there must be some form of toggle mechanism.</li> </ul>"},{"location":"Hardware/Accessories/GamePad/#pinouts","title":"Pinouts","text":""},{"location":"Hardware/Accessories/GamePad/#headset-connector","title":"Headset Connector","text":"<p>The headset connector is a usual 2.5 mm TRS-Jack and is totally compatible with the old Xbox headset. The pinout is shown below:</p> <pre><code>  ___   S  R T\n |   '----,-,-.\n |   ,----'-'-'\n \\   /\n  | |\n</code></pre> <ul> <li>S (Shield): Ground, common for Speaker (-) and Microphone (-)</li> <li>R (Ring): Speaker (+), can be left open</li> <li>T (Tip): Microphone (+), feeds elctret mic, shorten to ground for     muting</li> </ul>"},{"location":"Hardware/Accessories/GamePad/#xbox-360-wireless-controller","title":"Xbox 360 Wireless Controller","text":"<p>Wire Connector (Play'n'Charge Cable)</p> <pre><code>    | LT |         _______,__,______         | RT |\n    ________       \\ ------------- /      _________\n         LB         ___,__,__,___/        RB\n    --------         1 2 3 4 5 6 7        ---------\n</code></pre> <p>(View on Controller when turning 90 degrees towards user)</p> <p>Pin Functions:</p> <ul> <li>1 GND (Ground, black wire of USB)</li> <li>2 Data A (unknown function but likely paired with pin 7)</li> <li>3 VCC (Supply Voltage, works good with 3.3V, see note!)</li> <li>4 Unknown (charge option?)</li> <li>5 USB D+ (Data Line, greeen wire of USB)</li> <li>6 USB D- (Data Line, white wire of USB)</li> <li>7 Data B (unknown, see pin 2)</li> </ul> <p>Note: The supply voltage for Memory Units and other Accessories is always 3.3 Volts. The front side USB socket of the Xbox has a supply of 5V as required by standard USB devices like memory sticks or legacy keyboards. Experiments have proven that the Controller works good on Xbox USB port when wired up according to the pinout above and by inserting a 3.3 Volts positive regulator between VUSB (red) and VCC on (pin 3). As written inside the battery slot the Controller might be rated for 5V - if anyone has a spare trash controller he could try it without fear of frying the pad...</p> <p>Category: Hardware</p>"},{"location":"Hardware/Accessories/Headset/","title":"Headset","text":""},{"location":"Hardware/Accessories/Headset/#general-information","title":"General Information","text":"<ul> <li>The Xbox Live Headset Plugs Directly into Xbox 360 Controller.</li> <li>The headset provides for both volume control and muting of the     microphone.</li> <li>The old Xbox Live headset will work with the Xbox 360 but volume     control must then be done through the dashboard.</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Accessories/Media_Remote/","title":"Media remote","text":"<p>Standard Media Remote\u2022The standard remote (as opposed to the Universal Media Remote) was only released in limited quantities with Xbox 360 premium packages at launch.</p> <ul> <li>The difference between the Universal Media Remote and the Standard   Remote appears to just be the button additions.</li> <li>The remote uses the IR port located on the front of the Xbox 360.</li> <li>Some Windows Media Center Edition computers recognize this remote as   a normal Media Center remote.</li> </ul>"},{"location":"Hardware/Accessories/Media_Remote/#confirmed-facts","title":"Confirmed Facts","text":"<ul> <li>All Windows Media Center remotes are recognized by the Xbox 360.</li> </ul>"},{"location":"Hardware/Accessories/Media_Remote/#linux-facts","title":"Linux Facts","text":"<p>Big remote Big remote</p> <ul> <li>IRCODE , Function</li> <li>{'26','Button Y'},</li> <li>{'25','Button B'},</li> <li>{'24','DVD menu'},</li> <li>{'23','BACK'},</li> <li>{'22','OK'},</li> <li>{'20','Button left'},</li> <li>{'21','Button right'},</li> <li>{'19','Stop button'},</li> <li>{'18','Pause button'},</li> <li>{'17','Rec button'},</li> <li>{'16','Play button'},</li> <li>{'15','Fast rewind \\&lt;\\&lt;'},</li> <li>{'14','fast foward &gt;&gt;'},</li> <li>{'11','Volume down'},</li> <li>{'10','Volume up'},</li> <li>{'09','Button 9 on ke*ypad part'},</li> <li>{'08','Button 8 on ke*ypad part'},</li> <li>{'07','Button 7 on ke*ypad part'},</li> <li>{'06','Button 6 on ke*ypad part'},</li> <li>{'05','Button 5 on ke*ypad part'},</li> <li>{'04','Button 4 on keypad part'},</li> <li>{'03','Button 3 on keypad part'},</li> <li>{'02','Button 2 on keypad part'},</li> <li>{'01','Button 1 on keypad part'},</li> <li>{'00','Button 0 on keypad part'},</li> <li>{'1a','Go to ending &gt;|'},</li> <li>{'1b','Go to beginning |\\&lt;'},</li> <li>{'1c','Unknown'},</li> <li>{'1d','100 on remote'},</li> <li>{'1e','Button up'},</li> <li>{'1f','Button down'},</li> <li>{'0a','Clear'},</li> <li>{'0b','ENTER'},</li> <li>{'0c','Unknown'},</li> <li>{'0d','Windows Media Start'},</li> <li>{'0e','Mute'},</li> <li>{'0f','Info'},</li> <li>{'4f','Display'},</li> <li>{'51','Title'},</li> <li>{'64','Big X button on top, use as alternative 'on'?'},</li> <li>{'68','Button X'},</li> <li>{'66','Button A '},</li> <li>{'6c','Channel up'},</li> <li>{'6d','Channel down'};</li> </ul> <p>the small remote 'image insert here'</p> <ul> <li>IRCODE , Function</li> <li>{'64','guide'},</li> <li>{'19','stop'},</li> <li>{'18','pause'},</li> <li>{'16','play'},</li> <li>{'15','rewind'},</li> <li>{'14','fast forward'},</li> <li>{'1A','chapter next'},</li> <li>{'1B','chapter prev'},</li> <li>{'4F','display'},</li> <li>{'51','title'},</li> <li>{'24','dvd menu'},</li> <li>{'23','back'},</li> <li>{'0F','info'},</li> <li>{'1E','up'},</li> <li>{'1F','down'},</li> <li>{'20','left'},</li> <li>{'21','right'},</li> <li>{'22','ok'},</li> <li>{'12','A'},</li> <li>{'25','B'},</li> <li>{'13','X'},</li> <li>{'26','Y'},</li> <li>{'0D','windows'},</li> <li>{'17','record'};</li> </ul>"},{"location":"Hardware/Accessories/Media_Remote/#proof-of-concept-code-by-icekiller","title":"Proof of concept code by Icekiller","text":"<pre><code>/*\n * Example code of how to use the build in IR of the xbox 360\n * Code rewritten based on tmbinc's smc.c\n * free to use under GPL\n *\n * 20 januari 2008 by Icekiller\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;getopt.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n\n#define SMC_FILENAME \"/dev/smc\"\n\nint smc_fd;\nvoid wait(int seconds)\n{\n    clock_t endwait;\n    endwait = clock() + seconds * CLOCKS_PER_SEC;\n    while (clock() &lt; endwait) {\n    }\n}\n\nint main(int argc, char **argv)\n{\n    int first = 1;\n    /* try open SMC. if this doesn't work, bail out. */\n    smc_fd = open(SMC_FILENAME, O_RDWR);\n    if (smc_fd &lt; 0) {\n    perror(SMC_FILENAME);\n    return 1;\n    }\n\n    while (1) {\n    unsigned char msg[16];\n    int option_index = 0, c;\n    msg[0] = 0x16;\n    /* prepare message */\n    memset(msg, 0, 16);\n\n    if (c != 'w') {\n        msg[0] = 0x16;\n\n        int i;\n\n        if (write(smc_fd, msg, 16) != 16) {\n        perror(\"write\");\n        break;\n        }\n    }\n\n    if ((c == 'w') || (msg[0] &lt; 0x80)) {\n        int wait_for = msg[0];\n        while (1) {\n        msg[0] = 0x16;\n        if (read(smc_fd, msg, 16) != 16)\n            perror(\"read\");\n\n        int valueread;\n        valueread = msg[3];\n\n        if (msg[0] != 0x16)\n            switch (valueread) {\n            case 0x26:\n            printf(\"Button Y\");\n            break;\n            case 0x25:\n            printf(\"Button B\");\n            break;\n            case 0x24:\n            printf(\"DVD menu\");\n            break;\n            case 0x23:\n            printf(\"Back\");\n            break;\n            case 0x22:\n            printf(\"OK\");\n            break;\n            case 0x21:\n            printf(\"Button left\");\n            break;\n            case 0x20:\n            printf(\"Button right\");\n            break;\n            case 0x19:\n            printf(\"Stop button\");\n            break;\n            case 0x18:\n            printf(\"Pause button\");\n            break;\n            case 0x17:\n            printf(\"Rec button\");\n            break;\n            case 0x16:\n            printf(\"&gt;\");\n            break;\n            case 0x15:\n            printf(\"&lt;&lt;\");\n            break;\n            case 0x14:\n            printf(\"&gt;&gt;\");\n            break;\n            case 0x13:\n            printf(\"Button X\");\n            break;\n            case 0x12:\n            printf(\"Button A\");\n            break;\n            case 0x11:\n            printf(\"Volume down\");\n            break;\n            case 0x10:\n            printf(\"Volume up\");\n            break;\n            case 0x09:\n            printf(\"Button 9\");\n            break;\n            case 0x08:\n            printf(\"Button 8\");\n            break;\n            case 0x07:\n            printf(\"Button 7\");\n            break;\n            case 0x06:\n            printf(\"Button 6\");\n            break;\n            case 0x05:\n            printf(\"Button 5\");\n            break;\n            case 0x04:\n            printf(\"Button 4\");\n            break;\n            case 0x03:\n            printf(\"Button 3\");\n            break;\n            case 0x02:\n            printf(\"Button 2\");\n            break;\n            case 0x01:\n            printf(\"Button 1\");\n            break;\n            case 0x00:\n            printf(\"Button 0\");\n            break;\n            case 0x1a:\n            printf(\"&gt;|\");\n            break;\n            case 0x1b:\n            printf(\"&lt;\");\n            break;\n            case 0x1c:\n            printf(\"Unknown\");\n            break;\n            case 0x1d:\n            printf(\"Unknown\");\n            break;\n            case 0x1e:\n            printf(\"Button up\");\n            break;\n            case 0x1f:\n            printf(\"Button down\");\n            break;\n            case 0x0a:\n            printf(\"Clear\");\n            break;\n            case 0x0b:\n            printf(\"ENTER\");\n            break;\n            case 0x0c:\n            printf(\"Unknown\");\n            break;\n            case 0x0d:\n            printf(\"WMS\");\n            break;\n            case 0x0e:\n            printf(\"Mute\");\n            break;\n            case 0x0f:\n            printf(\"Info\");\n            break;\n            case 0x4f:\n            printf(\"Display\");\n            break;\n            case 0x51:\n            printf(\"Title\");\n            break;\n            case 0x64:\n            printf(\"Guide\");\n            break;\n            case 0x68:\n            printf(\"Button X\");\n            break;\n            case 0x66:\n            printf(\"Button A\");\n            break;\n            }\n        printf(\"\\n\", valueread);\n        if (msg[0] == wait_for)\n            break;\n        }\n    }\n    wait(1);\n    }\n\n}\n</code></pre> <p>The remote control works as a lowbase of the xbox360, so the power on and off still work in Linux, also you can get all the IR codes into linux. So 'if' a Mediacenter is ever ported to Xbox 360 Linux, you could use the official remote. (IR codes and info retrieved by Icekiller, with SMC.C from tmbinc, small remote by kwkward)</p> <p>Category: Hardware</p>"},{"location":"Hardware/Accessories/Memory_Unit/","title":"Memory unit","text":""},{"location":"Hardware/Accessories/Memory_Unit/#general-information","title":"General Information","text":"<ul> <li>Memory Units (64 MB) require no setup or configuration. (Plug &amp;   Play)</li> <li>Xbox 360 accepts two Memory Units.</li> <li> <p>Each unit contains three IC's:</p> </li> <li> <p>Custom Microsoft ASIC (marked as X805867-002)</p> </li> <li>Samsung NAND flash memory (IC model depends on memory size i.e.     K9F1208U)</li> <li>Perhaps an IC EEPROM memory (marked as X803122)</li> </ul>"},{"location":"Hardware/Accessories/Memory_Unit/#known-facts","title":"Known Facts","text":"<ul> <li>The Memory card is required in absence of hard drive to play on Xbox   Live and to save game progress.</li> <li>The memory cards are USB devices, albeit with custom connectors and   with 3.3V power (not 5V).</li> </ul>"},{"location":"Hardware/Accessories/Memory_Unit/#pinout","title":"Pinout","text":""},{"location":"Hardware/Accessories/Memory_Unit/#inside-the-memory-unit","title":"Inside the memory unit","text":""},{"location":"Hardware/Accessories/Memory_Unit/#flash-contents","title":"Flash Contents","text":"Address Length (bytes) Contains 0x00000 16 Text String \"DUMBO FIL format\" 0x0020B 5 5 byte value 0x04200 32 MS text string 0x04220 15 Ascii serial nr of MU 0x0440B 5 5 byte value 0x10800 ~ Data start"},{"location":"Hardware/Accessories/Memory_Unit/#fatx-partition-locations","title":"FATX Partition Locations","text":"Address Type 0x00 Partition 1 0x7ff000 Partition 2"},{"location":"Hardware/Accessories/Memory_Unit/#speculation","title":"Speculation","text":"<p>The connections of the small 8-pin IC:</p> Pin# Description Characteristic 1 GND A0 2 NC A1 3 NC A2 4 NC GND 5 to pin 22 of ASIC SDA 6 to pins 20 and 21 of ASIC SCL 7 to pin 3 of ASIC WP 8 VCC VCC (3.3V) <p>At the bottom side of this chip is written:</p> <pre><code>PHILK2B\nEL526\n901IA2\n</code></pre> <p>Most plausible theory is that the IC is an IC EEPROM memory. I've added in brackets possible 24CXXX family pin names. GND could be A0 because in most cases adress lines (A0-A2) are connected to ground.</p> <p>Other theory (less plausible) is that it might be a NXP (Philips) P89LPC901FD microcontroller with its die upside down? archive.org mirror: here</p> <p>When supplying 3.3 volts to the Memory Unit: Measurements at pins 5, 6, and 7 show that there is a clock signal of 5Mhz present on pin 7 (in burst of 16 cycles). Every 16 cycles, one bit is transferred on pin 6. 3ms after powerup data communication ends. Note: This looks like SPI, pin 7 - SCK, Pin 6 - /SS, Pin 5 - MODI.</p> <p>But SPI needs four wires. It's more like I<sup>2</sup>C which needs only two lines (SDA, SCL) and optionally WP (Write Protect).</p> <p>Category: Hardware</p>"},{"location":"Hardware/Accessories/Play_and_Charge_Kit/","title":"Play and Charge Kit","text":"<p>The Play and Charge Kit is sold separately from the Xbox 360 Wireless Controller. It contains a rechargable battery pack and a USB cable which connects the controller to the console.</p>"},{"location":"Hardware/Accessories/Play_and_Charge_Kit/#battery-pack","title":"Battery Pack","text":"<p>The battery pack that comes with the Play amd Charge Kit contains 2 standard rechargable AA batteries soldered to a control circuit board with a 6-pin header.</p> <p>The pinout for the header is (left to right): Temp, P-/GND, SCK, SCA, P, VCC</p> <p>The SCK, SCA, GND, and VCC pins are connected to an AT24C04M 2-wire serial EEPROM chip. Presumably the controller checks the EEPROM to verify that the battery pack has been charged fewer than a factory-set number of times and stops charging if that number is exceeded.</p> <p>Category: Hardware</p>"},{"location":"Hardware/Accessories/Webcam/","title":"Xbox Live Vision Camera","text":"<p>The web cam, also known as Xbox Vision Cam, that you can buy separate from the xbox 360 is just a little web cam that you can twist and move yourself. You can send picture messages with it, have video chats and a few other little things like having the background warping appropriate to your movement in front of the vision cam. The quality isn't amazing but it suits the purpose of what the device is used for which is just simple things like video chatting and picture messaging. When video chatting audio is heard through the microphone. They aren't as popular as they used to be probably because of the Kinect having all of these features and much more built in.</p> <p>Category: Hardware</p>"},{"location":"Hardware/Accessories/Wifi_Adapter/","title":"Introduction","text":"<p>FCC ID:C3K-WKS168 IC: 3048A-WKS168</p> <p>The Wireless Network Adapter is a dual-band (2.4/5GHz) 802.11a/b/g interface for the Xbox 360.</p> <p>This is a standard USB 2.0 device, and although it is designed to clamp onto the back of the console, it works when plugged into a standard USB port, given your operating system has accompanying device drivers. See below.</p>"},{"location":"Hardware/Accessories/Wifi_Adapter/#disassembly","title":"Disassembly","text":"<p>All Pieces of the Wifi Adapter Laid out </p> <p>Disassembled; bottom and top covers, PCB, USB cable and antenna</p> <p>Wireless LAN Adapter Opened (Back) </p> <p>PCB underside, with Hannstar Board Corp. inscription.</p>"},{"location":"Hardware/Accessories/Wifi_Adapter/#integrated-circuits","title":"Integrated Circuits","text":"<p>Wireless LAN Adapter Opened (Front) </p> <p>PCB upper-side, showing the major ICs</p>"},{"location":"Hardware/Accessories/Wifi_Adapter/#marvell-mvpg16","title":"Marvell MVPG16","text":"<p><code>MG16R</code> <code>00A2R</code> <code>521AC</code></p> <p>The MVPG16 is an integrated DC-DC synchronous step-down switching regulator. Input voltage ranges from 3.0V-5.5V. Output voltage ranges from 0.72V-3.63V and is user-programmable via a single external resistor.</p> <p>There's no readily available datasheet for this particular IC, however, one for it's modular MDx-G16 counterpart is, for download. There's a two-page brochure as well, but is rather lacking in the more technical details.</p> <p>Product information page at http://www.marvell.com/products/power/dspswitcher/index.jsp</p>"},{"location":"Hardware/Accessories/Wifi_Adapter/#marvell-88w8388-bdk1","title":"Marvell 88W8388-BDK1","text":"<p><code>88W8388-BDK1</code> <code>AGW1P\u00a0.2</code> <code>0530\u00a0A2P</code> <code>TW</code></p> <p>The 88W8388 is an 802.11a/b/g WLAN SoC from Marvell. Embedded are an ARM946E-S core (as per the ARM Networking.pdf Networking brochure) and on-chip memory. Together with an integrated TCP/IP stack, this allows for off-loading the host processor of protocol processing. This SoC is targeted at small-footprint devices, eg. cellular/VoIP phones, PDAs, video game consoles, etc.</p> <p>The 88W8388 is 88W88305-derived, as indicated below (table reproduced from http://www.clv.macnica.co.jp/product/marvell/sub1.html):</p> Part no. b/g/a Package option CLK Type Interface Feature/Advantage 88W8305 b TQFP 128pin 14x14x1.2 TBGA no option Flip chip Yes 20, 40, 44 CMOS only CF SDIO (SPI) TKIP (firmware) AES (hardware) WPA (firmware) Power Save 88W8381 b TQFP 128pin 14x14x1.2 TBGA 132pin 8x8x1 Flip chip Yes 19.2, 20, 26, 38.4, 40, 44 COMS &amp; Low swing sine wave CF SDIO (SPI) 8305 TKIP (hardware) 802.11e (QoS) 802.11i (Security) BT coex 88W8385 a/b/g TQFP 128pin 14x14x1.2 TBGA 132pin 8x8x1 Flip chip Yes 19.2, 20, 26, 38.4, 40, 44 COMS &amp; Low swing sine wave CF SDIO (SPI) Generic SPI 8381 a/g 88W8388 a/b/g TQFP No TBGA 132pin 8x8x1 Flip chip Yes 19.2, 20, 26, 38.4, 40, 44 COMS &amp; Low swing sine wave SDIO (SPI) USB 2.0 8385 TCP/IP termination NAND Flash I/F Audio Codec I/F <p>Baseband Processor Product Selection table</p> <p>Category: Hardware Category: Pages That Need Updates</p>"},{"location":"Hardware/Console/Case/","title":"Case","text":"<p>The Xbox 360 Case is made of plastic and was originally made to be hard to open. However it can easy be removed :</p> <ul> <li>Remove the HDD</li> <li>Remove the Face Plate by inserting your Right thumbs into it and   forcing it a bit upwards</li> </ul> <p></p> <p>You need to remove this panel before lifting the front panel\u2022Then remove both side pannels by inserting a small iron tool into the holes, and popping out the place holders</p> <ul> <li>Slowly lift up the Front panel, by unlocking the 4 plastic placesholders about 4cm</li> <li>Then insert a small tool in each hole of the backplate and open up the back side</li> </ul> <p>You now can lift up the upper part of the casing</p> <p>To remove the border case, Remove 6 large screws from the down panel with a torx T10 screw driver.</p> <p></p> <p></p> <p>Category: Hardware</p>"},{"location":"Hardware/Console/DVD_Drive/","title":"DVD drive","text":"<p>The DVD Drive is used by the Xbox 360 for playing games, movies, running executables, listening to music. The firmware of most DVD Drives can be modified to play backups, or aid in the running of unsigned code.</p>"},{"location":"Hardware/Console/DVD_Drive/#models","title":"Models","text":"<p>There are at least four different types of DVD drives used in the 360:</p> <ul> <li>Hitachi-LG GDR-3120L (Multiple ROM revisions)</li> <li>Toshiba/Samsung TS-H943 (MS25 / MS28)</li> <li>BenQ VAD6038</li> <li>Lite-On DG16D2S</li> </ul> <p>The model you get depends on where your Xbox was manufactured, when it was manufactured, what batch it was in and a lot of other factors.</p>"},{"location":"Hardware/Console/DVD_Drive/#general-information","title":"General Information","text":"<ul> <li>The Xbox 360 was launched with a standard dual layer DVD-ROM drive   manufactured by Hitachi-LG.</li> <li>The Xbox boots without any error when the DVD-ROM drive's SATA   connector and power cable are not connected. However, the power   light flashes rapidly, just like when the tray is ejecting.</li> <li>The drive uses the standard 7-pin Serial ATA connectors with a   non-standard power connector (2\u00d76 pins, roughly 2mm spacing; Molex   Milli-Grid look similar, and Hirose make them, too).</li> <li>Xbox internally calls it <code>\\\\Device\\\\CdRom0\\\\</code></li> <li>The raw file system (XDVDFS) on the disk is   similar to the file system on the original Xbox disks. Multiple   tools are out there that will extract raw ISOs.</li> <li>Modified firmware exists for every DVD Drive model, to allow playing   backup games. (Unsigned code still can't be run)</li> <li>Two different DVD-ROM versions can be interchanged between Xbox 360s   if the DVD key (stored in the drive firmware) is changed to match   that of the target 360's original drive. Some   Kernel versions (&gt;= 4532?) also require the   drive to report as the same model as the original drive.</li> </ul>"},{"location":"Hardware/Console/DVD_Drive/#confirmed-facts","title":"Confirmed Facts","text":"<ul> <li>The main processor of the LG DVD-ROM drive is an Panasonic   MN103S94FDA</li> <li>Although present on the disc, The BCA is not used as a security   check.</li> <li>The XBOX 360 discs has a fake ToC (Table of Contents), containing   only the video section. However, using a hotswap method, we can read   a XBOX 360 disc using regular drive. First of all, we need to put a   full 8.5GB disc in the drive, then we need to hotswap it by a XBOX   360 disc (without eject, of course). With the right software, there   is a way to backup XBOX 360 discs using regular DVD+R DL drive.</li> </ul>"},{"location":"Hardware/Console/DVD_Drive/#speculation","title":"Speculation","text":"<ul> <li>A 12X DVD-ROM drive (DVD+R/RW) Single or dual-layer DVDs. The other   supported formats are: CD-DA, CD-ROM, CD-R/RW, WMACD, MP3CD, JPEG   Photo CD and original Xbox games for backwards compatibility.</li> <li>The DVD-ROM doesn't work on a standard PC workstation, yet.</li> <li>I found a very very thin ring on the underside of my DVD (PGR3).   It's located at the inner part of the dvd, it's very very thin so   you have to look very sharp for it! Maybe this is the reason why   the DVD laser can't read the data part. It reads the video part and   then can't \"jump\" over the thin ring to read the data part.</li> </ul>"},{"location":"Hardware/Console/DVD_Drive/#on-disc-format","title":"On-Disc format","text":"<p>the 2 different sections and the BCA area of the DVD-ROM are visible here.360 discs, like Xbox1 discs, have a lower number of sectors encoded in their dvd structure data. This makes it \"impossible\" to access the data after the \"leadout\" (or at least what is specified as leadout). The \"standard\" area has 0xDB0 (~7MB) sectors, and contains DVD-Video data, telling you that this is a game disc. Game data is stored at sector offset 0x1FB20 (LBA), so it's \"after the leadout\". The data itself, however, is stored dvd-compliant (standard ECC, standard seed, standard EDC, standard sector layout. How boring.). If you can get your drive to read past the specified end-of-disc, you can read the game data.</p> <p>A specific sector region, between the standard-data and the beginning of the game data can't be read. I guess this is the \"ring\" which is visible. It probably contains empty/weak sectors (reading really broken frames is always a bit difficult. Someone with the proper equipment might want to check this).</p> <p></p> <p>Evidence that the BCA is not used by the Xbox 360. The tools which can be used for this are basically the same as for Xbox1, just that the data offset was different there. There are \"scene-tools\" which are of course so top secret that you never heard about them which can do this. They can be hacked for Xbox 360 (by just modifiying the read offset), and there you go.</p> <p>(Of course the \"how to get your drive's firmware to do this\" is highly off-topic here, but it usually boils down to using debug ATAPI command to write in the drive's memory, then modifiying the drive's idea of the \"end-of-disc\", then using normal read commands. Some others say just opening up the DVD-Rom drive from inside out, Inserting a large DVD, then lifting it up vertically to do not trigger the eject mode, and then inserting a Original XBOX disc will also give you access)</p> <p>Category: Hardware</p> <p>Category: Pages with missing images</p>"},{"location":"Hardware/Console/Ethernet/","title":"Ethernet interface","text":"<p>The Xbox 360 use all the same Ethernet 10/100 network adapter. WiFi-adapter is missing, but can be purchased separately. For new revisions of consoles (Slim version) Wi-Fi-built module.</p> <p>Controller chip Fast Ethernet (on-board is usually referred to as U1B1 or U1B2)</p>"},{"location":"Hardware/Console/Ethernet/#ethernet-chip","title":"Ethernet Chip","text":""},{"location":"Hardware/Console/Ethernet/#ics1893bf","title":"ICS1893BF","text":"<p>Datasheet</p> <p>Comes from Integrated Circuit Systems, Inc.</p> <p></p>"},{"location":"Hardware/Console/Ethernet/#bcm5241","title":"BCM5241","text":"<p>Datasheet</p> <p>Comes from Integrated Circuit Systems, Inc.</p> <p>Pinout coming soon...</p>"},{"location":"Hardware/Console/Ethernet/#wlan-chip","title":"WLAN Chip","text":""},{"location":"Hardware/Console/Ethernet/#xbox-360-slim-internal-wifi-module","title":"Xbox 360 Slim - Internal Wifi module","text":"<p>The Xbox 360 Slim family (Corona/Trinity/Winchester) comes with an internal wifi module.</p> <p>It is connected to the motherboard via USB protocol, it uses 3,3V VCC instead of 5V!</p> <p>Generic info:</p> <ul> <li>Wifi Chipset: Marvell 88W8786U-NAP2</li> <li>Flash: Winbond W25X40BVSNIG (4Mbit / 512kB)</li> <li>USB IDs: 045e:0765</li> </ul> <p>There are different models of this board used:</p> <ul> <li>Model 1400, X850272-007, U72H003 GP 800571 REV.0, FCC: C3K1400</li> <li>Model 1488, X858591-002, Marvell B52 REV 3.0, FCC: C3K1488</li> </ul> <p> </p> <p>Category: Hardware</p>"},{"location":"Hardware/Console/HDD/","title":"Hard Drive Disk","text":"<ul> <li>The drive is manufactured by Samsung (Seagate Drives have been used   in some systems. Unknown if contents are the same) and is required   to play backward compatible Xbox games.</li> </ul>"},{"location":"Hardware/Console/HDD/#samsung-details","title":"Samsung details:","text":"<ul> <li>Model: SAMSUNG HM020GI</li> <li>Revision: YU100-06</li> <li>Serial Number: S0A8J20YA44356 (of course this is different for every   HD)</li> <li>Capacity: 18.63 GB</li> </ul>"},{"location":"Hardware/Console/HDD/#seagate-details","title":"Seagate details:","text":"<ul> <li>Model: ST920217AS</li> <li>Revision: 3.01/LD25.1</li> <li>Capacity: 20 GB</li> </ul>"},{"location":"Hardware/Console/HDD/#hitachi-details","title":"Hitachi details:","text":"<ul> <li>Model: HTS541020G9SA00 (Travelstar)</li> <li>Revision: C60D</li> <li>Capacity: 20 GB</li> <li>Vendor Support URL: [1]</li> </ul>"},{"location":"Hardware/Console/HDD/#confirmed-facts","title":"Confirmed Facts","text":"<ul> <li>The harddisk is not locked in any way. A completely zero drive will   only be read by the Xbox 360 if the relevent headers are in place on   the disk.</li> <li>A FATX partition exists on the drive</li> <li>For a drive to be considered valid it must have the 'Plain text HDD   info' and MS logo PNG. If these elements do not exist then no HDD is   detected. So there is no way for third parties to manufacture HDDs   without a license or without infringing Microsoft's copyright. (The   Gameboy used the same idea for cartridges). US courts have held (in   at least four separate cases) that Copyright cannot be used to   prevent interoperation.</li> <li>The 360's serial number is required when formatting a HDD.</li> <li>The drive's capacity is reported as 13GB by the 360 immediately   after formatting (20Gb HDD only).</li> </ul>"},{"location":"Hardware/Console/HDD/#speculation","title":"Speculation","text":"<ul> <li>There is no information at this time that leads us to believe the   HDD is encrypted, there are plenty of clear text entries that can be   read.</li> <li>The FATX partitions on the drive seem to be a   Big Endian version of the   1st Generation Xbox's FATX filesystem. Work is underway to modify   the Linux kernel driver to verify this. There is some initial   support for this file system in [CVS].</li> </ul>"},{"location":"Hardware/Console/HDD/#drive-contents","title":"Drive contents","text":"<p>The Xbox uses the FATX format for its partitions. The FATX page has more information about the partition locations and the FATX format itself.</p>"},{"location":"Hardware/Console/HDD/#power-connector","title":"Power connector","text":"Pin\u00a0#\u00a0 \u00a0Signal\u00a0Name\u00a0 \u00a0On\u00a0XBOX\u00a0360\u00a0 \u00a0Signal\u00a0Description 1\u00a0 \u00a0V33\u00a0\u00a0 Not\u00a0connected \u00a03.3V\u00a0Power 2\u00a0 \u00a0V33\u00a0\u00a0 Not\u00a0connected \u00a03.3V\u00a0Power 3\u00a0 \u00a0V33\u00a0\u00a0 Not\u00a0connected \u00a03.3V\u00a0Power,\u00a0Pre-charge,\u00a02nd\u00a0mate 4\u00a0 \u00a0Ground\u00a0 \u00a0Connected\u00a0 \u00a01st\u00a0Mate,\u00a0Pre-charge,\u00a02nd\u00a0mate 5\u00a0 \u00a0Ground\u00a0 \u00a0Connected\u00a0 \u00a02nd\u00a0Mate 6\u00a0 \u00a0Ground\u00a0 \u00a0Connected\u00a0 \u00a03rd\u00a0Mate 7\u00a0 \u00a0V5\u00a0\u00a0 Connected\u00a0 \u00a05V\u00a0Power 8\u00a0 \u00a0V5\u00a0\u00a0 Connected\u00a0 \u00a05V\u00a0Power 9\u00a0 \u00a0V5\u00a0\u00a0 Connected\u00a0 \u00a05V\u00a0Power 10 \u00a0Ground\u00a0\u00a0 Connected\u00a0 \u00a02nd\u00a0Mate 11 \u00a0Reserved\u00a0 Not\u00a0connected\u00a0 - 12 \u00a0Ground\u00a0\u00a0 Connected\u00a0\u00a0 1st\u00a0Mate 13 \u00a012V\u00a0\u00a0 Not\u00a0connected \u00a01st\u00a0Mate,\u00a0Pre-charge,\u00a02nd\u00a0mate 14\u00a0\u00a0 12V\u00a0\u00a0 Not\u00a0connected \u00a02nd\u00a0Mate 15\u00a0 \u00a012V\u00a0\u00a0 Not\u00a0connected \u00a03rd\u00a0Mate <p>This (probably) explains why normal 3.5\" sata drives won't even spin up (missing 12V). So if you want to use a 3.5\" drive you need to connect your own 12V.</p> <p>This table plus more info can be found in the electrical specification here. (Table 17, Page 117)</p>"},{"location":"Hardware/Console/HDD/#external-links","title":"External Links","text":"<ul> <li>http://watertastesgood.com/xbox/delta.py</li> <li>Tool to help do binary diffs of HDD images, courtesy of Daeken</li> <li>[http://www.xbox-linux.org/wiki/Xbox_Partitioning_and_Filesystem_Details]</li> <li>[http://www.xbox-linux.org/wiki/Differences_between_Xbox_FATX_and_MS-DOS_FAT]</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Memory/","title":"Memory","text":""},{"location":"Hardware/Console/Memory/#system-memory-mainboard-gpu","title":"System Memory - Mainboard &amp; GPU","text":"<ul> <li>512 MB of Unified GDDR3 RAM<ul> <li>Unified Memory Architecture</li> <li>Reduces cost and complexity of the motherboard design</li> </ul> </li> <li>700 MHz DDR<ul> <li>Effective transmission rate of 1.4 GHz on the 128-bit bus</li> </ul> </li> <li>Unified Memory Architecture (GPU &amp; CPU Access)<ul> <li>GPU 10MB eDRAM</li> </ul> </li> <li>128-bit interface to ATI's memory controller</li> </ul>"},{"location":"Hardware/Console/Memory/#memory-bandwidth","title":"Memory Bandwidth","text":"<ul> <li>32 GB/s GPU to eDRAM bandwidth<ul> <li>2 GHz @ 2 accesses per clock cycle on a 64 bit DDR bus</li> </ul> </li> <li>22.4 GB/s memory interface bus bandwidth (low latency path to CPU   cores)<ul> <li>700 MHz @ 2 accesses per clock cycle (one per edge) on a 128 bit   bus</li> </ul> </li> <li>256 GB/s memory bandwidth to eDRAM</li> <li>21.6 GB/s front-side bus</li> <li>Southbridge bandwidth of 500 MB/s.</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Motherboard/","title":"Motherboard","text":"<p>(This page is riddled with speculation and extrapolation of information from dodgy sources, so take it with a grain of salt.)</p> <p>The Xbox 360 motherboard (or motherboard) has undergone a few revisions, as Microsoft has corrected mistakes or added/improved existing features.</p> <ul> <li>Known revisions include:</li> </ul> <p>:*Xenon (Launch hardware)</p> <p>:*Zephyr (Elite)</p> <p>:*Falcon (65nm Chipset revision)</p> <p>:*Opus</p> <p>:*Jasper (Onboard Memory Unit)</p> <p>:*Trinity (Slim)</p>"},{"location":"Hardware/Console/Motherboard/#details","title":"Details","text":"<p>The motherboard PCB has four layers (sources: 1, 2), implying that the top and bottom layers (the ones we can see and probe) contain most of the signals. This is a good thing :)</p>"},{"location":"Hardware/Console/Motherboard/#cpu-gpu-front-side-bus","title":"CPU, GPU, &amp; Front side bus","text":"<p>According to these three sources the FSB is a serial bus with 16 differential pairs in each direction, and each pair runs at 5.4Gbit/s. This agrees with Microsoft's published bandwidth specification of 21.6 Gbyte/sec (10.8 Gbyte/sec each way, 16 bits/2 bytes at a time, 5.4 Gbit/sec per pair).</p> <p>Looking at photos of the motherboard, we can see 40 pairs of carefully routed tracks between the CPU and GPU. 32 pairs (16 each way) + 8 clock/handshake/parity? pairs = 40 pairs.</p> <p>This very high frequency interface will make probing and snooping on the bus extremely difficult, which is unfortunate because the Xbox1 security was compromised in part by a FSB bus snoop done by bunnie. At this frequency, the (relatively) simple task of attaching probe wires to the FSB will change the impedance seen on the bus by the FSB PHYs and cause the bus to fail to work correctly (look at eye diagram...). It might still be possible to probe the FSB with very expensive gear though.</p> <p>It's not very likely that they made the mistake of sending sensitive information on an exposed bus again though.</p>"},{"location":"Hardware/Console/Motherboard/#photos","title":"Photos","text":"<ul> <li>http://arstechnica.com/articles/paedia/cpu/xbox360-1.ars</li> <li>http://g-prime.net/x360/open/ (archive.org mirror)</li> <li>http://www.darkmoon.org/xbox360_photos.htm (archive.org mirror)</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Northbridge/","title":"Northbridge","text":"<p>The Xbox 360's North Bridge is integrated into the system's Xenos (GPU) and shares a memory controller with it.</p> <ul> <li>128-bit GDDR3 Memory Controller @ 1.4GHz (22.4GB/s)</li> </ul> <p>:*700 MHz 512MB Samsung GDDR3 RAM (8 chips, each 512Mbit by 16 bits)</p> <ul> <li>Shared System/Graphics memory</li> </ul> <p>::*(5.6GB/s per chip)</p> <p>::*90nm Process</p> <ul> <li>500MB/s read/write (1GB/s total) SIS Southbridge interface (PCI express)</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Pin_Headers/","title":"Pin Headers","text":"<p>There are ten sets of pin headers on the board. They are numbered according to the PCB sections (J X Y N).</p> <p></p> ID #Pins Purpose J1D2 9 XDK Debug Header #2 J1F1 6 Southbridge LED Header J2B1 13 XDK Debug header J2D1 6 Southbridge Header J2D2 8 GPU Header J5C1 6 ANA Header J5C2 6 GPU SPI EEPROM Header J7F1 6 CPU SPI EEPROM Header J7G1 3 Aux Power Header J8C1 10 CPU JTAG Header"},{"location":"Hardware/Console/Pin_Headers/#j1d2-j2d1-j2d2","title":"J1D2, J2D1, J2D2","text":"J1D2 Pin Signal Description 1 Unknown 2 Unknown 3 Unknown 4 Unknown 5 Unknown 6 Unknown 7 Unknown 8 GND Ground 9 GND Ground J2D1 Pin Signal Description 1 Unknown 2 Unknown 3 Unknown 4 Unknown 5 Unknown 6 GND Ground J2D2 Pin Signal Description 1 Unknown 2 Unknown 3 Unknown 4 Unknown 5 Unknown 6 GND Ground 7 Unknown 8 Unknown <p>Scheme</p> <p>Category: Hardware</p>"},{"location":"Hardware/Console/RF_Module/","title":"RF Module","text":"<p>The RF module is believed to be based on DECT technology:1 (Dutch)</p> <ul> <li>Chips on the RF module:</li> </ul> <p>:*Backside:</p> <p>::*ATMEL528 24C04N I2C EEPROM</p> <p>::*MS VS55RC</p> <p>:*Frontside (Under metal shield):</p> <p>::*MS VS55RB</p> <p>The RF Module also contains 4 red/green leds, 1 green led in the middle of the power button, 1 switch. The multi color leds are connected to the MS V55RC via resistors. The switch and the center led are connected to D8, a 1x2mm 6pin device (diode?).</p> <p>The VS55RB probably also performs some power management functions. It is possible to switch the box on via the wireless controllers, so the wireless part will need to be powered when the Xbox is switched off.</p> <p>The layout of the connectors is as follows:</p> <p><code>3.3v\u00a0\u00a0\u00a0usb\u00a0\u00a0\u00a0\u00a0usb\u00a0\u00a0\u00a0\u00a0gnd</code> <code>pon\u00a0\u00a0\u00a0\u00a0\u00a0fb1\u00a0\u00a0\u00a0fb2\u00a0\u00a0\u00a0\u00a0gnd\u00a0\u00a0\u00a0\u00a0TP17</code></p> <p>The two usb wires are connected to the southbridge. fb1 and fb2 ('front bus') form a slow serial bus, something like I2C but different: the bit numbers don't match and the start and stop conditions are different. These can be used to control the leds: for examble without AV cable, there is no USB activity on boot, but there is on this front bus. Whether the leds can be controlled by USB as well is unsure.</p> <p>Pon is a active low signal which goes low by pressing the power button. Perhaps also controlled by pressing the on function on wireless controllers.</p> <p>TP17 is an unknown signal, connected to test pin TP17 on the RF module pcb</p> <p>Category: Hardware</p>"},{"location":"Hardware/Console/SMC/","title":"SMC","text":"<p>The System Management Controller (SMC) is an 8051/8052 core inside the Southbridge. It manages the power sequencing, and is always active when the Xbox 360 has (standby or full) power applied. It controls the frontpanel, has a Realtime clock, decodes IR, manages temperatures, fans, DVDROM tray and a bunch of other things. It talks with the frontpanel board to set the LEDs. When the system is running, the kernel can communicate with the SMC, for example to query the realtime clock, open the dvd-tray etc.</p>"},{"location":"Hardware/Console/SMC/#the-fifo","title":"The FIFO","text":""},{"location":"Hardware/Console/SMC/#sending-a-message","title":"Sending a Message","text":"<p>Communication between kernel and SMC happens over a bidirectional FIFO (at ea001080 / ea001090). All messages and replies are 16 byte long and have the command id in the first byte.</p> <pre><code>void\u00a0smc_send(void\u00a0*msg)\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while\u00a0(!(readl(0xea001084)\u00a0&amp;\u00a04))\u00a0\u00a0\u00a0\u00a0//\u00a0wait\u00a0for\u00a0FIFO\u00a0ready\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cpu_relax();\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0writel(4,\u00a00xea001084);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0start\u00a0message\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0writesl(0xea001080,\u00a0msg,\u00a04);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0send\u00a016\u00a0bytes\n \u00a0\u00a0\u00a0\u00a0\u00a0writel(0,\u00a00xea001084);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0end\u00a0message\n}\n</code></pre>"},{"location":"Hardware/Console/SMC/#receiving-a-reply","title":"Receiving a Reply","text":"<p>Some messages have replies, which will be returned as 16 byte sequence similar to the message (they also have the command id in the first byte).</p> <pre><code>int\u00a0smc_read_reply(void\u00a0*msg)\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(!(readl(0xea001094)\u00a0&amp;\u00a04))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0do\u00a0we\u00a0have\u00a0a\u00a0reply?\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a00;\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0writel(4,\u00a00xea001094);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0start\u00a0reply\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0readsl(0xea001090,\u00a0msg,\u00a04);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0read\u00a016\u00a0bytes\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0writel(0,\u00a00xea001094);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//\u00a0end\u00a0reply\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a01;\n}\n</code></pre>"},{"location":"Hardware/Console/SMC/#command-messages","title":"Command Messages","text":"ID Len Example Purpose 0x82 2-3 \"\\x82\\0x04\\0x31\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set standby/power 0x85 ? ? set real time clock 0x88 ? ? set fan algorithm 0x89 ? ? set fan speed (cpu/gpu?) 0x8b ? \"\\x8b\\0x62\\0x00\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set dvd tray 0x8c 3 \"\\x8c\\0x01\\0x00\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set power led 0x8d 2 \"\\x8d\\0x01\\0x00\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set audio mute 0x94 ? ? set fan speed (cpu/gpu?) 0x95 ? ? set ir address 0x98 1 \"\\x98\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set dvd tray secure 0x99 3 \"\\x99\\0x01\\0x0f\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set ring of light 0x9a ? ? set rtc wake"},{"location":"Hardware/Console/SMC/#query-messages","title":"Query Messages","text":"ID Len Example Query Example Reply Purpose 0x01 1:6 \"\\x01\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" <code>01 12 00 00 00 00</code> power on type 0x04 1:11 \"\\x04\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" <code>04 602f 212223 01 00000000</code> real time clock 0x07 1:10 \"\\x07\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" <code>07ff 241b 2fa4 2cfa 262c</code> read temps 0x0a 1:2 \"\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" <code>0a 60</code> request tray state 0x0f 1:2 \"\\x0f\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" <code>0f 54</code> request AV pack type 0x11 6:2 \"\\x11\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" <code>11 02</code> read ana 0x12 1:6 \"\\x12\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" <code>1241 0203 0000</code> request SMC version 0x16 1:2 \"\\x16\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" <code>16 0f</code> query IR address 0x17 1:2 \"\\x17\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" <code>17 00</code> query tilt sensor"},{"location":"Hardware/Console/SMC/#event-messages","title":"Event Messages","text":"ID Len Example Message Purpose 0x83 2 <code>83 64</code> SMC event <p>Category: Hardware</p>"},{"location":"Hardware/Console/SMC_Command_0x01/","title":"SMC Command 0x01","text":""},{"location":"Hardware/Console/SMC_Command_0x01/#query-power-on-type","title":"Query Power On Type","text":"<p>The reply to the SMC command 0x01 will contain some information about the event which caused the X360 to power up.</p> Message: <code>01</code> Reply: <code>01 WW 00 XX YY ZZ</code> Data Source Meaning WW @63h Type of power up Event XX @3fh ?? YY.0 @2bh.1 ?? ZZ @3eh ?? # Event Type 0x11 power button 0x12 eject button 0x15 rtc wakeup 0x16 ??? 0x20 power IR 0x21 eject IR 0x22 xenon IR 0x24 MCE IR 0x30 power cycle 0x31 reset cycle 0x41 ??? 0x51 kiosk 0x55 argon (RF) 0x56 gameport 1 0x57 gameport 2 0x5a expansion resume"},{"location":"Hardware/Console/SMC_Command_0x82/","title":"SMC Command 0x82","text":""},{"location":"Hardware/Console/SMC_Command_0x82/#set-standbypower-offreboot","title":"Set Standby/Power Off/Reboot","text":"<p>This Command Message triggers various power management operations.</p> Message: <code>82 XX YY ZZ</code> XX YY ZZ Meaning 01 00 -- Power Off (@3dh=1, @64h=#5a) 01 32 -- Power Off (@3dh=0, Clears RTC?) 04 31 ?? Reboot (@3dh=1, @64h=#01, Soft Reset) 04 30 ?? Reboot (@3dh=0, @64h=#03, Power Cycle) 04 33 -- Clear (@3dh=0)"},{"location":"Hardware/Console/SPI/","title":"General","text":"<p>The SPI bus (Serial Peripheral Interface) on the Xbox 360 is mainly used for communicating with the NAND-Flash Controller (SFCX), an SPI Programmer is needed for this. The bus consists of the following signals:</p> Name Description MOSI Master out, Slave in SS Slave Select SCK Serial Clock MISO Master in, Slave out XEJ Eject XXX ?"},{"location":"Hardware/Console/SPI/#fat-motherboard","title":"FAT Motherboard","text":"<p>The Diagram matches following Xbox 360 Motherboard-revisions: Xenon, Zephyr, Falcon, Opus, Jasper. </p>"},{"location":"Hardware/Console/SPI/#slim-motherboard","title":"SLIM Motherboard","text":"<p>The Diagram can be used for Xbox 360 Motherboard-revision: Trinity </p>"},{"location":"Hardware/Console/Southbridge/","title":"Southbridge","text":"<p>Category: Hardware</p>"},{"location":"Hardware/Console/Stereo_DAC/","title":"Stereo DAC","text":"<p>The Xbox 360 uses a WOLFSON WM8517HCGED Stereo DAC With Integrated Output Stage for 1.7Vrms LINE OUT, which is pin compatible (and otherwise quite similar) to the WM8521 (which has 2Vrms).</p> <p>This is a DAC with built in output stage and derives its clock signal from the 360's master clock, the only one of the mother board.</p> <p>The output has small SMD Ceramic's presumably for DC blocking. The local decoupling on the Digital and Analogue supply pins and 'CAP' pin (reference) are also small Ceramic SMD's. Output traces are very very thin. Voltage regs are miles away and have other components deriving power from the same rail's, which also has really thin traces.</p> <p>Hardware</p>"},{"location":"Hardware/Console/USB/","title":"USB","text":"<p>\u2022The Xbox 360 comes with 3 standard USB 2.0 ports. (2 on the front and 1 on the back)</p> <p>The Xbox 360 added official support for using USB drives as a mean of storing Xbox 360 files on April 6, 2010. Files are stored to the flash drive by using files within a hidden folder (Root\\Xbox360\\) that are mounted with the FATX file system.</p>"},{"location":"Hardware/Console/USB/#confirmed-facts","title":"Confirmed Facts","text":"<p>Can be used to add hard disk and get around DRM.</p> <p>SEE: USB Hard Drive Mod</p>"},{"location":"Hardware/Console/USB/#speculation","title":"Speculation","text":"<ul> <li>iPod and standard USB flashdrives using the FAT(32)? Filesystem are     detected via the 360 media center.(Cannot read NTFS)</li> <li>The Xbox 360 seems to be able to read the HFS filesystem Mac     formatted iPods.</li> <li>It is unknown if the USB ports can access DMA but it is speculated     that the USB ports may be read-only. Such speculation is     questionable, as two-way communication is required to be able to     communicate with products. Instead, any read-only access control may     be implemented in the Dashboard, or write support may simply not     exist within the filesystem drivers. - This is most likely     impossible - There are no \"slave initiated DMA\" transactions as part     of the USB spec. Even if it does support USB OTG, and therefore can     act as a Slave, a driver [on the xbox] would still need to be     present for any usb endpoints to exist.</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Xenon_%28CPU%29/","title":"Xenon CPU","text":"<p>Xenon (not to be confused with Xenos) is the CPU that is used in the Xbox 360. The processor, internally codenamed Waternoose by IBM and XCPU by Microsoft. \"The basic design is a 64-bit PowerPC architecture, with the complete PowerPC ISA available.\" It is different from the Intel Pentium III in the original Xbox: the Xenon CPU is composed of three symmetrical cores on a single die, each core has two symmetric hardware threads (SMT), for a total of six hardware threads available to games. Each individual core also includes 32 KiB of L1 instruction cache and 32 KiB of L1 data cache.</p>"},{"location":"Hardware/Console/Xenon_%28CPU%29/#specifications","title":"Specifications","text":"<ul> <li>The package is a 2-2-2 FC-PBGA, measuring 31mm by 31mm</li> <li>168 mm2 die size; one cpu core is about 28mm2</li> <li>Support logic for Array and Logic Built in Selftest</li> <li>165 Million transistors</li> <li>Three symmetrical cores running at 3.2 GHz each = 9.6Ghz throughput.<ul> <li>32 KiB of L1 instruction cache and 32 KiB of L1 data cache per     core</li> <li>64 bit CPU cores based on the IBM 970 \"G5\" design</li> <li>Each core is two way SMT-capable and clocked at 3.2Ghz</li> <li>2\u00d7 (128\u00d7128 bit) register files for each core</li> <li>Two hardware threads per core; six hardware threads total</li> <li>VMX-128 vector unit per core; three total</li> <li>128 VMX-128 registers per hardware thread</li> </ul> </li> <li>1 MB L2 cache<ul> <li>(lockable by the GPU) running at half-speed (1.6 GHz) with a     256-bit bus</li> <li>51.2 gigabytes per second of L2 memory bandwidth (256 bit \u00d7 1600     MHz)</li> </ul> </li> <li>21.6 GB/s front side bus (aggregated 10.8 GB/s upstream and     downstream)</li> <li>115 GFLOPS theoretical peak performance</li> <li>CPU Integer Perf (VPR): 1089 (363 each)</li> <li>Dot product performance: 9.6 billion per second</li> <li>IBM eFuse technology</li> <li>IBM's PowerPC instruction set architecture</li> <li>Restricted to In-order code execution</li> <li>Big endian architecture</li> </ul>"},{"location":"Hardware/Console/Xenon_%28CPU%29/#linux-support","title":"Linux Support","text":"<ul> <li>We have full SMP support, so we can use all three cores.</li> <li>However, we currently need to disable the secondary threads because     of a yet-to-be analyzed stability issue.</li> <li>The CPU is quite slow on general purpose code. Due to the non     out-of-order execution core, it heavily relies on the compiler to do     proper optimizations. GCC currently doesn't know how to do this,     resulting in running but very inefficient code.</li> <li>The Cell people worked on PPU-GCC, from which the Xenon will benefit     as well, as the PPC cores is quite similiar to the Cell's PPU. All     PPU-GCC work have been merged on mainline GCC 4.4</li> </ul>"},{"location":"Hardware/Console/Xenon_%28CPU%29/#external-links","title":"External Links","text":"<ul> <li>Application-customized CPU design: The Microsoft Xbox 360 CPU story     Jeffrey Brown, Distinguished Engineer, IBM</li> <li>\"Power\" Architecture Technology at IBM</li> <li>SoC drawer: The resource view at IBM     (mentions Xbox CPU design. Gets nitty gritty on resources and     scheduling, i/o interconnects, &amp; on chip memory)</li> <li>Just like being there: Papers from the Fall Processor Forum 2005:    Application-customized CPU design    at IBM (Explore the customized IBM PowerPC processor designed for    the Microsoft XBox 360)</li> <li>Xenon hardware overview by Pete Isensee, Development Lead, Xbox Advanced Technology Group,     written some time before 23 June 2004</li> <li>Ars Technica explains the Xenon CPU</li> <li>Xbox360 CPU at     Wikipedia</li> <li>PowerPC 970 at Wikipedia</li> <li>PowerPC at Wikipedia</li> <li>POWER4 at Wikipedia</li> <li>CPU Chip for Xbox 360 Manufacturing Overview, FSB, PPC Core, VMX &amp; FPU, &amp; L2 Cache block diagrams from IBM</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Xenon_%28Motherboard%29/","title":"Xenon (Motherboard)","text":"<p>The original Xbox 360 configuration used in the initial Premium and Core machines released in the end of November 2005. These are also know as the RRoD (Red Ring of Death) machines because the GPU chip warps away from the motherboard because of excessive heat.</p> <ul> <li>90 nm IBM CPU</li> <li>90 nm ATI GPU and 90nm on-chip eDRAM</li> <li>Low profile GPU cooler</li> <li>Standard CPU cooler</li> <li>203 Watt output power supply (16.5 A)</li> <li>Shipping with Hitachi and Samsung DVD-Drive</li> <li>Highly unlikely to have glue around the CPU but it IS possible.</li> </ul> <p></p> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Xenos_%28GPU%29/","title":"Xenos GPU","text":"<p>Xenos (not to be confused with Xenon) is a custom graphics processing unit (GPU) designed by ATI, used in the Xbox 360. Developed under the codename \"C1,\" it is in many ways related to the R500 desktop PC graphics card series and therefore very similar to an ATI Radeon X1900 as far as features and performance are concerned. However, the Xenos introduced many new design ideas that were later adopted in the R600 series. The package contains two separate silicon dies, the GPU and an eDRAM, featuring a total of 337 million transistors. For infos about Xenos Framebuffer/Xenosfb click HERE and for infos about modesetting HERE</p>"},{"location":"Hardware/Console/Xenos_%28GPU%29/#specifications","title":"Specifications","text":"<ul> <li>325 Million transistors (235m Parent Die / 90m Daughter Die) (Other     specs say 337 million total)</li> <li>GPU &amp; Northbridge (Northbridge on Parent Die)</li> <li>Two-die design, with two chips in a single package on a single     substrate<ul> <li>Parent die contains the GPU and memory controller</li> <li>Daughter die consists of the 10MB of eDRAM &amp; additional logic     (FSAA, Alpha, ZLogic &amp; Stencil)</li> <li>2GHz link between the parent and daughter die</li> </ul> </li> <li>500MHz processor</li> <li>10 MB of embedded DRAM (By NEC)</li> <li>48-way parallel floating-point dynamically scheduled shader     pipelines<ul> <li>4 ALU's per pipe for Vertex or Pixel Shader processing</li> </ul> </li> <li>Unified shader architecture (Beyond Shader Model 3.0)</li> <li>Three SIMD engines with 16 processors per unit (The 48 shader     pipeline)</li> <li>16 Filtered &amp; 16 unfiltered texture samples per clock</li> <li>HDR Rendering</li> <li>DirectX 9</li> <li>Limited support for DirectX 10</li> <li>Handles all scaling of video (resolution).</li> </ul>"},{"location":"Hardware/Console/Xenos_%28GPU%29/#linux-support","title":"Linux Support","text":"<p>Currently, we have support for the framebuffer console. We also have an unaccelerated X driver. We don't yet have support for acceleration, neither 2D nor 3D, but there is on going work. 1 Rudimentary video mode setup code exists in XeLL and the Linux framebuffer driver. There are though problems with interlaced modes.</p>"},{"location":"Hardware/Console/Xenos_%28GPU%29/#framebuffer-code","title":"Framebuffer Code","text":"<p>Unfortunately, the framebuffer memory is not linear (i.e. pixels are not stored one after another, line after line). The memory is organized in tiles of 32x32 pixels, where in each tile blocks of 4x1 pixels are scattered around. Every pixel is stored as a 32 bit RGBx tuple.</p> <p>The tiling breaks most framebuffer applications which require linear access, causing heavily distorted pictures. This could maybe be fixed by writing custom blit routines in xenos_fb. Are there any apps using the framebuffer blit functions, or is everybody mmap()ing? -- Ge0rG 15:03, 21 Jan 2008 (PST)</p>"},{"location":"Hardware/Console/Xenos_%28GPU%29/#external-links","title":"External Links","text":"<ul> <li>ATI Xenos: Xbox 360 Graphics     Demystified at     Beyond3D</li> <li>AMD R6xx R7xx 3D at     Xorg.com</li> <li>R700 Instruction Set     Arch     at developer.amd.com</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/NAND/","title":"NAND","text":""},{"location":"Hardware/Console/NAND/#flash-memory","title":"Flash memory","text":"<ul> <li> <p>Datasheet</p> </li> <li> <p>SMT socket that should work if you choose to remove yours:   https://web.archive.org/web/20111206034431/http://www.emulation.com:80/cgi-cfm/insert_quantity.cfm?part_number=S%2DTSO%2DSM%2D048%2DA</p> </li> </ul> <p>Attached to Southbridge</p>"},{"location":"Hardware/Console/NAND/#nand-points-on-motherboard-for-fat","title":"NAND Points on Motherboard for FAT","text":""},{"location":"Hardware/Console/NAND/#nand-points-on-motherboard-for-slim","title":"NAND Points on Motherboard for SLIM","text":"<p>coming soon...</p>"},{"location":"Hardware/Console/NAND/#different-sizes","title":"Different Sizes","text":"<p>On different Motherboard Revision also different NANDs were used. Xenon-, Zephyr-, Falcon-, Opus- and some Jasper-Consoles (Retails) are using 16MB NANDs, other Jasper-Consoles (Retail),Arcade Bundles which came without a HDD, got a 256MB or 512MB NAND onboard. Only 64MB of these 256/512MB NAND are used for system files, the rest is used as an internal Memory Unit. All Development-/Demo-/Reviewer-/Test-Kits got at least a 64MB NAND. Depending on the NAND Size either Small- or Large-Block Flash Controllers get used.</p>"},{"location":"Hardware/Console/NAND/#flash-controllers","title":"Flash Controllers","text":"<p>The Flash Controller decides how to handle the NAND Memory. There are currently two types, the Old/Original SFC which handles the NAND with small block and the new SFC (Codename: Panda?) which handles the NAND as either small or large blocks.</p> <p>Original SFC (pre-Jasper)</p> <ul> <li>16MB NAND</li> </ul> Type Size Block Size 0x4000 (16KB) Block Count 0x400 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0x3E0 <ul> <li>64MB NAND</li> </ul> Type Size Block Size 0x4000 (16KB) Block Count 0x1000 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0xF80 <p>New SFC</p> <ul> <li>Small Block: 16MB NAND</li> </ul> Type Size Block Size 0x4000 (16KB) Block Count 0x400 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0x3E0 <ul> <li>Large Block: 256/512MB NAND</li> </ul> Type Size Block Size 0x20000 (128KB) Block Count (non-MU) 0x1000 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0x1E0"},{"location":"Hardware/Console/NAND/#simple-calculations","title":"Simple Calculations","text":"<p>Have an address which is without ECC?</p> <p><code>realaddr = (addr / 512) * 528 + (realaddr % (mod) 512 &gt; 0 ? realaddr % (mod) 512 : 0);</code></p> <p>This also works in reverse:</p> <p><code>addr = (realaddr / 528) * 512 + (realaddr % (mod) 528 &gt; 0 ? realaddr % (mod) 528 : 0);</code></p>"},{"location":"Hardware/Console/NAND/#readingwriting","title":"Reading/Writing","text":"<p>The Flash can be written or read using a number of methods. If you have the old shader hack running the easiest is using lflash.</p> <p>You can also wire LPT directly to the flash using this diagram. As well, you can build your own USB SPI Flasher with this diagram and use these binaries. Flash the PicXboot.hex to your PIC, then use the programmer from this picflash to flash the picflash.hex to the PIC through USB in bootloader mode. Once the device is flashed,</p> <p>Once wired you can read/write to the chip using software such as NandPro.</p> <p>In software the NAND is mapped to memory address 0x80000200C8000000.</p> <ul> <li>You must be in real-mode to access the space</li> <li>You can read it byte by byte but it is recommended to follow the     standard and read it in 4 byte blocks</li> </ul>"},{"location":"Hardware/Console/NAND/#sectors","title":"Sectors","text":"<ul> <li>1: copyright notice, zeros, unencrypted numbers</li> <li>2: encrypted data</li> </ul> <p>@2MB filesystem, unencrypted, but content encrypted, config not</p>"},{"location":"Hardware/Console/NAND/#nand-file-system","title":"NAND File System","text":"<p>Informations about the Filesystem on the Xbox 360 NAND Flash can be found here</p>"},{"location":"Hardware/Console/NAND/#bad-blocks","title":"Bad Blocks","text":"<p>Its possible that bad blocks appears when reading/writing to the NAND. For solving these look at the following page: Bad Blocks</p>"},{"location":"Hardware/Console/NAND/#small-flash-chip-close-to-cpu","title":"Small flash chip close to CPU","text":"<p>Some 360s have a small flash chip near the CPU, some don't as seen in the following pictures.</p> <p>No chip:</p> <p></p> <p>Here is a high-res picture of a premium box with the chip:</p> <p></p> <p>As discussed in this article on the xboxhacker.net forums, this appears to be a Atmel 25020 EEPROM. The chip model reads:</p> <pre><code>ATMEL524\n25020AN\nSU18\n</code></pre> <p>Datasheet can be found here.</p> <p>This chip is a low power 2048 bit serial EEPROM according to the datasheet.</p> <ul> <li> <p>If the small chip near the CPU is removed the Xbox will boot up and   function just fine [Darkmoon 360 experiments]</p> </li> <li> <p>According to IBM the CPU has \"An interface for a serial EEPROM in   case patch logic configuration was needed during bring-up\"</p> </li> </ul>"},{"location":"Hardware/Console/NAND/#small-flash-chip-on-front-panel","title":"Small flash chip on front panel","text":"<p>There is another Atmel chip on the front panel:</p> <p> </p> <p>Atmel 528 serial EEPROM</p> <p>This chip reads:</p> <pre><code>ATMEL528\n24C04N\nSU18\n</code></pre> <p>Datasheet can be found here</p> <p>This chip is a low power 4096 bit serial EEPROM according to the datasheet.</p>"},{"location":"Hardware/Console/NAND/#tools","title":"Tools","text":"<ul> <li>360 Flash Tool, which is not easy to find</li> <li>Xbox 360 NAND Editor by stoker25,   open source and semi-complete, has code to do with bootloaders/keyvault/filesystem</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Revisions/","title":"Index","text":"<p>The XBox 360 motherboard has gone through several changes over the years. These changes often reduced die sizes of various chips (CPU (Xenon), GPU (Xenos), eDRAM, etc.), added new features (HDMI, etc.) and patched the SMC/JTAG exploit. This pages lists off all known motherboard revisions, their changes as well as links to their respective pages.</p>"},{"location":"Hardware/Console/Revisions/#xenon-v1","title":"Xenon (V1)","text":"<p>The original Xbox 360 configuration used in the initial Premium and Core machines released in the end of November 2005. These are also known as the RRoD (Red Ring of Death) machines because the GPU chip warps away from the motherboard because of excessive heat.</p> <ul> <li>Consoles : Core, Pro/Premium 20GB</li> <li>90nm IBM CPU</li> <li>90nm ATI GPU and 90nm on-chip     eDRAM</li> <li>Low profile GPU cooler</li> <li>Standard CPU cooler</li> <li>203 Watt output power supply (16.5 A)</li> <li>Shipping with Hitachi46-78, Samsung ms25or ms28, BenQ DVD-Drive. Can     also come with Lite-On drive if it was refurbished.</li> <li>Highly unlikely to have glue around the CPU but it IS possible.</li> </ul>"},{"location":"Hardware/Console/Revisions/#zephyr-v2","title":"Zephyr (V2)","text":"<p>Zephyr was the first revision with HDMI connector. It was introduced with the Xbox 360 Elite in May 2007. In July 2007 Xbox 360 Premium machines began appearing with the Zephyr motherboard.</p> <ul> <li>Consoles: Arcade, Pro/Premium 20GB, Elite 120GB and Halo 3 Console</li> <li>90nm IBM CPU &amp; ATI GPU</li> <li>90nm eDRAM</li> <li>203 Watt PSU (16.5 A)</li> <li>HDMI video output</li> <li>Updated motherboard layout</li> <li>Glue around the CPU in some cases</li> <li>3 pin fan connector</li> <li>New Extended GPU heat sink with a heat pipe</li> <li>New Elite model includes 120GB hard drive</li> <li>Shipping with Hitachi 78 or 79 and BenQ DVD-Drive. May also have     Lite-On if it was refurbished.</li> </ul>"},{"location":"Hardware/Console/Revisions/#falcon-v3","title":"Falcon (V3)","text":"<p>All Xbox 360 Premium machines and Arcade machines made in August 2007 introduced the new 65 nm CPU accompanied with a new cooler and still 90 nm GPU with the Zephyr cooler. The motherboard is based on Zephyr and requires fewer components (some capacitors and coils removed) for the new 65 nm CPU, resulting in lower costs.</p> <ul> <li>Consoles: Arcade, Pro/Premium 20GB &amp; 60GB, Elite 120GB</li> <li>65nm IBM CPU</li> <li>90nm ATI GPU</li> <li>80nm on-chip eDRAM.</li> <li>HDMI Video Output</li> <li>175 Watt PSU (2V rated for 14.2A, new connector)</li> <li>New CPU Heat sink + the GPU heat sink with heat pipe</li> <li>Fewer voltage regulators, capacitors and inductors</li> <li>Bigger and enhanced CPU cooler</li> <li>RAM removed from bottom of mainboard on later models</li> <li>3 pin fan connector</li> <li>Shipping with Hitachi 79, BenQ and new Lite-On 7XXX series DVD-Drive</li> </ul>"},{"location":"Hardware/Console/Revisions/#opus-v31","title":"Opus (V3.1)","text":"<p>This is an intermediate motherboard with 65nm CPU and 90nm GPU, new coolers, but no HDMI. It will be used in Xenon chassis for repairs and RRoD affected machines. Started to appear end of July 2008 in machines coming back from repair. It's just a Falcon without a custom A/V (HDMI) port so that it fits into a Xenon chassis and case.</p> <ul> <li>Consoles: Core, Pro/Premium 20GB</li> <li>Falcon based board</li> <li>65nm IBM CPU</li> <li>90nm ATI GPU with 80nm on-chip     eDRAM</li> <li>No HDMI Video Output</li> <li>175 Watt PSU (2V rated for 14.2A, new connector)</li> <li>Updated Heat sinks<ul> <li>Falcon CPU cooler</li> <li>Zephyr GPU cooler</li> </ul> </li> <li>3 pin fan connector</li> <li>Shipping with Hitachi, Samsung, BenQ and Lite-On 7XXX DVD-Drive</li> <li>Opus only available from Xenon being repaired by MS.</li> <li>Very Rare</li> </ul>"},{"location":"Hardware/Console/Revisions/#jasper-v4","title":"Jasper (V4)","text":"<p>Jasper introduced the 65nm GPU to reduce power usage and cost further. The new power supply is rated for 150 Watt, down from 175 Watt on the Falcon. The Amperage on the 12V rail is down to 12.1A (12.1A x 12V = 145.2W).</p> <p>The on-board flash has also increased to allow the new NXE (New Xbox Experience) dashboard update to reside internally, instead of requiring a memory unit or the hard drive.</p> <ul> <li>Consoles: Arcade 256MB &amp; 512MB, Pro/Premium 60GB, Elite 120GB &amp;     250GB and Resident Evil 5 console</li> <li>65nm IBM CPU</li> <li>65nm ATI GPU with 80nm on-chip     eDRAM</li> <li>150 Watt PSU (12V rated for 12.1A, new connector)</li> <li>Arcade Edition Larger Flash 256MB or 512MB Hynix HY27UF082G2B     on-board flash, up from 16MB HY27US08281A flash, to accommodate the     NXE update.</li> <li>New Southbridge chipset</li> <li>Ram removed from bottom of mainboard</li> <li>New style CPU Heat sink + the GPU heat sink with heat pipe</li> <li>3 pin fan connector.</li> <li>New Warranty Sticker.</li> <li>Shipping with LiteOn 7XXX/8XXX/V2/9XXX DVD-Drivers.</li> <li>Least likely to red ring of death (RRoD) due to the less heat being     outputted by the chips</li> </ul>"},{"location":"Hardware/Console/Revisions/#jasper-v41","title":"Jasper (V4.1)","text":"<p>Same as Jasper (V4), minor changes.</p> <ul> <li>Consoles: Arcade 512MB, Elite 120GB &amp; 250GB, Modern Warfare 2     consoles and Final Fantasy 13 consoles</li> <li>65nm eDRAM (?)</li> <li>New Southbridge chipset</li> <li>Arcade Edition Larger Flash 256MB and 512MB to accommodate NXE     (Removes 256MB Memory Card)</li> <li>Shipping with Lite-On 8XXXV2/9XXX DVD-Drivers.</li> <li>JTAG Hack / SMC patched on CB level</li> <li>Xenon style GPU heat sink with Falcon style CPU heat sink</li> <li>Special edition consoles: Modern Warfare 2 Consoles</li> <li>Last of the original style 360 systems</li> </ul>"},{"location":"Hardware/Console/Revisions/#trinityvalhalla-v5-new-slim-xbox-360","title":"Trinity/Valhalla (V5) [New Slim Xbox 360]","text":"<ul> <li>Consoles: 4GB Arcade, Elite 250GB and Halo Reach Console</li> <li>Unified single chip with CPU, GPU and     eDRAM at 45nm process.</li> <li>16MB NAND</li> <li>135 Watt PSU</li> <li>802.11n Wi-Fi integrated</li> <li>No more Memory Unit ports</li> <li>Separate Kinect port</li> <li>Different HDD port</li> <li>Smaller form factor</li> <li>4GB internal Memory on small Daughter board</li> <li>No more RROD, simple red power light on error (unknown on more     detail)</li> </ul>"},{"location":"Hardware/Console/Revisions/#corona","title":"Corona (?)","text":"<p>Referenced in 20353 xbdm.dll, nothing known right now, possibly the newer cheaper XDKs?</p> <p>Information on this board so far:</p> <ul> <li>Many say that it is a Trinity Revision (Trinity v2)</li> <li>Console: Forza 4 250 GB (This board was found in a Forza 4 bundle)</li> <li>Manufacture Date: 8-17-2011</li> <li>No HANA Chip, it's integrated into the Southbridge</li> <li>115 W PSU</li> <li>CPU: 45 nm Combined Chip (Basicaly the CPU and GPU are combined)</li> <li>HDMI Enabled</li> </ul> <p>The interesting thing is that it seems that Microsoft knew about the Reset Glitch Hack, so they removed the HANA Chip. So it seems Microsoft found the exploit days before GliGli brought it out for the public.</p> <p>Corona Sources: Source 1 Source 2</p> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Revisions/Falcon/","title":"Falcon (Motherboard revision)","text":"<p>Falcon is the codename used for the third revision to the Xbox 360's motherboard. Appearing in September 2007, this revision reduced the CPU die size from 90nm to 65nm, and the GPU's eDRAM die size from 90nm to 80nm.</p> <ul> <li>Consoles: Arcade, Pro/Premium 20GB &amp; 60GB, Elite 120GB</li> <li>65nm IBM CPU</li> <li>90nm ATI GPU</li> <li>80nm on-chip eDRAM.</li> <li>HDMI Video Output</li> <li>175 Watt PSU (2V rated for 14.2A, new connector)</li> <li>New CPU Heat sink + the GPU heat sink with heat pipe</li> <li>Fewer voltage regulators, capacitors and inductors</li> <li>Bigger and enhanced CPU cooler</li> <li>RAM removed from bottom of mainboard on later models</li> <li>3 pin fan connector</li> <li>Shipping with Hitachi 79, BenQ and new Lite-On 7XXX series DVD-Drive</li> </ul>"},{"location":"Hardware/Console/Revisions/Falcon/#opus","title":"Opus","text":"<p>Opus motherboards started to appear in July 2008, to people who had sent in their RRoD Xenon consoles. The Opus motherboard is essentially a Falcon motherboard, without the HDMI connector, so that they could fit into the original Xenon cases they were shipped in.</p> <ul> <li>Consoles: Core, Pro/Premium 20GB</li> <li>Falcon based board</li> <li>65nm IBM CPU</li> <li>90nm ATI GPU with 80nm on-chip eDRAM</li> <li>No HDMI Video Output</li> <li>175 Watt PSU (2V rated for 14.2A, new connector)</li> <li>Updated Heat sinks<ul> <li>Falcon CPU cooler</li> <li>Zephyr GPU cooler</li> </ul> </li> <li>3 pin fan connector</li> <li>Shipping with Hitachi, Samsung, BenQ and Lite-On 7XXX series     DVD-Drive</li> <li>Opus only available from Xenon being repaired by MS</li> <li>Very Rare</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Revisions/Identification/","title":"With opening the console","text":"<p>When you open your Xbox Console you can determine the Revision precisely. First you have to locate the used Video Encoder Chip!</p>"},{"location":"Hardware/Console/Revisions/Identification/#determine-video-chip","title":"Determine Video-Chip","text":"<p>The VideoChip is located in the marked area: </p> <p>Find out which chip your xbox has!</p> <p>CONEXTANT </p> <p>FOCUS </p> <p>XCALIBUR </p>"},{"location":"Hardware/Console/Revisions/Identification/#i-got-a-conextant-chip","title":"I got a CONEXTANT chip","text":""},{"location":"Hardware/Console/Revisions/Identification/#i-got-a-focus-chip","title":"I got a FOCUS chip","text":""},{"location":"Hardware/Console/Revisions/Identification/#i-got-a-xcalibur-chip","title":"I got a XCALIBUR chip","text":""},{"location":"Hardware/Console/Revisions/Identification/#without-opening-the-console","title":"Without opening the console","text":"<p>Just by looking at the serial number, which is visible through the Xbox carton, you have a very good chance to find out the version of an Xbox. You can also get the serial number in Linux with the xbox_tool command.</p> <p>Please note that these rules may not apply to refurbished models.</p>"},{"location":"Hardware/Console/Revisions/Identification/#step-1-manufacturing-date-and-serial-number","title":"Step 1: Manufacturing Date and Serial Number","text":"<p>On the bottom of the Xbox, you can see the manufacturing date and the serial number. The manufacturing date is in the following format:</p> <p>2004-11-20</p> <p>i.e. YYYY-MM-DD</p> <p>(Year-Month-Day) which is the date according to ISO 8601.</p> <p>The serial number looks like this:</p> <p>3137905 44705</p> <p>i.e. LNNNNNN YWWFF</p> <p>L the number of the production line within the factory,</p> <p>NNNNNN the number of the Xbox within this week,</p> <p>Y the last digit of the production year,</p> <p>WW the number of the week of the production year,</p> <p>FF is the code of the factory (02: Mexico, 03: Hungary, 05: China. 06: Taiwan).</p>"},{"location":"Hardware/Console/Revisions/Identification/#step-2-the-factory","title":"Step 2: The Factory","text":"<p>Look at the factory code, i.e. the last two digits of the serial number.</p> <p>If the factory code is \"03\" (Hungary), you are done: You can be sure that it is a 1.0 Xbox. You can even be sure that it contains a Thomson DVD drive</p> <p>If the factory code is \"02\" (Mexico), it is either a 1.0 or a 1.1 Xbox. Look at the manufacturing date: If it is November 2002 or later, you have a 1.1 Xbox, else it's a 1.0.</p> <p>If the factory code is \"05\" (China), you have at least a 1.1 Xbox.</p> <p>If the factory code is \"06\" (Taiwan), you have at least a 1.3 Xbox.</p>"},{"location":"Hardware/Console/Revisions/Identification/#step-3-version-table","title":"Step 3: Version Table","text":"<p>If you have a \"Halo Special Edition\" Xbox (translucent green), you have version 1.2, which has been made in weeks 8 and 9 of 2003 on lines 2, 5 and 6.</p> <p>If you have a \"Crystal Special Edition\" Xbox (translucent white), you either have a version 1.5 or 1.6 which were made in weeks 32 to 34 of 2004.(Which is not on the list below)</p> <p>Find out the production line of the Xbox, which is the first digit of the serial number. Then find out the year and week of your Xbox. The first digit of the second block is the last digit of the year (i.e. 2 or 3 for 2002 or 2003), and the following two digits are the number of the week. For example, the serial \"1111111 31205\" is from week 12/2003.</p> <p>Now look up the box corresponding to the week and the production line in the following table. The legend below the table will tell you the meaning of the colors. Note:Anything After 18\\04 Is mainly Unknown and is most likly to be a version 1.6 or 1.6b.</p> Week Line 1 Line 2 Line 3 Line 4 Line 5 Line 6   23/02     \u00a0?     \u00a0?     12 Jun     \u00a0?     \u00a0?     \u00a0?     34/02     \u00a0?     \u00a0?     24 Aug     \u00a0?     \u00a0?     \u00a0?     39/02     \u00a0?     \u00a0?     \u00a0?     \u00a0?     29 sept     \u00a0?     42/02     18 Oct     43/02     \u00a0?     44/02     \u00a0?     45/02     13 Nov     46/02     \u00a0?     47/02     20 Nov     \u00a0?     48/02     \u00a0?     \u00a0?     49/02     03 Dec     03 Dec     50/02     13 Dec     51/02     19 Dec     \u00a0?     52/02     \u00a0?     \u00a0?     01/03     \u00a0?     \u00a0?     02/03     10 Jan     \u00a0?     03/03     \u00a0?     \u00a0?     04/03     24 Jan     \u00a0?     22 Jan     20 Jan     05/03     \u00a0?     \u00a0?     \u00a0?     06/03     \u00a0?     \u00a0?     \u00a0?     07/03     \u00a0?     \u00a0?     \u00a0?     08/03     \u00a0?     21 Feb     \u00a0?     19 Feb     09/03     \u00a0?     \u00a0?     27 Feb     \u00a0?     \\-     10/03     \u00a0?     03 Mar     \u00a0?     \u00a0?     \\-     11/03     \u00a0?     10 Mar     \u00a0?     11 Mar     \\-     12/03     \u00a0?     \u00a0?     \u00a0?     \\-     13/03     \u00a0?     \u00a0?     \u00a0?     \\-     14/03     \u00a0?     02 Apr     03 Apr     \\-     15/03     09 Apr     \\-     16/03     \\-     17/03     \\-     18/03     \\-     19/03     04 May     20/03     05 May     21/03     22/03     23/03     02 Jun     24/03     25/03     26/03     27/03     28/03     29/03     \u00a0?-?-?     17 Jul     30/03     23 Jul     \u00a0?-?-?     23 Jul     24 Jul     23 Jul     23 Jul     31/03     28 Jul     32/03     11/04     2 Mar     11/04     11 Mar     \u00a0?     12/04     \u00a0?     \u00a0?     18 Mar     22 Mar     13/04     28 Mar     \u00a0?     \u00a0?     14/04     \u00a0?     1 Apr     15/04     \u00a0?     5 Apr     10 Apr     16/04     \u00a0?     \u00a0?     \u00a0?     17/04     \u00a0?     \u00a0?     \u00a0?     18/04     \u00a0?     \u00a0?     \u00a0?     31/04     \u00a0?     \u00a0?     \u00a0?     \u00a0?     \u00a0?     33/04     \u00a0?     \u00a0?     \u00a0?     \u00a0?     46/04     \u00a0?     \u00a0?     \u00a0?     11 Nov     \u00a0?     \u00a0?     47/04     \u00a0?     16 Nov     \u00a0?     \u00a0?     \u00a0?     \u00a0?     21/05     16 May   <p>Legend:</p>   1.0     1.1     1.2     1.3     1.4     1.6     unknown   <p>Retrieved from http://www.xbox-linux.org/wiki/Xbox_Versions_HOWTO</p>"},{"location":"Hardware/Console/Revisions/Jasper/","title":"Jasper","text":"<p>Jasper is the codename of the fifth motherboard revision for the Xbox 360. On Jasper motherboards found within Arcade SKUs, this Xbox 360 Motherboard revision features an onboard memory unit to facilitate the NXE Dashboard.</p> <p>The connections required to dump/flash the NAND are the same as all previous models.</p> <p>Performing the SMC Hack requires the same wiring as Zephyr, Opus, and Falcon mainboards. This is a slightly different set of connections than those required for the Xenon mainboard.</p>"},{"location":"Hardware/Console/Revisions/Jasper/#jasper-v40","title":"Jasper (V4.0)","text":"<ul> <li>Consoles: Arcade 256MB &amp; 512MB, Pro/Premium 60GB, Elite 120GB &amp;     250GB and Resident Evil 5 console</li> <li>65nm IBM CPU</li> <li>65nm ATI GPU with 80nm on-chip eDRAM</li> <li>150 Watt PSU (12V rated for 12.1A, new connector)</li> <li>Arcade Edition Larger Flash 256MB or 512MB Hynix HY27UF082G2B     on-board flash, up from 16MB HY27US08281A flash, to accommodate the     NXE update.</li> <li>New Southbridge chipset</li> <li>Ram removed from bottom of mainboard</li> <li>New style CPU Heat sink + the GPU heat sink with heat pipe</li> <li>3 pin fan connector.</li> <li>New Warranty Sticker.</li> <li>Shipping with LiteOn 7XXX/8XXX/V2/9XXX DVD-Drivers.</li> <li>Least likely to red ring of death (RRoD) due to the less heat being     outputted by the chips</li> </ul>"},{"location":"Hardware/Console/Revisions/Jasper/#jasper-v41","title":"Jasper (V4.1)","text":"<p>Same as Jasper (V4) other than some minor changes.</p> <ul> <li>Consoles: Arcade 512MB, Elite 120GB &amp; 250GB, Modern Warfare 2     consoles and Final Fantasy 13 consoles</li> <li>65nm eDRAM (?)</li> <li>New Southbridge chipset</li> <li>Arcade Edition Larger Flash 256MB and 512MB to accommodate NXE     (Removes 256MB Memory Card)</li> <li>Shipping with Lite-On 8XXXV2/9XXX DVD-Drivers.</li> <li>JTAG Hack / SMC patched on CB level</li> <li>Xenon style GPU heat sink with Falcon style CPU heat sink</li> <li>Special edition consoles: Modern Warfare 2 Consoles</li> <li>Last of the original style 360 systems</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Revisions/Trinity/","title":"Trinity / Valhalla","text":"<p>Trinity is the codename of the motherboard used in the Xbox 360 Slim. It is the sixth motherboard revision. It was originally believed that it's codename was Valhalla, but after looking through debug files it was found that this is not the case. It no longer has Memory Unit ports. It has a special port for connecting the Kinect peripheral, which provides power to the device instead of plugging it in separately. It also features a single chip that contains the CPU, GPU and eDRAM, with a 45nm die size. The Xbox 360 Slim, and as a result, the motherboard are much smaller than the original. It also contains an internal USB port which has a 802.11n WiFi card inserted. The HDD port was also changed, making it much smaller and flush against the case. The RRoD is also non-existant, replaced with a single red power light on any errors.</p> <ul> <li>Consoles: 4GB Arcade, Elite 250GB and Halo Reach Console</li> <li>Unified single chip with CPU, GP and eDRAM at 45nm process.</li> <li>16MB NAND</li> <li>135 Watt PSU</li> <li>802.11n Wi-Fi integrated</li> <li>No more Memory Unit ports</li> <li>Separate Kinect port</li> <li>Different HDD port</li> <li>Smaller form factor</li> <li>4GB internal Memory on small Daughter board</li> <li>No more RROD, simple red power light on error (unknown on more     detail)</li> </ul> <p>Category: Hardware</p>"},{"location":"Hardware/Console/Revisions/Zephyr/","title":"Zephyr","text":"<p>Zephyr was the second revision of the Xbox 360 motherboard and case and was originally exclusively available only with Elite consoles. Zephyr was the first Xbox 360 motherboard revision to have HDMI.</p> <p>Performing the SMC Hack requires a slightly different set of connections to Xenon motherboards.</p> <ul> <li>Consoles: Arcade, Pro/Premium 20GB, Elite 120GB, and Halo 3 Console</li> <li>90nm IBM CPU &amp; ATI GPU</li> <li>90nm eDRAM</li> <li>203 Watt PSU (16.5 A)</li> <li>HDMI video output</li> <li>Updated motherboard layout</li> <li>Glue around the CPU in some cases</li> <li>3 pin fan connector</li> <li>New Extended GPU heat sink with a heat pipe</li> <li>New Elite model includes 120GB hard drive</li> <li>Shipping with Hitachi 78 or 79 and BenQ DVD-Drive. May also have     Lite-On drive if it was refurbished.</li> </ul> <p>Category: Hardware</p>"},{"location":"Homebrew/","title":"Homebrew Software","text":"<p>360FlashTool</p> <p>Genesis Plus</p> <p>Lflash</p> <p>LibHomebrew</p> <p>LibXenon</p> <p>LibXenon Examples</p> <p>List of homebrew applications</p> <p>List of homebrew emulators</p> <p>List of homebrew games</p> <p>List of homebrew_loaders</p> <p>List of PC utilities</p> <p>List of system tools</p> <p>Mupen64-360</p> <p>NandCompare</p> <p>NANDPro</p> <p>PCSXR Xenon</p> <p>PC Software</p> <p>Pong</p> <p>Rawflash</p> <p>Run Code</p> <p>SDLQuake</p> <p>Sega Genesis_Plus_GX</p> <p>Sega Master_System_Plus</p> <p>Snes9x-Gx</p> <p>Starting Homebrew Development</p> <p>Tanks 360</p> <p>UART</p> <p>Utilities</p> <p>XeLL</p> <p>XeLL Reloaded</p> <p>XMENU</p> <p>XMPlayer</p> <p>ZLX Browser</p>"},{"location":"Homebrew/List_of_homebrew_applications/","title":"List of homebrew applications","text":""},{"location":"Homebrew/List_of_homebrew_applications/#applications","title":"Applications","text":"Title Description Author XMENU A .elf launcher with customizable backgrounds. Created legally using LibXenon cpasjuste ZLX_Browser A nice-looking filemanager based on the ZLX_Library ced2911 XMPlayer A media player ported to the xbox 360 using LibXenon. ced2911 <p>Category: Homebrew Software</p>"},{"location":"Homebrew/List_of_homebrew_emulators/","title":"List of homebrew emulators","text":""},{"location":"Homebrew/List_of_homebrew_emulators/#emulators","title":"Emulators","text":"Title Description Mupen64-360 Mupen64-360 is a Nintendo64 emulator, it's a port of Wii64 (which itself was a port of Mupen64). PCSXR-Xenon Pcsxr-xenon is a Sony playstation 1 emulator, based on lastest PCSX-Reloaded source code Sega_Genesis_Plus_GX Sega Genesis Plus GX is a freeware, open-source, portable emulator for the Genesis and MegaDrive consoles. Sega_Master_System_Plus Sega Master Plus is a freeware, open-source, portable emulator for the Sega Master System and Game Gear consoles. Snes9x-Gx The first SNES emulator to run natively on the xbox 360 created using LibXenon <p>Category: Homebrew Software</p>"},{"location":"Homebrew/List_of_homebrew_games/","title":"List of homebrew games","text":""},{"location":"Homebrew/List_of_homebrew_games/#games","title":"Games","text":"Title Description Pong The game of the year : PONG Tanks_360 A game with shooting tanks SDLQuake The famous FPS Quake, built via SDL <p>Category: Homebrew Software</p>"},{"location":"Homebrew/List_of_homebrew_loaders/","title":"List of homebrew loaders","text":""},{"location":"Homebrew/List_of_homebrew_loaders/#homebrew-loaders","title":"Homebrew Loaders","text":"Title Description XeLL The original Xenon Linux Loader. Doesn't work on Reset_Glitch_Hack XeLLous Xenon Linux Loader modification by Redline99. Doesn't work on Reset_Glitch_Hack XeLL_Reloaded Xenon Linux Loader RELOADED. Consists of 2 stages, works on both, JTAG and RGH <p>Category: Homebrew Software</p>"},{"location":"Homebrew/List_of_system_tools/","title":"List of system tools","text":""},{"location":"Homebrew/List_of_system_tools/#system-tools","title":"System Tools","text":"Title Description Lflash A NAND Flasher for xbox360, currently only working with 16MB NAND. For use with Linux. Dumpana Tool for dumping ANA (Graphic Scaler Chip) registers. For use with Linux. Rawflash A tool for flashing rawimages (already properly remapped) to NAND, directly via LibXenon application. <p>Category: Homebrew Software</p>"},{"location":"Homebrew/Apps/XMENU/","title":"Xmenu","text":""},{"location":"Homebrew/Apps/XMENU/#nfo","title":"NFO","text":"<pre><code>Xmenu 0.3\n=========\n\nXmenu is an elf loader with a basic gui.\n\n\nInstallation\n============\n\nCopy the file xenon.elf and the \"xenon\" folder to the root of your usb disk/pen.\nLoad it with the free60.org hack.\n\n\nChangelog\n=========\n\nVersion 0.3 :\n- It's now possible to load custom icons. Put a \".png\" image (32 bits, with alpha channel, 32*32 pixels would be better)\n  alongside your executable file, with the \".ico\" extension. Example :\n  If you have an executable named \"snes9x.elf\", put the \".png\" icon in the same directory with the name \"snes9x.ico\".\n\nVersion 0.2 :\n- Graphics data is now loaded at startup, allowing to customise.\n- Smaller fonts, this allow more items to be displayed.\n\nVersion 0.1 :\n- Alpha testing version.\n\n\nThanks\n======\nSasoseso from xboxhacker.net for sending me a free xbox 360, if all the people could be like you :)\nTmbinc of course for all his work.\nCed2911 for sega master system emulators sources, helped me a lot.\nGe0rG and ssmurf, because they are nice guys :)\n\n\n\nCpasjuste @ mydedibox.fr\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/Apps/XMPlayer/","title":"XMPlayer","text":""},{"location":"Homebrew/Apps/XMPlayer/#nfo","title":"NFO","text":"<pre><code>XMPlayer 0.0.1 - June 17, 2012\n--------------\n\nAfter some long weeks of work, this XMPlayer for 360\n\n================================================================================\nWebsite &amp; Donate\n================================================================================\nCed2911\n\nhttps://www.paypal.com/cgi-bin/websc...if%3aNonHosted\n\n================================================================================\nWhat it does\n================================================================================\n- Play video from usb, hard drive and disc drive\n- Support for ext2fs, ntfs, fat, xtaf and iso9660 partition\n- French and english translation\n- Launch elf from every media\n\n================================================================================\nWhat it does not do\n================================================================================\n- Some 1080p are playing, some doesn't\n- No network support\n- No control when playing music files\n- No picture viewer\n\n================================================================================\nKnow issues\n================================================================================\n- Slowdown when using vsync\n- XTAF support is experimental\n\n================================================================================\nWhat to do next\n================================================================================\n- More tranlastions\n- Nand flasher/dumper\n- Nand fs\n- Network support (http, youtube, update)\n- More performance\n\n================================================================================\nInstall\n================================================================================\n- Copy all files at the root of an usb stick, launch it by xell or latest dashlaunch\n\nThanks to\nAioros\ncancerous\nGliGli\nIceKiller\nJuvenal\nNatelx\nRazkar\nsk1080\ntuxuser\n[c0z]\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/Emulators/Genesis_Plus/","title":"Genesis Plus emulator","text":""},{"location":"Homebrew/Emulators/Genesis_Plus/#general-information","title":"General Information","text":"<p>Source: http://www.multiupload.com/6QYQL218GB</p>"},{"location":"Homebrew/Emulators/Genesis_Plus/#nfo","title":"NFO","text":"<pre><code>Introduction:\n  Genesis Plus is a freeware, open-source, portable emulator for the Genesis and MegaDrive consoles\n\nChangelog:\n    v240909:    First public release\n        Sound doesn't work as it should ....\n        It support bin and zip file but rom in smd format doesn'work\n        UI updatted and support skinning:\n          Background:   uda:/mdbg.png\n          File Icon:    uda:/mdfile.png\n          Folder Icon:  uda:/mddir.png\n\nContact:\n  [http://ced2911.wata.fr](https://web.archive.org/web/20110108141423/http://ced2911.wata.fr:80/) | cedric2911@free.fr\n\nThanks:\n  Tmbinc\n  Jc\n  Relapse\n  And all people in #free60\n  Authors of Genesis Plus Wii and Dc\n  Charles MacDonald\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/Emulators/Mupen64-360/","title":"Mupen64 360","text":""},{"location":"Homebrew/Emulators/Mupen64-360/#nfo","title":"NFO","text":"<pre><code>**************************\n* Mupen64-360 v0.96 Beta *\n**************************\n\nhttp://www.libxenon.org/\n\nDescription\n===========\n\nMupen64-360 is a Nintendo64 emulator for the Xbox 360, it's powered by libxenon and it's a port of Wii64 (which itself was a port of Mupen64).\n\nUsage\n=====\n\nUnzip on USB sick, then run from Xell.\n\nMany ROM formats are supported, zipped ROMs also work.\n\nIn the browser, the Back button changes the current drive, A selects, B goes to parent dir. Back also quits a game. Other controls are described in the emulator itself.\n\nThe browser background image is loaded from /mupen64-360/bg.png on the USB stick, other backgrounds are provided.\n\nHistory\n=======\n\nv0.96 Beta: First binary release\n\nCredits\n=======\n\nWii64 / Mupen64 teams (guess why :)\nGliGli (Xbox 360 port)\nCed2911 (GUI library)\nRazkar (Backgrounds)\nEveryone that contributed to libxenon...\n</code></pre>"},{"location":"Homebrew/Emulators/Mupen64-360/#video","title":"Video","text":"<p>Category: Homebrew Software</p>"},{"location":"Homebrew/Emulators/PCSXR-Xenon/","title":"PCSXR Xenon","text":""},{"location":"Homebrew/Emulators/PCSXR-Xenon/#nfo","title":"NFO","text":"<pre><code>    Pcsxr-xenon - Release a 0.5\n     ---------------------------\n\n     ****\n       Pcsxr-xenon is a sony playstation 1 emulator using libxenon, based on lastest PCSX-Reloaded source code available.\n\n     ****\n\n     ==============================\n       Changelogs\n     ==============================\n     alpha 0.5.1\n         - missing sound over hdmi\n\n     ==============================\n       Thanks\n     ==============================\n\n     - Big thanks to GliGli to mantain libxenon\n     - Thanks to [c0Z], i'm always asking you something and don't understand\n     - Thanks to Razkar, Tuxuser, Cancerous to support me all the time\n     - Thanks to Pcsx-reloaded, pcsx-rearmed, shalma to your gift to the ps1 emulation scene\n\n     Ced2911 - 08/14/2011\n\n  Update 04/03/2012\n\n     Pcsxr 0.6\n\n     New gpu plugin, allow to play game in hd !!\n\n     Load game from fat, ext2/3/4, ntfs device\n\n     Save states support\n\n     Thanks,\n\n     Gligli, Razkar, Tuxuser, [c0z], lantus, all the libxenon-dev team\n\n  Update 18/03/2012\n\n     Pcsxr 0.62\n\n     Remove ext2/3/4, ntfs support (red screen on some setup)\n\n     Bug fixe on gpu plugin\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/Emulators/Sega_Genesis_Plus_GX/","title":"Sega Genesis Plus GX","text":""},{"location":"Homebrew/Emulators/Sega_Genesis_Plus_GX/#nfo","title":"NFO","text":"<pre><code>genesis_plus 0.98\n\nfirst public version\n\nmerry xmas release :D\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/Emulators/Sega_Master_System_Plus/","title":"Sega Master System Plus","text":"<p>Source: http://www.multiupload.com/62T7RVYB5A</p>"},{"location":"Homebrew/Emulators/Sega_Master_System_Plus/#nfo","title":"NFO","text":"<pre><code>Introduction:\n  SMS Plus is a freeware, open-source, portable emulator for the Sega Master System and Game Gear consoles.\n\nChangelog:\n  v140909a: Fixed controller bug\n  v140909: Sound is now fully working greats to tmbinc\n           Back to menu with select key\n\n\nContact:\n  [http://ced2911.wata.fr](https://web.archive.org/web/20110108141423/http://ced2911.wata.fr:80/) | cedric2911@free.fr\n\nThanks:\n  Tmbinc\n  Charles MacDonald\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/Emulators/Snes9x-Gx/","title":"SNES9x GX","text":""},{"location":"Homebrew/Emulators/Snes9x-Gx/#nfo","title":"NFO","text":"<pre><code>*******************************************************************************\n   ____  _   _ _____ ____  _____  __   ______  __ __  __\n  / ___|| \\ | | ____/ ___|/ _ \\ \\/ /  / ___\\ \\/ / \\ \\/ /___ _ __   ___  _ __\n  ___ \\|  \\| |  _| ___ \\ (_) \\  /  | |  _ \\  /   \\  // _ \\ '_ \\ / _ \\| '_ \\\n   ___) | |\\  | |___ ___) __, /  \\  | |_| |/  \\   /  \\  __/ | | | (_) | | | |\n  |____/|_| _|_____|____/  /_/_/_\\  ____/_/_\\ /_/____|_| |_|___/|_| |_|\n\n*******************************************************************************\n\n-------------------------------------------------------------------------------\n                              General Information\n-------------------------------------------------------------------------------\nFilename.............: Snes9x-Gx-Beta001\nType.................: Emulator\nPlatform.............: Xbox 360\nRelease Date.........: 2009/09/08\nBy...................: TMBINC\nWebpage..............: www.free60.org\n\n-------------------------------------------------------------------------------\n                                 Change Log / Fixes\n-------------------------------------------------------------------------------\nFilename: Snes9x-Gx-Beta001\n - Fixed Ticking Sound.\n - Swapped B &amp; A buttons around.\n\nFilename: Snes9x-Gx-Beta\n - Sound Support Added.\n - Wireless Pad Support Added.\n - Full CPU Core Support Added.\n\nFilename: Snes9x-Gx-Alpha\n - The emu looks for a static rom filename - SNES9X.SMC\n - Some USB storage devices might not work.\n - Only the composite, component and VGA AVPACK are supported.\n - PAL60 is used instead of NTSC on composite.\n - VGA is hardcoded to 1024x768.\n - No VSYNC.\n - Only first wired controller is supported.\n - CPU is running at 800Mhz, only one core/thread is used.\n - No sound.\n-------------------------------------------------------------------------------\n                                 Known Bugs / To Do List\n-------------------------------------------------------------------------------\n - Screen Tearing\n - Improve Wireless Pad Support (Might be abit laggy compared to wired)\n - No Sram Support Yet\n - Graphical Interface / Menu\n - Lots More To List\n\n-------------------------------------------------------------------------------\n                                 Release Notes\n-------------------------------------------------------------------------------\nThis is the first SNES emulator to run natively on the xbox 360 using the new\nXell hack released by the guys over at www.free60.org\n\nBuild based off the sources from http://code.google.com/p/snes9x-gx/ &amp; compiled\nusing LibXenon found at https://github.com/LibxenonProject\n\nAll Code used to create LibXenon &amp; to compile this port, is opensourse &amp;\ncontains no Microsoft XDK code making it legal to distribute the .ELF files.\n\nCurrently only running on the xenon xell hack. Support for other chipsets is\nin the works!\n\n-------------------------------------------------------------------------------\n                                 Install Notes\n-------------------------------------------------------------------------------\nCopy Xenon.elf to the root of your mem stick along with any rom which has been\nrenamed as SNES9X.SMC\n\nInsert mem stick into xbox 360 &amp; power on.\n\nTHIS ONLY WORKS WITH HACKED 360 RUNNING XELL\n\n-------------------------------------------------------------------------------\n                                 License\n-------------------------------------------------------------------------------\nSnes9x homepage: http://www.snes9x.com\nSnes9x GX homepage: http://code.google.com/p/snes9x-gx/\n\nPermission to use, copy, modify and/or distribute Snes9x in both binary\nand source form, for non-commercial purposes, is hereby granted without\nfee, providing that this license information and copyright notice appear\nwith all copies and any derived work.\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event shall the authors be held liable for any damages\narising from the use of this software or it's derivatives.\n\nSnes9x is freeware for PERSONAL USE only. Commercial users should\nseek permission of the copyright holders first. Commercial use includes,\nbut is not limited to, charging money for Snes9x or software derived from\nSnes9x, including Snes9x or derivatives in commercial game bundles, and/or\nusing Snes9x as a promotion for your commercial product.\n\nThe copyright holders request that bug fixes and improvements to the code\nshould be forwarded to them so everyone can benefit from the modifications\nin future versions.\n\nSuper NES and Super Nintendo Entertainment System are trademarks of\nNintendo Co., Limited and its subsidiary companies.\n\n-------------------------------------------------------------------------------\n                                 Greetz &amp; Shoutouts\n-------------------------------------------------------------------------------\nThanks to TMBINC - XBH - Free60 - And the rest of the crew!!!!\nNFO Created By HoRnEyDvL 2009\n-------------------------------------------------------------------------------\n-------------------------------------------------------------------------------\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/Games/Pong/","title":"Pong","text":""},{"location":"Homebrew/Games/Pong/#nfo","title":"NFO","text":"<pre><code>Hi there\n\nJust for show you a small app i've made for Xbox 360, with the help of libxenon and SDL.\nThe game of the year : PONG! :D\n\nActually, no extra, we move to top/bottom and that's it.\n\nI add sound when i get bin2o working\n\nInput have bug (bottom key sometime not response)\n</code></pre>"},{"location":"Homebrew/Games/Pong/#video","title":"Video","text":"<p>Category: Homebrew Software</p>"},{"location":"Homebrew/Games/SDLQuake/","title":"SDL Quake","text":""},{"location":"Homebrew/Games/SDLQuake/#nfo","title":"NFO","text":"<pre><code>As a testbed, ive ported SDLQuake in parallel with libSDLXenon\n\nSDLQuake libXenon repository is located at\n\nhttps://github.com/lantus/sdlquake-libxenon\n\nDownload the source and use 'make' to build SDLQuake.\n\nI've attached a binary with shareware quake as well.\n\nEnjoy :)\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/Games/Tanks_360/","title":"Tanks 360","text":""},{"location":"Homebrew/Games/Tanks_360/#nfo","title":"NFO","text":"<pre><code>This is going to get flushed out more.\n\nFor now, i decided to work on creating an engine / game from scratch made in and from libxenon and lzx.\nThis is still very basic much more to come.\n\nThanks to libxenon team.\nThanks to Ced2911, Cancerous, Tuxuser for Libxenon / LZX / Encouragement\nThanks to Blackwolf for the upcoming music\nThanks to Mattie for the idea\nThanks to STK50 for all you have done. Hope one day to work with you again.\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/PC-Software/","title":"PC Software","text":""},{"location":"Homebrew/PC-Software/#nand-tools","title":"NAND Tools","text":""},{"location":"Homebrew/PC-Software/#nandcompare","title":"NandCompare","text":""},{"location":"Homebrew/PC-Software/#description","title":"Description:","text":"<p>Check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps.</p> <p>Author: Rab at XBH</p>"},{"location":"Homebrew/PC-Software/#download","title":"Download:","text":"<ul> <li>v1.3</li> </ul>"},{"location":"Homebrew/PC-Software/#nandpro","title":"NandPro","text":""},{"location":"Homebrew/PC-Software/#description_1","title":"Description:","text":"<p>Read/write NAND dumps and repair the spare bytes / ECC sections.</p> <p>Author: Tiros at XBH</p>"},{"location":"Homebrew/PC-Software/#download_1","title":"Download:","text":"<ul> <li>xbins </li> <li>360-HQ</li> </ul>"},{"location":"Homebrew/PC-Software/#360flashtool","title":"360FlashTool","text":""},{"location":"Homebrew/PC-Software/#description_2","title":"Description:","text":"<p>Decrypt and extract various parts of an Xbox NAND dump.</p> <p>Author: Robinsod, TheSpecialist and SeventhSon at XBH</p> <p>Since Robinsod released the source of \"360 Flash Dump Tool\" and stopped developing a couple of people (Redline99, Tiros and MODFREAKz) decided to continue develop this great app.</p>"},{"location":"Homebrew/PC-Software/#download_2","title":"Download:","text":"<ul> <li>0.97</li> </ul>"},{"location":"Homebrew/PC-Software/#nandfs","title":"NANDFS","text":"<p>Description: Add/remove/extract files from a NAND dump. Open source.</p> <p>Author: [stoker25], based on 360 Flash Tool source by Robinsod.</p>"},{"location":"Homebrew/PC-Software/#download_3","title":"Download:","text":"<ul> <li>v.45d binaries</li> <li>v.45d source</li> </ul>"},{"location":"Homebrew/PC-Software/#pc-utilities","title":"PC Utilities","text":"Title Description NandCompare Check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps. NANDPro Read/write NAND dumps and repair the spare bytes / ECC sections. It can also flash CPLDs or log POST-Codes. 360FlashTool Display, Decrypt and extract various parts of an Xbox NAND dump. <p>Category: Homebrew Software</p>"},{"location":"Homebrew/PC-Software/360FlashTool/","title":"360 Flash Tool","text":""},{"location":"Homebrew/PC-Software/360FlashTool/#nfo","title":"NFO","text":"<pre><code>This tool will allow you to decrypt and extract various parts of a Xbox 360 flash dump.\nThis tool will allow you to decrypt/encrypt and extract various parts of a Xbox 360 flash dump and much more!!\nThe flash is devided into 2 major parts\n\n1) The Cx sections (CB,CD,CE &amp; 0,1 or 2 CF &amp; CG sections).\nCB, CPU bootup\nCD, unpacker for CE\nCE, contains the HV and Kernel in a .cab archive\nCF&amp;CG are upgrade patches\nThe tool will extract and decrypt sections CB, CD, CE. Additionally it will extract the .cab file in section CE. This can be opened with winrar and the content (xboxkrnl.img) extracted. The first 256K of xboxkrnl.img is the Hypervisor, the remainder is the 2.0.1888 Kernel.\n\n2) The Flash File System.\nThe tool expects a dump to contain the data (512 bytes) followed by the ECC (16 bytes). The ECC bytes are used to locate FS entries &amp; identify the version.\nThe tool consists of the exe and CxKey.txt. CxKey.txt is delivered with 32 '0's and they should be replaced with the key obtained from the 1BL. After all the fuss about AACS keys recently it seems risky to put the key in the exe Wink The Cx sections extracted from a dump will only decrypt correctly if the correct hex digits are inserted in the CxKey.txt file\n\nVersion History\n-----------------\n\n(v0.97)\n- Improved Nand Image detection\n- Added support for small XeLL Images (1,3MB)\n- Added ability to extract/import Slot0/Slot1 of ZeroPaired Images [XBR/freeBOOT/small XeLL]\n- Added ability to detect/convert raw Images (made with external programmer) to proper read format\n- Added ability to detect/convert Images without ECC data (made with Infectus device)\n- Added ability to extract/import new 'dae.bin' file [DvdAuthEx]\n- Added support for \"Alternate KeyVault\" decrypting/extracting\n- Added option to rebuild an opened Nand Image with different CPU-Key (Bootloaders/HV and generic files)\n- Added option in Settings to allow randomized encryption\n- Added option in Settings to allow cut short BigBlock Nand Images (64MB)\n- Fixed bug, regarding to saving config block checksum at wrong offset (in rare cases)\n- Changed, more accurate file extraction, automatically create subfolders\n- A lot of improvements and bug fixes\n\n(v0.95)\n- Added support for Trinity (XBOX360 Slim) dumps\n- Added ability to extract new 'fcrt.bin' file (encrypted only atm)\n- Added ability to display SMC Code Version\n- Added ability to view Advanced KeyVault Info\n- Fixed bug, patching KeyVault works again\n- Fixed bug, no longer crashes if Bootloaders are small in size (in rare cases)\n- Fixed bug, regarding to re-encrypting the SMC when the image is Zero Paired Image\n\n(v0.94)\n- Added static SMC Config editing [change CPU/GPU Fan Speed, Calibration Data, MAC Address, ....] (Thanks to q36)\n- Added support for single file \"config.bin\" editing/converting via Drag'n'Drop\n- Added ability to convert Xellous/NandPro raw SMC Config to different Styles and vice versa, e.g. for ibuild (Thanks to foouser)\n// FreeBOOT SmallBlock Style 16Kb\n// FreeBOOT BigBlock Style 128Kb\n// FlashTool SmallBlock Style 64Kb\n// FlashTool BigBlock Style 512Kb\n// BinCrypt2 Style 32Kb\n- Added checksum calculation for static SMC Config Block (Thanks to cory1492)\n- Added ability to extract/import encrypted KeyVault without known CPU Key [For Advanced Users]\n- Added ability to extract ibuild compatible files (..\\freeBOOT\\Data)\n- Added ability to open 70MB images (dumped with nandpro \"-r70\")\n- Added Option menu to enable/disable several features\n- Added Tooltips and Glass Effect\n- Bugfix in Multiple CPU Key handling\n- Fixed a lot small bugs\n\n(v0.93)\n- Fixed CPU-Key detection/correction in Multiple Keys section\n- Added ability to save KeyVault to file\n- Added ability to export a registry file from all added Keys\n- Added support to extract the Console Revocation List to a readable format 'dynamic_list.txt'\n- Improved state indication via Progress Bar\n- Minor changes\n\n(v0.92)\n- Added Support for Large Block nands (Jasper 256MB and 512MB nands)\n- Added Support for DevKit images + region for DevKit\n- Added Support for XBR/ZeroPaired images (still in development)\n- Added Single CPU Key or Multiple CPU Key handling (max. 25 Keys)\n- Added simple state indication via Progress Bar\n- Added ability to display Bad Blocks with true image offsets\n- Fixed bug in reading 7BL (CG) that have more blocks than specified in 6BL (CF)\n- Fixed bug in reading bootloaders that are smaller than 1 block\n- Fixed bug in kernel extract log with double slashes, more accurate extract log\n- Fixed multiple memory leaks\n- Fixed application can now start without Administrator Rights or UAC enabled\n- Updated config block logic with new info\n- Changed appearance for more read comfort\n\n(v0.91) 2009-12-06\n* Added, support for Jasper 16MB nands, Block ID and Block Version in a different location. Uses offset 0x71 to determine metadata style, 0 = Original, 1 = New 16MB, 2 = Large Block.\n* Added ability to open ZeroPaired images, but WARNING this should be treated as read only. I suspect it will destroy the nand image if used to modify the file.\n\n(v0.90)\n- Bugfix, regarding to CD decryption. If you have a 1920+ CD version it doesn't decrypt CD properly. (by arnezami)\n- Bugfix, if a CPU key starts with 00 then the program crashed. (by arnezami)\n- Added, separate extract option for all important stuff (Security Data, Extended Key Vault, Console Revocation List, AP25 Challenge Database, Config Blocks)\n- Added, console ID generation method (source from xorloser)\n- Added, detection and correction of 1 wrong byte in the CPU-Key (by MODFREAKz)\n- Added, XValue decryption (by Redline99)\n- Added, support when raw extracting a file that it sets the Date/Time stamps as per original in Nand\n- Fixed, decryption for \"Console Revocation List\" (Thanks to xorloser and Redline99)\n- Fixed, \"Kernels not extracted (CPU Key required, CD Ver == 1920)\"\n- Changed, full KV.bin extract and patch\n- Added new OSIG types and unspoof possibility\n- Added/Changed new regions\n- 1BL, XEX1 and XEX2 are set as standard\n- Improved exception handling\n- Added Drag and Drop\n- Changed Icon\n- Code cleanup\n- Fixed a lot of other small bugs\n\n\n(v0.88B)\n- Fixed the Region bug (HK/Asia &lt;=&gt; EU and AUS)\n- Redesigned (XP style)\n\n\n(v0.88A)\n- A small upgrade allowing the secdata.bin file to be decrypted.\n(You need the XEX and CPU keys then extract the filesystem and you will get a decrypted secdata.bin as well as a bunch of other stuff.)\n\n\n(v0.88)\n- The flash image can now be patched with modified SMC code and the 2BL hash is fixed up to allow the 360 to boot.\n- You can also modify the Pairing Data and LDV in the headers.\n\n\n(v0.87)\n- Added, KV editting (change region, DVD-Key, OSIG type or import a new KV)\n\n\n(v0.86B)\n- Fixed bug (patching KV works again)\n- 5787 contains a modified CF, this build of the tool will now extract the HV &amp; Kernel correctly\n(It doesn't change the way the extractor/patcher works but the change in CFs size broke my code)\n\n\n(v0.86A)\n- Fixes bug introduced in v0.85 when patching CB LDV\n- Changed file filter to '*.bin'\n\n\n(v0.86)\n- Adds support for bad blocks (no more crashes if you have a bad block in you dump)\n\n\n(v0.85)\n- Added option to patch CB LDV\n- Extract using new v1920 CD decryption\n- Extracts SMC code\n\n\n(v0.81)\n- Adds the possibility to dump just the flash in 3 parts:\n1) Cx Sections\n2) KV\n3) File System\n\nNote: If you have bad flash blocks that prevent you dumping a particular area this will is a work around while I write some bad block handling code.\n\n\n(v0.80)\n- Fixed bug that ment xexp files were not applied correctly\n- Updated to prefix the XEX2 header on the front of the decrypted/patched binary for compatibility with the IDA Pro XEX loader.\n- Added the ability to re-encrypt and insert a KeyVault (by SeventhSon)\n\n\n(v0.72)\n- Fixed stupid no CPU key crash bug\n- Applies the patches (xexp files) it finds to the xex.\n(So, for a flash dump that contains: dash.xex (v1888), dash.xexp1 (v2241), dash.xexp2 (v2868))\n\n\n(v0.70)\n- There are upto 4 keys required by the tool, you can enter these by clicking the Keys button.\n1) 1BL Key\n2) CPU Key\n3) XEX 1 the Key used by the HV when the an XEXs certificate flag has bit 2 set\n4) XEX 2 the Key used by the HV when the an XEXs certificate flag has bit 2 clear\n\n- The Extract button will cause the tool to extract as much as possible from the Flash dump to a directory you select. During the extraction process a log file (log.txt) is generated containing \"Useful Stuff To Know\":\nIf 1BL is known - CB,CD,CE,CF(s),CG(s), xboxkrnl.1888.exe and xboxkrnl.XXXX.exe(s) as before\nIf 1BL &amp; CPU Key is known - KeyVault.bin\nIf XEX1 &amp; XEX2 &amp; ECC data are known the tool will extract and decrypt &amp; decompress the XEXs in the flash dump. The decrypted XEX is named xxxx.xex.bin. More info about the xex (and its patches) is contained in the log file.\n\n- Possibility to zero the pairing data in the CB section (tmbinc thought this caused the mfgbootlauncher.xex plus v1888 Kernel to be loaded) by clicking the Zero PD button. You do need the 1BL key but you DO NOT need your CPU key for this patch.\n- The Patch button allows you to change the Lockdown Counter(s) in the CF sections, as before, you DO need your CPU key\n\n\n(v0.61)\n- Fixed bug, the decryption of CG works again so now you can extract the different HV/Kernel versions from CE\n- Fixed bug, no longer crashes if it finds an invalid CG section\n- Added, load dumps (with or without ECC data). A non ECC dump must be exactly 16MB, all the Cx sections, Kernels, Key Vault will decrypt but you don't get access to the Flash File System.\nNote: (you cant dump a map of the ECC bytes and you cant save an image with a modified Lock Down Counter in CF.\n\n\n(v0.60)\n- Supports downgrading if you know your CPU key.\n- The CG decryption is broken in this version.\n\n\n(v0.51)\n- Added, Flash Map option\n\n\n(v0.50)\n- Now decrypts and extracts the Key Vault (DVD Key, Serialnumber &amp; Date of Manufacture). You will need your CPU Fuses as dumped by Xell.\n- The CxKey.txt file has changed, you need to add a ',' and your CPU Fuse data.\n\nExample:\nXXXXXXXXXXXXXXXX,YYYYYYYYZZZZZZZZ\nXXXXXXXXXXXXXXXX is the 1BL key\nYYYYYYYYZZZZZZZZ is the fuse data (CPU Key)\n\n\n(v0.40)\n- Extraction of CE section is now working, you may now right click and select 'Extract' and get just the raw, decrypted CE Section or Kernel(s). (Thanks TheSpecialist)\n- Selecting Kernel(s) causes the application to extract the base (typically 1888) HV and Kernel as an uncompressed file - \"xboxkrnl.1888.exe\".\n- The option to extract them as a .cab file has now been removed. If 1 or both of the patch (CF/CG) slots are occupied they will be applied to the base kernel and the result is also written as a file - xboxkrnl.XXXX.exe.\n\nFor example, if you have a base kernel (1888) and 2 patches (2858 and 4552) in your flash dump, load into the tool, right click on CE and choose kernel(s) you will get 3 files\nxboxkrnl.1888.exe The base HV &amp; kernel, no patches\nxboxkrnl.2858.exe The base HV &amp; kernel, patched to 2858\nxboxkrnl.4552.exe The base HV &amp; kernel, patched to 4552\n\n\n(v0.30)\n- Fixed CG extraction (see NAND Layout thread for info)\n- Reverted CE.cab to single file (Thanks Takires)\n- Patch pairing data in CF and re-encrypt\n\n\n(v0.20)\n- Decrypts CF &amp; CG (Thanks again tmbinc)\n- The .cab file extracted from CE now contains 2 files, Hypervisor.bin and xboxkrnl.exe\n- Exported sections now include version number in the name\n\n\n(v0.10)\n- Initial Release\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/PC-Software/List_of_PC_utilities/","title":"List of PC utilities","text":""},{"location":"Homebrew/PC-Software/List_of_PC_utilities/#pc-utilities","title":"PC Utilities","text":"Title Description NandCompare Check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps. NANDPro Read/write NAND dumps and repair the spare bytes / ECC sections. It can also flash CPLDs or log POST-Codes. 360FlashTool Display, Decrypt and extract various parts of an Xbox NAND dump. <p>Category: Homebrew Software</p>"},{"location":"Homebrew/PC-Software/NANDPro/","title":"NANDPro","text":""},{"location":"Homebrew/PC-Software/NANDPro/#nfo","title":"NFO","text":"<pre><code>===============================================================================\n            SUPPORTED DEVICE INTERFACES\n===============================================================================\n\nUSB:\n   LPC2148 Olimex USB header board.\n   High performance 16MB/2Mins.\n   LibUsb driver.\n\nLPT:\n   Parallel Printer Port, SPP mode.\n   Low performance, 16MB/35mins (cpu dependant).\n   Dlportio printer port driver.\n\nXSVF:\n   Subset device of USB.\n   LPC2148 Olimex USB header board required.\n   NOT for nand programming. This command line device type is for flashing\n   .xsvf files to a Xilinx cpld.\n\nPOST:\n   Subset device of USB.\n   LPC2148 Olimex USB header board required.\n   NOT for nand programming. This command line device type is for monitoring\n   Post codes only.\n\nThe included .hex file supports both Nand SPI flash, Xilinx Programming,\nand Post Monitor all at the same time.\nThe mode selected ie: Nand Flash/Xsvf/PostMon is determined by the command line.\nPrevious .hex files as well as the \"pic\" version of hardware will not work.\n\nThe Maximus \"NANDFlasher\" has an array of plated through holes to break out all\nthe extra LPC2148 gpio. This product can be flashed with the new ArmV3.hex file\nfor full comatibility with Nandpro. The wiring coordinates are included here for\nthose who have this device. The included .jpg file shows the connections\nto flash this device with the Philips utility. An RS232 level shifter is also\nrequired for this purpose.\n\nThe Team Executor \"NAND-X\" can also be flashed with the ArmV3.hex, however the\nwiring connections may be difficult, and are not listed in this document.\n\n===============================================================================\n            DRIVER AND HARDWARE INSTALLATION\n===============================================================================\n\nUSB Install:\n   Flash the .hex file to the LPC2148 using the\n   \"Philips LPC2000 FlashUtility\" or equivalent.\n   Connect LPC2148 to computer USB.\n   Point \"found new hardware\" to the \"custom.inf\"\n   Windows reports: \"Your new hardware is ready to use\"\n\nUSB Hardware:\n   Connect only wires from EXT connectors to MAINBRD where indicated.\n   Connect only wires from EXT connectors to Xilinx jtag connector where indicated.\n   No resistors or diodes at all. For sure! Do not add them!\n\n===============================================================================\n\nLPT Install:\n   Run the port95nt.exe application to install the DlPortio driver\n\nLPT Hardware:\n   Some parallel ports run at 3.3v others at 5v. The MAINBRD is 3.3 volts.\n\n   It is recommend to use 100 ohm series saftey resistors (R)\n   for all lpt connections except for DB25.11 and DB25.18 (GND), as shown above.\n   Testing with 5 volt lpt and NO resistors didn't burn anything up though. YMMV\n\n   For DB25.11 connect diode exactly as shown. It is highly recommended to\n   connect the diode to the MAINBRD end rather than the PC end of the wire.\n   Preferred diode is BAT41 or other Schottkey switch diode with low forward voltage drop.\n   1N4148/53, 1N914, type switching diodes should be also be ok,\n   but are not quite as good. 1N400X are rectifiers and not good at all.\n\n   This solution isn't perfect but you typically dont leave it hooked up forever anyway.\n   If someone wants to design and post a buffer circuit go right ahead. I can't be bothered\n\n===============================================================================\n            COMMAND LINE USAGE\n===============================================================================\n\nNandPro v3.0a by Tiros\n\n\nUseage:\n\nTo invoke Nand SPI flasher use:\nNandPro dev: -r# Filename (HexStartBlock HexBlockCount) -&gt;Read\nNandPro dev: -w# Filename (HexStartBlock HexBlockCount) -&gt;Write\nNandPro dev: -e# (HexStartBlock HexBlockCount)          -&gt;Erase\n\ndev: Is hardware interface usb: or lpt:\ndev: Can also be a filename:, to be used as a 'Virtual Nand Device'\n   Virtual device config can be forced, by appending :HexConfigValue\n# Is nand size (16, 64, 256, 512) in MegaBytes\nHexBlocks are optional range limits, default is entire device\n-r# Read saving file RAW (with SPARE)\n-R# Read saving file without SPARE\n!r# Read saving only the SPARE data\n-w# Write RAW (with SPARE) file\n+w# Write RAW (with SPARE) file, init SPARE, block numbers, ECC\n@w# Write RAW (with SPARE) file, init block numbers, ECC\n*w# Write RAW (with SPARE) file, init ECC\n+W# Write while ADDING SPARE from file without SPARE\n\nTo invoke Xilinx xsvf flasher use:\nNandPro xsvf: XsvfInputFilename.xsvf\n\nTo invoke usb post monitor use:\nNandPro post: PostLogFileName.txt\n\n\n===============================================================================\n===============================================================================\n            .XSVF CPLD CONNECTIONS AND OPERATION\n===============================================================================\n===============================================================================\nFollow instructions for USB install.\nMake the following connections from the LPC2148 to the Xilinx device\nJtag conenctor:\n\nArmLpc  Jtag            Olimex          Maximus\n\n3.3v    VCC             EXT2.24         M1\nGND     GND             EXT2.25         N3\nP0.17   TCK             EXT1.18         A2\nP0.18   TDO             EXT1.19         B3\nP0.19   TDI             EXT1.20         C1\nP0.20   TMS             EXT1.21         C2\n\nXilinx CPLD flashing typical command line:\n\nFlash a .xsvf file, created by Impact, to cpld:\n   Nandpro xsvf: filename.xsvf\n\nGeneral XSVF notes:\nLPT is not supported for this feature.\nRequires additional connections from LPC2148 to the Xilinx jtag connector.\nThe Xilinx Impact tool is used to create .xsvf files. The Xilinx Impact software\nrecords/redirects cpld operations into a binary file (.xsvf) that can be\nprocessed by Nandpro. IE: Nandpro does not flash .jed files, but .jed files\nmay be directly converted to .xsvf by Impact.\nSee the Xilinx Impact tool for more information.\n\n===============================================================================\n===============================================================================\n            POST MONITOR CONNECTIONS AND OPERATION\n===============================================================================\n===============================================================================\nFollow instructions for USB install.\nThe post connections require level shifting to 3.3 volts to be monitored.\nThis will require an external circuit. The cpld can also be used for this purpose.\n\nFlash cpld with nandpro:\n   nandpro xsvf: SlimPlusPost.xsvf\n\nThe SlimPlusPost.xsvf is fully compatible with the existing released pinout with\nthe exception of the DBG pin. The DBG pin has been relocated and now\ndrives via open collector. The LED will remain off, and flash briefly\non each reset attempt.\n\nTo connect an LED to the DBG pin:\n\n3.3V---/\\/\\330/\\/\\---&gt;|-------DBG 3 (37)\n\n\nMake the following connections from the LPC2148 to the cpld\nlevel shifter outputs:\n\nArmLpc  Post    Olimex          Maximus         CPLD Out (CMOD)\n\nP1.16   Post0   EXT2.5          L1                      38 (28)\nP1.17   Post1   EXT2.6          J2                      37 (27)\nP1.18   Post2   EXT2.7          I1                      36 (26)\nP1.19   Post3   EXT2.8          G3                      34 (25)\nP1.20   Post4   EXT2.9          A1                      33 (24)\nP1.21   Post5   EXT2.10         D3                      32 (23)\nP1.22   Post6   EXT2.11         E1                      31 (22)\nP1.23   Post7   EXT2.12         G1                      30 (18)\n\n\nMake the following connections from the main board post outputs to the\ncpld level shifter inputs:\n\nMbrd                    CPLD\nPost Out                In (CMOD)\n\nPost0                   39 (29)\nPost1                   40 (30)\nPost2                   41 (31)\nPost3                   42 (32)\nPost4                   43 (33)\nPost5                   44 (34)\nPost6                   1  (35)\nPost7                   2  (36)\n\n\nPost monitor typical command line:\n   Nandpro post: PostLog.txt\n\nGeneral post monitoring notes:\nLPT is not supported for this feature.\nPost changes will be displayed on the command line and logged to the\nspecified filename as a text file.\nThe log file will be over written on each run.\nPressing any key will break the post monitor loop.\n\n===============================================================================\n===============================================================================\n            NAND FLASHING CONNECTIONS AND OPERATION\n===============================================================================\n===============================================================================\nSeven connections must be made from MAINBRD to the HW device interface.\nMAINBRD connects as specified to either Olimex board, or a PC printer port.\n\nArmLpc  Olimex          LPT                             MAINBRD\n\nSS      EXT1-3          DB25.1  --R---  J1D2.2\nMISO    EXT1-6          DB25.11 --&gt;|--  J1D2.4  Diode, observe polarity!\nP0.28   EXT2-1          DB25.16 --R---  J2B1.6\nGND     EXT1-26         DB25.18 ------  J1D2.6  or      J2B1.12\nMOSI    EXT1-7          DB25.14 --R---  J1D2.1\nSCK     EXT1-5          DB25.2  --R---  J1D2.3\nP0.29   EXT2-2          DB25.17 --R---  J2B1.5\n\n   Make connections to MAINBRD and run the app.\n   MAINBRD needs to be plugged in to AC power.\n   Actually powered on or not does not matter.\n   While running NandPro application reset will occur.\n   After nand operation is complete, reset will be released.\n\nNand flashing typical command line:\n\nRead entire 16M flash, including SPARE:\n   NandPro dev: -r16 nand.bin\n\nWrite entire 16M flash, including SPARE:\n   NandPro dev: -w16 nand.bin\n\nAdvanced command line examples:\n\nRead encrypted key vault with SPARE:\nnandpro dev: -r16 rawkv.bin 1 1\n\nRead encrypted key vault from a \"Virtual Nand\" dev:, named vnand.bin, with SPARE :\nnandpro vnand.bin: -r16 rawkv.bin 1 1\n\nWrite encrypted key vault:\nnandpro dev: -w16 rawkv.bin 1 1\n\nFlash a xell.bin compiler output (no SPARE) to block 40, adding SPARE while flashing:\nnandpro dev: +W16 xell.bin 40\n\nRead config block from a \"Virtual Nand\", named vnand.bin, without SPARE:\nnandpro vnand.bin: -R16 configblk.bin 0x??? 1\n\nWrite above config block to dev: adding the SPARE back in:\nnandpro dev: +W16 configblk.bin 0x??? 1\n\nWrite a \"small\" python.ECC file to \"full size\" \"Virtual Nand\" :\nnandpro vnand.bin: -w16 python.ECC\n\nWrite to a dev:, from another RAW file, fixing ECC while writing:\nnandpro dev: -w16 DumpWithErrors.bin\n\n\nGeneral nand flashing notes:\n\nSPARE is the 16 bytes following a data block.\n\nECC is 26 bits located within the spare area.\n\nBlock numbers are also contained in spare area.\n\nReading and writing defaults to the entire device.\nThe start block argumnet is optional and dictates the starting block to program.\nThe ending block is also optional, and end if no block is specified, programming will\ncontinue until end of file or end of specified nand size.\n\nLarge block nands have different SPARE format than small block nands.\nThe software uses the detected device's SPARE format for all (+) write operations.\nFiles written RAW (-) are not translated in any way.\n\nThe \"nand size\" argument only sets the limit of available blocks for device operations.\nIt is not hardware related, and need not exactly match the true device.\n\nThere is no need to erase before programming.\n\nYou can hex edit a block, and use Nandpro to fix its ECC when you write it back.\n\nThe \"Case\" of the command generally indicates if I/O file will contain SPARE or not\n   Upper Case:     No SPARE\n   Lower Case:     RAW (with SPARE)\n\nThe \"Virtual Nand\" file can be read or be programmed, as if it where a device.\nThe \"Virtual Nand\" file must be a raw file, containing SPARE.\nThis can be used to extract or inject data from\\to an existing raw dump.\nExample: To inject a \"small\" python image into an existing\n\"full size\" image, or to extract individual blocks from an existing raw dump.\n\nNote:\nFor the vnand: device the flash config is normally automatically detected.\nSome \"hybrid\" 256/512 images can not be detected properly, to mount these files the config\nvalue must be forced by specifying it as the last argument on the command line, preceeded by a ':'.\nOnly vnand: device may be forced!\n\nExample:\nnandpro vnand.bin: -r64 rawkv.bin 1 1 :AA3020\n\n\nREADING WILL OVER-WRITE AN EXISTING FILE WITHOUT WARNING!\nNEW LOG FILE WILL OVERWRITE OLD WITHOUT WARNING!\n\nDO NOT LEAVE LPT CABLE CONNECTED WHEN CONSOLE DOES NOT HAVE AC POWER!\n\n===============================================================================\n            HISTORY\n===============================================================================\n//\n//2.0\n//Initial Release\n//\n//2.0a\n//Fixed usage for +W, +w\n//Fixed problem with payload injection for large block nands\n//Fixed miscalc of file blocks togo when injecting !raw\n//No ARM code impact\n//\n//\n//2.0b\n//Remove \"Press Any Key\" for unattended batch file processing\n//Removed retry on individual sectors, retry entire block instead, including erase\n// attempt to program all sectors anyway, then report status\n//ARM code update required for above\n//Added ARM HW version test, (U32) 0000 0001 required or abort\n//Added \"Virtual Nand\" device\n//\n//\n//2.0c\n//Bit settling verify feature added for LPT reading\n//Add support for Jasper16a\n//Improved detection for virtual nand device, fixes some problems with writing to vnand.\n//Allways corrects the ECC bytes (but not SPARE), even in raw mode\n// ie: A raw file that has been hex edited can simply be flashed with -w\n//\n//Added command line swithces\n//%r will read SPARE data only, 16 bytes per block\n//@w will write RAW file, while correcting block numbers\n//Can \"force\" a flash config on command line by appending :HexFlashConfig\n//\n//2.0d\n//For compatibility purposes -w does not calculate ECC\n//Raw files are flashed pure using -w. To correct ECC errors use *w instead\n// ie: A raw file that has been hex edited can simply be flashed with *w\n//\n//2.0e\n//Fixed the \"forced\" flash config on command line for virtual nand device.\n//\n//3.0a\n//Requires new v3 .hex for arm\n//Suppport added to flash .xsvf files by jtag\n//Support added for post monitoring and logging\n//\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/PC-Software/NandCompare/","title":"NANDCompare","text":""},{"location":"Homebrew/PC-Software/NandCompare/#nfo","title":"NFO","text":"<pre><code>nand compare (v1.4):\n--------------------\n\n  i made 6 reads of my nand with no matches (one of them was good but of course i\n  didn't know that at the time), but diffing them i could see that the differences\n  where spread all throughout the file, so i wrote this tool to reconstruct it\n\n  then i also discovered the usefulness of the compare function in verification of\n  the write, so hopefully this tool will be of use to other people\n\n  please send feedback, bugs, etc. to rab (richardaburton@gmail.com) or post in\n  the thread on xbox-scene or xboxhacker\n\n\nthe tool has two functions:\n---------------------------\n\n- compare 2 nand images\n  better than simply using md5 as it tells you which blocks are mismatched, which\n  allows you to reread only those that are in error rather than the entire chip\n  (speeding up the process)\n\n  one use of this is when verifying a write by reading back the nand and comparing\n  it against the original you wrote, if you get a bad block just reread that\n  individual block, patch it into the full read and compare again (files are\n  reread each time you click compare, no need to reselect the same files in the\n  gui)\n\n  e.g. nandpro lpt: -w16 XBR.bin (write image as normal)\n        nandpro lpt: -r16 verify.bin (read back image)\n        (do comparison, shows block 2e mismatches)\n        nandpro lpt: -r16 2e.bin 2e 1 (read block 2e)\n        nandpro verify.bin: -w16 2e.bin 2e 1 (patch this new read into verify image)\n        (do comparison again, if still bad rewrite just this block and read it back again as above)\n\n\n- reconstruct image from 3 bad reads\n  assumes that read errors don't occur in same place each time, which is true for\n  some read errors (e.g. lpt timing problems), if there is a good reason why you\n  can't read something then this may not be true\n\n  this tool cannot recreate a nand out of nothing, if you give it 3 files full of\n  zeros you'll get a recreated nand full of zeros, always look at a dump to make\n  sure it looks correct (e.g. has a microsoft copyright at the top, once you've\n  reconstructed a nand open it in 360 flash tool and make sure it reads ok there)\n\n  the tool works by comparing blocks between the 3 files, any block found matching\n  in 2 (or 3) of the files will be considered good, you will be warned if not all\n  blocks can be recovered, in which case you'll need to get more reads or look for\n  a good reason why your reads are so bad\n\n\nversion history:\n----------------\n  1.4 (2010/01/23) - support any size image (any number of blocks at 0x4000 + ecc)\n                      for partial dumps of large nands, 2mb xell backups, etc.\n  1.3 (2009/12/18) - reduce block size for 256/512mb nands (to 0x4000 + ecc) based\n                      on user feedback (nandpro uses small block numbering so our\n                      output didn't match up with nandpro)\n                    - make gui more responsive when operating on large nands\n  1.2 (2009/12/15) - support for 256mb nand\n                    - use correct block size for 256/512mb nand (0x20000 + ecc)\n                    - added progress bar\n  1.1 (2009/12/13) - support for 512mb nand (assumes same block size as 16mb)\n  1.0 (2009/12/12) - first release\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Homebrew/Tools/XeLL/","title":"XeLL","text":"<p>XeLL is the Xenon Linux Loader. It's a second-stage bootloader which is loaded by a loader.</p> <p>XeLL catches CPU threads, sets them up, loads an ELF file from either network (tftp) or CDROM (ISO9660), and launches it. It's made to boot linux. Thus it also contains a flat device tree for linux. However, it should be able to load other ELF files as well, like apps based on libXenon.</p> <p>lwIP is used for networking. Network config is currently hardcoded in network.c (and main.c), and probably needs to be modified if you want to use it.</p> <p>XeLL is in a very early stage, but is (most of the time) fully working.</p> <p>XeLL is available at https://github.com/Free60Project/xell. There are currently no binary releases of original XeLL.</p> <p>XeLLous is an available modification of XeLL made by Redline99. It support flashing full nand images (updflash.bin) and patchslots for rebooter images (updpatch.bin) and includes a HTTP Server where you can get your CPUKey and DVDKey (if KV is in place) and dump your nand. XeLLous is availabe on xbins.</p> <p>XeLL Reloaded (Codename: 2Stages) is the recent branch of XeLL. It consists of 2 stages: Stage 1 does the main low level hw init, loads Stage 2 into memory and executes it. Stage 2 is built with libxenon - ensures the latest codebase. For all new features check the README1 You can get the sourcecode of XeLL Reloaded from Free60 Sourceforge's GIT aswell - branch: 2stages (which is the standard branch) 2</p>"},{"location":"Homebrew/Tools/XeLL/#building-and-running","title":"Building and running","text":"<p>0. Make sure that you have a working Cross Compiler toolchain and LibXenon.</p> <p>1. Grab the sources from the git repository:</p> <p><code>git\u00a0clone</code> <p>2. Compile it using your cross compiler (depending on the name of your cross compiler, you may have to adjust the name after CROSS=):</p> <p><code>cd\u00a0xell</code></p> <p>If you want to build XeLL NON-2stages sourcecode:</p> <p><code>git\u00a0checkout\u00a0master</code></p> <p>Now compile it</p> <p><code>make\u00a0CROSS=powerpc64-unknown-linux-gnu-</code></p> <p>3a. Use the JTAG Hack or Reset Glitch Hack- you can even upgrade XeLL via USB.</p> <p>3b. Deprecated: load xell-readcd.bin using the readcd method and a patched King Kong game.</p> <p>3c. Deprecated: use the serial loader from Crawler360 to download xell-serial.bin to your Xbox 360 and run it.</p> <p>Category: Homebrew Software</p>"},{"location":"Linux/Lflash/","title":"LFlash","text":"<p>lflash is a program released into the public domain by Felix Domke. It is able to both read and write the flash if used under linux on the 360. Currently do not attempt to read / write to large block nands found in new arcade versions (256/512 MB internal memory), as it will corrupt your file/nand.</p>"},{"location":"Linux/Lflash/#source","title":"Source","text":"<p>The source is available on the free60 GIT Repository in the tools section.</p> <p>Category: Homebrew Software Category: Linux</p>"},{"location":"Linux/Linux_Kernel/","title":"Linux Kernel","text":"<p>There is a set of 7 patches available sent to the linuxppc mailing list on 08 March 2007, which have to be applied to Linux 2.6.20. If you're interested in kernel development and/or adding new features, please take a look at Linux Kernel Development.</p> <ul> <li>(patch 1/7) xenon: add PCI Vendor ID:   Microsoft</li> <li>(patch 2/7) xenon: add platform   support</li> <li>(patch 3/7) xenon: udbg support   (ugly)</li> <li>(patch 4/7) xenon: add southbridge ethernet   support</li> <li>(patch 5/7) xenon: add SATA   support</li> <li>(patch 6/7) xenon: add SMC   support</li> <li>(patch 7/7) xenon: add framebuffer support   (ugly)</li> </ul> <p>To run linux, you need to use XeLL Bootloader available right now. To compile the kernel, you need to set up a Cross compiler toolchain (unless you already have another PowerPC Linux machine).</p>"},{"location":"Linux/Linux_Kernel/#prerequisites","title":"Prerequisites","text":"<p>The minimal requirements for successfully cross compiling the Linux Kernel for your Xbox are (unverified):</p> <ul> <li>A machine running a Linux based OS (most likely your PC)</li> <li>Sources for the Linux Kernel</li> <li>The Xenon patch or patchset</li> <li>Binutils (targeting the powerpc architecture)</li> <li>GCC (targeting the powerpc architecture)</li> </ul>"},{"location":"Linux/Linux_Kernel/#configuring-and-compiling-the-kernel","title":"Configuring and Compiling the Kernel","text":"<ol> <li>Get the source for the Kernel from     kernel.org and unpack it.</li> </ol> <pre><code>cd /usr/src\nwget\u00a0http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.tar.bz2\ntar\u00a0-xvjf\u00a0linux-2.6.21.tar.bz2\n</code></pre> <ol> <li>Download and apply the Xenon patch/patchset matching your kernel.</li> </ol> <pre><code>cd\u00a0linux-2.6.21/\nfor\u00a0patch\u00a0in\u00a0pci_ids.h.diff\u00a0linux-2.6.21-xenon-cpu.diff\u00a0linux-2.6.21-xenon.diff\u00a0\\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0linux-2.6.21-xenon-enet.diff\u00a0linux-2.6.21-xenon-platform.diff\u00a0\\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0linux-2.6.21-xenon-sata.diff\u00a0linux-2.6.21-xenon-smc.diff\u00a0\\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0linux-2.6.21-xenon-ugly-fb.diff\u00a0linux-2.6.21-xenon-ugly-udbg.diff\u00a0\\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0interlace.diff\u00a0;\u00a0do\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0wget\u00a0http://op-co.de/xbox360/2.6.21/$patch\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0patch\u00a0-p1\u00a0&lt;\u00a0$patch\ndone\n</code></pre> <ol> <li> <p>Configure the Kernel. You can manually fetch a configuration file from the internet (e.g. here) and type:</p> <p><code>make\u00a0ARCH=powerpc\u00a0CROSS_COMPILE=powerpc64-unknown-linux-gnu-\u00a0oldconfig</code></p> <p>Of course, you can fine-tune your Kernel configuration to fit your needs using</p> <p><code>make\u00a0ARCH=powerpc\u00a0CROSS_COMPILE=powerpc64-unknown-linux-gnu-\u00a0menuconfig</code></p> </li> <li> <p>Build the Kernel by typing:</p> <p><code>make\u00a0ARCH=powerpc\u00a0CROSS_COMPILE=powerpc64-unknown-linux-gnu-\u00a0all</code></p> <p>If everything goes well, you will end up with a file arch/powerpc/boot/zImage.xenon containing the kernel which can be loaded by XeLL.</p> </li> </ol>"},{"location":"Linux/Linux_Kernel/#configuring-and-compiling-the-26388-kernel-experimental","title":"Configuring and Compiling the 2.6.38.8 Kernel (experimental)","text":"<p>Patches for recent kernels are available now, but considered highly experimental.</p> <ol> <li>Get the source for the Linux 2.6.38.8 Kernel from kernel.org and     unpack it.</li> </ol> <pre><code>wget\u00a0http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.38.8.tar.bz2\ntar\u00a0-xvjf\u00a0linux-2.6.38.8.tar.bz2\n</code></pre> <ol> <li> <p>Download and apply the experimental Xenon patch &amp; kernel config.</p> <pre><code>wget\u00a0-O\u00a0xenon_config\u00a0http://sourceforge.net/projects/free60/files/Linux%20Kernel/xenon_config/download\nwget\u00a0-O\u00a0patch-2.6.38.8-xbox0.11.1.diff\u00a0http://sourceforge.net/projects/free60/files/Linux%20Kernel/v2.6.38/patch-2.6.38.8-xbox0.11.1.diff/download\ncd\u00a0linux-2.6.38.8/\npatch\u00a0-p1\u00a0&lt;\u00a0../patch-2.6.38.8-xbox0.11.1.diff\ncp\u00a0../xenon_config\u00a0.config\n</code></pre> </li> <li> <p>Configure the Kernel.</p> <p><code>make\u00a0ARCH=powerpc\u00a0CROSS_COMPILE=powerpc64-unknown-linux-gnu-\u00a0menuconfig</code></p> </li> <li> <p>Build the Kernel by typing:</p> <p><code>make\u00a0ARCH=powerpc\u00a0CROSS_COMPILE=powerpc64-unknown-linux-gnu-\u00a0all</code></p> </li> </ol> <p>If everything goes well, you will end up with a file arch/powerpc/boot/zImage.xenon containing the kernel which can be loaded by the XeLL.</p> <p>Remember, these patches are Experimental!</p>"},{"location":"Linux/Linux_Kernel/#rootfilesystem-via-nfs","title":"Rootfilesystem via NFS","text":"<ol> <li> <p>Configure the kernel (CONFIG_CMDLINE in .config) for NFS (see     NFS-Tutorial for details) to match your local     setup.</p> <p>Example: <pre><code>CONFIG_CMDLINE=\"root=nfs video=xenonfb console=tty0 nfsroot=192.168.1.1:/mnt/nfsroot/xbox rw ip=dhcp\"\n</code></pre> 2.  Make sure that the IP Plug and Play (<code>CONFIG_IP_PNP*</code> in .config) options match your ip setup method.</p> </li> </ol>"},{"location":"Linux/Linux_Kernel/#pre-compiled-kernels","title":"Pre-compiled Kernels","text":"<p>http://home.comcast.net/~ssmurf/XeLL-Bootloader-sda2-v2.6.24.3.tar.gz (archive.org)</p> <p>Category: Linux</p>"},{"location":"Linux/Linux_Kernel_Development/","title":"Linux kernel development","text":"<p>Currently we have the following patches working against 2.6.33 kernel:</p> <ul> <li>PCI: adding PCI_VENDOR_ID_MICROSOFT (trivial)</li> <li>Xenon CPU: adding Xenon into cputable</li> <li>Xenon Platform: adding Interrupt controller, SMP support, setup</li> <li>Xenon SATA: adding the sata_xenon libata driver</li> <li>Xenon SMC: adding support for the SMC , including RTC and   communication with Ana.</li> <li>Xenon FB (ugly): adding support for tiled framebuffer</li> <li>Sound Support</li> <li>Pad Support</li> </ul> <p>User:Bertl is currently working on them. Please contact him you want to help on the IRC.</p> <p>Currently missing are:</p> <ul> <li>A sane way for framebuffer support.</li> <li>Better graphics support (changing resolutions etc.). We need to add   the GPU to the Xell OF tree so Linux detects it correctly. We can   probably reuse great part of the ATI/AMD open source drivers   available.</li> <li>IR remote support</li> </ul> <p>Category: Linux</p>"},{"location":"Linux/List_of_Unix_Distributions/","title":"List of Unix distributions","text":""},{"location":"Linux/List_of_Unix_Distributions/#live-cds","title":"Live CDs","text":"Title Description LiveCD Linux Live-CDs"},{"location":"Linux/List_of_Unix_Distributions/#install-scripts","title":"Install Scripts","text":"Title Description Ubuntu7.10 Linux Deboostrap-script for Ubuntu 7.10 \"Gutsy\" Ubuntu11.10 Linux Deboostrap-script for Ubuntu 11.10 \"Oneiric\" Debian-etch Linux Deboostrap-script for Debian 4 \"etch\" Debian-lenny Linux Deboostrap-script for Debian 5 \"lenny\" Debian-squeeze Linux Deboostrap-script for Debian 6 \"squeeze\" <p>Category: Linux</p>"},{"location":"Linux/Distros/","title":"Linux distributions","text":"<ul> <li>LiveCD</li> <li>Ubuntu 7.10</li> <li>Ubuntu 11.10</li> <li>Debian-etch</li> <li>Debian-lenny</li> <li>Debian-squeeze</li> </ul> <p>Category: Linux</p>"},{"location":"Linux/Distros/LiveCD/","title":"Live CDs","text":"<p>Thanks to Cpasjuste and stonersmurf, we now have three Live-CDs!</p> <p>See First Steps for a step-by-step tutorial on running them.</p> <p>Note: Samsung drives are supported on the Gentoo LiveCD BETA v2, only.</p> <ul> <li>Gentoo Minimal 2006.1 Get it from here!</li> </ul> <p>https://downloads.sourceforge.net/free60/gentoo-xenon-minimal-2006.1.tar.bz2 This LiveCD is based on the minimal Gentoo Live-CD, so it doesn't offer X. But download size is reasonable at around 90MB.</p> <ul> <li>Gentoo LiveCD BETA Get it from here!</li> </ul> <p>http://downloads.sourceforge.net/free60/gentoo-livecd-xenon-beta.tar.bz2 This LiveCD is based on the BETA Gentoo LiveCD. It includes our X.org framebuffer driver and a Gnome Desktop environment. Download size is around 600MB.</p> <ul> <li>Gentoo LiveCD BETA v2 Get it from here!</li> </ul> <p>http://downloads.sourceforge.net/free60/gentoo-livecd-xenon-beta-v2.iso</p> <p>md5 sum</p> <p>Release Notes</p> <p>It\u00a0is\u00a0the\u00a0second\u00a0revision\u00a0of\u00a0the\u00a0Gentoo\u00a0LiveCD\u00a0BETA\u00a0including\u00a0the\u00a0latest\u00a0kernel\u00a0updates\u00a0for\u00a0the\u00a0Xbox\u00a0360.\u00a0Download\u00a0size\u00a0is\u00a0around\u00a0621MB.</p> <p>Category: Linux</p>"},{"location":"Linux/Distros/Debian/etch/","title":"Install Debian 4 \"Etch\" from the Gentoo LiveCD","text":"<p>Warning: This script will WIPE your Xbox 360 harddisk (/dev/sda) and install Debian Etch</p> <p><code>debianinstall.sh</code> will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the Gentoo LiveCD v2. You will need a DHCP-server on your network for this script.</p>"},{"location":"Linux/Distros/Debian/etch/#how-do-i-run-it","title":"How do I run it","text":"<p>Click \"Application &gt; Accessories &gt; Terminal\" and type the following commands:</p> <p>Note: Do not use this, use the modified bash code posted at the bottom of this page.</p> <pre><code>sudo\u00a0su\nwget\u00a0https://web.archive.org/web/20121104151039/http://home.comcast.net/~ssmurf/debianinstall.sh\nsh\u00a0./debianinstall.sh\n</code></pre> <p>Reboot the 360 when you are told. Boot with http://home.comcast.net/~ssmurf/XeLL-Bootloader-sda2-v2.6.24.3.tar.gz and login as root. You will be asked for a new password. The rest of the installation will start automatically. The download is about 600Mb. Select xenosfb when the script asks for Xserver-driver.</p>"},{"location":"Linux/Distros/Debian/etch/#debianinstallsh","title":"debianinstall.sh","text":"<pre><code>#!/bin/bash\ndd\u00a0if=/dev/zero\u00a0of=/dev/sda\u00a0bs=512\u00a0count=1\nsfdisk\u00a0/dev/sda\u00a0&lt;&lt;\u00a0EOF\n,124,S\n,,L\nEOF\nmkfs.ext3\u00a0/dev/sda2\nmkswap\u00a0/dev/sda1\nsync;\u00a0sync;\u00a0sync\nswapon\u00a0/dev/sda1\nmkdir\u00a0/mnt/debian\nmount\u00a0/dev/sda2\u00a0/mnt/debian\ncd\u00a0/mnt/debian\nmkdir\u00a0/mnt/debian/work\ncd\u00a0/mnt/debian/work\nwget\u00a0--no-check-certificate\u00a0https://www.securehost.com/mirror/debian/pool/main/d/debootstrap/debootstrap_0.3.3.2etch1_all.deb\nar\u00a0-xf\u00a0debootstrap_0.3.3.2etch1_all.deb\ncd\u00a0/mnt/debian\nzcat\u00a0&lt;\u00a0/mnt/debian/work/data.tar.gz\u00a0|\u00a0tar\u00a0xv\nexport\u00a0DEBOOTSTRAP_DIR=/mnt/debian/usr/lib/debootstrap\nexport\u00a0PATH=$PATH:/mnt/debian/usr/sbin\ndebootstrap\u00a0--arch\u00a0powerpc\u00a0etch\u00a0/mnt/debian\u00a0ftp://archive.debian.org/debian/\necho\u00a0Xenon\u00a0&gt;\u00a0/mnt/debian/etc/hostname\ncat\u00a0&gt;\u00a0/mnt/debian/etc/fstab\u00a0&lt;&lt;\u00a0EOF\n/dev/sda2\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ext3\u00a0\u00a0\u00a0\u00a0\u00a0defaults\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00\n/dev/sda1\u00a0\u00a0\u00a0\u00a0\u00a0none\u00a0\u00a0\u00a0\u00a0swap\u00a0\u00a0\u00a0\u00a0sw\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00\nproc\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/proc\u00a0\u00a0\u00a0\u00a0proc\u00a0\u00a0\u00a0\u00a0defaults\u00a0\u00a00\u00a0\u00a0\u00a00\nEOF\ncat\u00a0&gt;\u00a0/mnt/debian/etc/network/interfaces\u00a0&lt;&lt;\u00a0EOF\niface\u00a0lo\u00a0inet\u00a0loopback\nauto\u00a0lo\nauto\u00a0eth0\niface\u00a0eth0\u00a0inet\u00a0dhcp\nEOF\ncat\u00a0&gt;\u00a0/mnt/debian/etc/apt/sources.list\u00a0&lt;&lt;\u00a0EOF\ndeb\u00a0archive.debian.org/debian/\u00a0\u00a0etch\u00a0main\u00a0contrib\u00a0non-free\nEOF\n#Change\u00a0root-pwd\u00a0inside\u00a0chroot\nchroot\u00a0/mnt/debian\necho\u00a0-e\u00a0\"xbox\\nxbox\"\u00a0|\u00a0(passwd\u00a0--stdin\u00a0$USER)\nexit\ncp\u00a0/mnt/debian/root/.bashrc\u00a0/mnt/debian/root/.bashrc.orginal\ncat\u00a0&gt;&gt;\u00a0/mnt/debian/root/.bashrc\u00a0&lt;&lt;\u00a0EOF\npasswd\napt-get\u00a0update\napt-get\u00a0install\u00a0ntp\u00a0wget\u00a0-y\u00a0--force-yes\napt-get\u00a0install\u00a0x-window-system\u00a0-y\u00a0--force-yes\naptitude\u00a0install\u00a0gnome\u00a0-y\napt-get\u00a0install\u00a0build-essential\u00a0firefox\u00a0gftp\u00a0khexedit\u00a0console-tools\u00a0-y\u00a0--force-yes\necho\u00a0\"AVAHI_DAEMON_START=0\"\u00a0&gt;\u00a0/etc/default/avahi-daemon\n/etc/init.d/networking\u00a0restart\ncd\u00a0/usr/lib/xorg/modules/drivers/\nrm\u00a0-r\u00a0-f\u00a0*\nwget\u00a0https://web.archive.org/web/20141026185511/http://home.comcast.net/~ssmurf/xenosfb_drv.so\ncd\u00a0/etc/X11/\nrm\u00a0-r\u00a0-f\u00a0xorg.conf\nwget\u00a0https://web.archive.org/web/20141026185511/http://home.comcast.net/~ssmurf/xenosfb_drv.so\nmkdir\u00a0/lib/modules/2.6.21.1\ntouch\u00a0/lib/modules/2.6.21.1/modules.dep\necho\u00a0\"\"\u00a0&gt;\u00a0/etc/gdm/gdm.conf-custom\nsed\u00a0-i\u00a0'/security/\u00a0a\\AllowRoot=true'\u00a0/etc/gdm/gdm.conf\nsed\u00a0-i\u00a0's/#LEDS=+num/LEDS=+num/'\u00a0/etc/console-tools/config\nupdate-rc.d\u00a0-f\u00a0hwclock.sh\u00a0remove\nupdate-rc.d\u00a0-f\u00a0festival\u00a0remove\nupdate-rc.d\u00a0-f\u00a0portmap\u00a0remove\nupdate-rc.d\u00a0-f\u00a0cupsys\u00a0remove\nupdate-rc.d\u00a0-f\u00a0spamassassin\u00a0remove\nupdate-rc.d\u00a0-f\u00a0alsa-utils\u00a0remove\nrm\u00a0/root/.bashrc\nmv\u00a0/root/.bashrc.orginal\u00a0/root/.bashrc\n/etc/init.d/gdm\u00a0start\nEOF\necho\u00a0\"Base\u00a0System\u00a0Install\u00a0Complete!\"\necho\u00a0\"You\u00a0may\u00a0now\u00a0shutdown\u00a0the\u00a0xbox360.\"\necho\u00a0\"Then\u00a0continue\u00a0the\u00a0install\u00a0by\u00a0booting\u00a0the\u00a0Xell-Bootloader-sda2.\"\n</code></pre> <p>Category: Linux</p>"},{"location":"Linux/Distros/Debian/lenny/","title":"Install Debian 5 \"Lenny\" from the Gentoo LiveCD","text":"<p>Warning: This script will WIPE your Xbox 360 harddisk (/dev/sda) and install Debian Lenny</p> <p>lennyinstall.sh will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the Gentoo LiveCD v2. You will need a DHCP-server on your network for this script.</p>"},{"location":"Linux/Distros/Debian/lenny/#how-do-i-run-it","title":"How do I run it","text":"<p>Click \"Application &gt; Accessories &gt; Terminal\" and type the following commands:</p> <p><code>sh sudo\u00a0su wget\u00a0https://web.archive.org/web/20141025060051/http://home.comcast.net/~ssmurf/lennyinstall.sh sh\u00a0./lennyinstall.sh</code></p> <p>Reboot the 360 when you are told. Boot with http://home.comcast.net/~ssmurf/XeLL-Bootloader-sda2-v2.6.24.3.tar.gz and login as root. You will be asked for a new password. The rest of the installation will start automatically. The download is about 600Mb. Select xenosfb when the script asks for Xserver-driver.</p> <p>Note: Currently unstable, resulted in xorg crashing and there is no network activity. Debian Etch works, same with Ubuntu 7.10.</p>"},{"location":"Linux/Distros/Debian/lenny/#lennyinstallsh","title":"lennyinstall.sh","text":"<pre><code>#!/bin/bash\n#\u00a0set\u00a0the\u00a0date\u00a0to\u00a0anything\u00a0except\u00a01/1/1970\u00a0since\u00a0this\u00a0causes\u00a0issues\n#\u00a0time\u00a0is\u00a0now\u00a0also\u00a0set\u00a0after\u00a0first\u00a0boot\u00a0by\u00a0.bashrc\u00a0script\u00a0below\ndate\u00a0-s\u00a01/1/2009\ndd\u00a0if=/dev/zero\u00a0of=/dev/sda\u00a0bs=512\u00a0count=1\nsfdisk\u00a0/dev/sda\u00a0&lt;&lt;\u00a0EOF\n,124,S\n,,L\nEOF\nmkfs.ext3\u00a0/dev/sda2\nmkswap\u00a0/dev/sda1\nsync;\u00a0sync;\u00a0sync\nswapon\u00a0/dev/sda1\nmkdir\u00a0/mnt/debian\nmount\u00a0/dev/sda2\u00a0/mnt/debian\ncd\u00a0/mnt/debian\nmkdir\u00a0/mnt/debian/work\ncd\u00a0/mnt/debian/work\nwget\u00a0`&lt;http://ftp.us.debian.org/debian/pool/main/d/debootstrap/debootstrap_1.0.23_all.deb&gt;\nar\u00a0-xf\u00a0debootstrap_1.0.23_all.deb\ncd\u00a0/mnt/debian\nzcat\u00a0&lt;\u00a0/mnt/debian/work/data.tar.gz\u00a0|\u00a0tar\u00a0xv\ncp\u00a0/mnt/debian/usr/sbin/debootstrap\u00a0/mnt/debian/usr/share/debootstrap\u00a0\u00a0\u00a0\u00a0\u00a0\nexport\u00a0DEBOOTSTRAP_DIR=/mnt/debian/usr/share/debootstrap\nexport\u00a0PATH=$PATH:/mnt/debian/usr/share/debootstrap\ndebootstrap\u00a0--arch\u00a0powerpc\u00a0lenny\u00a0/mnt/debian\u00a0`&lt;ftp://mirrors.kernel.org/debian/&gt;\necho\u00a0Xenon\u00a0&gt;\u00a0/mnt/debian/etc/hostname\ncat\u00a0&gt;\u00a0/mnt/debian/etc/fstab\u00a0&lt;&lt;\u00a0EOF\n/dev/sda2\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ext3\u00a0\u00a0\u00a0\u00a0\u00a0defaults\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00\n/dev/sda1\u00a0\u00a0\u00a0\u00a0\u00a0none\u00a0\u00a0\u00a0\u00a0swap\u00a0\u00a0\u00a0\u00a0sw\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00\nproc\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/proc\u00a0\u00a0\u00a0\u00a0proc\u00a0\u00a0\u00a0\u00a0defaults\u00a0\u00a00\u00a0\u00a0\u00a00\nEOF\ncat\u00a0&gt;\u00a0/mnt/debian/etc/network/interfaces\u00a0&lt;&lt;\u00a0EOF\niface\u00a0lo\u00a0inet\u00a0loopback\nauto\u00a0lo\nauto\u00a0eth0\niface\u00a0eth0\u00a0inet\u00a0dhcp\nEOF\ncat\u00a0&gt;\u00a0/mnt/debian/etc/apt/sources.list\u00a0&lt;&lt;\u00a0EOF\ndeb\u00a0`&lt;ftp://mirrors.kernel.org/debian/&gt;`\u00a0lenny\u00a0main\u00a0contrib\u00a0non-free\nEOF\n#Change\u00a0root-pwd\u00a0inside\u00a0chroot\nchroot\u00a0/mnt/debian\necho\u00a0-e\u00a0\"xbox\\nxbox\"\u00a0|\u00a0(passwd\u00a0--stdin\u00a0$USER)\nexit\ncp\u00a0/mnt/debian/root/.bashrc\u00a0/mnt/debian/root/.bashrc.orginal\ncat\u00a0&gt;&gt;\u00a0/mnt/debian/root/.bashrc\u00a0&lt;&lt;\u00a0EOF\npasswd\napt-get\u00a0update\napt-get\u00a0install\u00a0ntp\u00a0wget\u00a0-y\u00a0--force-yes\napt-get\u00a0install\u00a0x-window-system\u00a0-y\u00a0--force-yes\naptitude\u00a0install\u00a0gnome\u00a0-y\napt-get\u00a0install\u00a0build-essential\u00a0firefox\u00a0gftp\u00a0khexedit\u00a0console-tools\u00a0-y\u00a0--force-yes\ncd\u00a0/usr/lib/xorg/modules/drivers/\nrm\u00a0-r\u00a0-f\u00a0*\nwget\u00a0`&lt;http://lilstevie.com/assets/xbox360/xenosfb_drv.so&gt;\ncd\u00a0/etc/X11/\nrm\u00a0-r\u00a0-f\u00a0xorg.conf\nwget\u00a0`&lt;https://web.archive.org/web/20141026190741/http://home.comcast.net/~ssmurf/xorg.conf&gt;\nmkdir\u00a0/lib/modules/2.6.21.1\ntouch\u00a0/lib/modules/2.6.21.1/modules.dep\necho\u00a0\"\"\u00a0&gt;\u00a0/etc/gdm/gdm.conf-custom\nsed\u00a0-i\u00a0'/security/\u00a0a\\AllowRoot=true'\u00a0/etc/gdm/gdm.conf\nsed\u00a0-i\u00a0's/#LEDS=+num/LEDS=+num/'\u00a0/etc/console-tools/config\nrm\u00a0/root/.bashrc\nmv\u00a0/root/.bashrc.orginal\u00a0/root/.bashrc\n/etc/init.d/gdm\u00a0start\nEOF\necho\u00a0\"Base\u00a0System\u00a0Install\u00a0Complete!\"\necho\u00a0\"You\u00a0may\u00a0now\u00a0shutdown\u00a0the\u00a0xbox360.\"\necho\u00a0\"Then\u00a0continue\u00a0the\u00a0install\u00a0by\u00a0booting\u00a0the\u00a0Xell-Bootloader-sda2.\"\n</code></pre> <p>Category: Linux</p>"},{"location":"Linux/Distros/Debian/squeeze/","title":"Install Debian 6 \"Squeeze\" from a Linux LiveCD","text":"<p>Warning: This script will WIPE your Xbox 360 harddisk (/dev/sda) and install Debian 6</p> <p>If you have XeXmenu or another dashboard homebrew on that drive, you will loose it all: Follow these instructions only if you understand what you are doing.</p> <p><code>debian_squeeze.sh</code> will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the a Linux LiveCD. You will need a DHCP-server on your network for this script.</p>"},{"location":"Linux/Distros/Debian/squeeze/#how-do-i-run-it","title":"How do I run it?","text":"<p>Click \"Application &gt; Accessories &gt; Terminal\" and type the following commands:</p> <p><code>sh sudo\u00a0su wget\u00a0`&lt;http://file.libxenon.org/free60/linux/script/debian_squeeze.sh&gt; sh\u00a0./debian_squeeze.sh</code></p> <p>Reboot the 360 when you are told. Boot with (Linux kernel binary)[http://file.libxenon.org/latest_kern&gt;], supply correct \"root=\" parameter via kboot.conf (*kboot currently only supported via xell-reloaded-testing builds), boot the kernel/system and login as user: xbox, password: xbox. Have fun :) (If you are not having fun, let us know about the errors you are experiencing.)</p>"},{"location":"Linux/Distros/Debian/squeeze/#debootstrapping-script","title":"debootstrapping script","text":"<p>debian_squeeze.sh <pre><code>#!/bin/bash\n#\u00a0set\u00a0the\u00a0date\u00a0to\u00a0anything\u00a0except\u00a01/1/1970\u00a0since\u00a0this\u00a0causes\u00a0issues\n#\u00a0time\u00a0is\u00a0now\u00a0also\u00a0set\u00a0after\u00a0first\u00a0boot\u00a0by\u00a0.bashrc\u00a0script\u00a0below\ndate\u00a0-s\u00a01/1/2009\n#\u00a0if\u00a0/dev/sda\u00a0is\u00a0mounted\u00a0then\u00a0paritions\u00a0get\u00a0wiped\u00a0by\u00a0dd\u00a0but\u00a0sfdisk\u00a0fails!\nswapoff\u00a0/dev/sda1\numount\u00a0/mnt/debian\n#\u00a0partition\u00a0and\u00a0mkfs\u00a0hdd\u00a0(all\u00a0data\u00a0is\u00a0lost!)\ndd\u00a0if=/dev/zero\u00a0of=/dev/sda\u00a0bs=512\u00a0count=1\nsfdisk\u00a0/dev/sda\u00a0&lt;&lt;\u00a0EOF\n,124,S\n,,L\nEOF\ndd\u00a0if=/dev/zero\u00a0of=/dev/sda2\u00a0bs=512\u00a0count=1\nmkfs.ext3\u00a0/dev/sda2\nmkswap\u00a0/dev/sda1\nsync;\u00a0sync;\u00a0sync\nswapon\u00a0/dev/sda1\n#\u00a0setup\u00a0paths\nmkdir\u00a0/mnt/debian\nmount\u00a0/dev/sda2\u00a0/mnt/debian\ncd\u00a0/mnt/debian\nmkdir\u00a0/mnt/debian/work\ncd\u00a0/mnt/debian/work\n#\u00a0download\u00a0extract\u00a0and\u00a0run\u00a0debootstrap\nwget\u00a0http://ftp.nl.debian.org/debian/pool/main/d/debootstrap/debootstrap_1.0.38_all.deb\nar\u00a0-xf\u00a0debootstrap_1.0.38_all.deb\ncd\u00a0/mnt/debian\nzcat\u00a0&lt;\u00a0/mnt/debian/work/data.tar.gz\u00a0|\u00a0tar\u00a0xv\nexport\u00a0DEBOOTSTRAP_DIR=/mnt/debian/usr/share/debootstrap\nexport\u00a0PATH=$PATH:/mnt/debian/usr/sbin\ndebootstrap\u00a0--arch\u00a0powerpc\u00a0squeeze\u00a0/mnt/debian\u00a0ftp://mirrors.kernel.org/debian/\n#\u00a0create\u00a0needed\u00a0files\u00a0on\u00a0hdd\necho\u00a0Xenon\u00a0&gt;\u00a0/mnt/debian/etc/hostname\ncat\u00a0&gt;\u00a0/mnt/debian/etc/fstab\u00a0&lt;&lt;\u00a0EOF\n/dev/sda2\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ext3\u00a0\u00a0\u00a0\u00a0\u00a0defaults\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00\n/dev/sda1\u00a0\u00a0\u00a0\u00a0\u00a0none\u00a0\u00a0\u00a0\u00a0swap\u00a0\u00a0\u00a0\u00a0sw\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00\nproc\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/proc\u00a0\u00a0\u00a0\u00a0proc\u00a0\u00a0\u00a0\u00a0defaults\u00a0\u00a00\u00a0\u00a0\u00a00\nEOF\ncat\u00a0&gt;\u00a0/mnt/debian/etc/network/interfaces\u00a0&lt;&lt;\u00a0EOF\niface\u00a0lo\u00a0inet\u00a0loopback\nauto\u00a0lo\nauto\u00a0eth0\niface\u00a0eth0\u00a0inet\u00a0dhcp\nEOF\ncat\u00a0&gt;\u00a0/mnt/debian/etc/apt/sources.list\u00a0&lt;&lt;\u00a0EOF\ndeb\u00a0ftp://mirrors.kernel.org/debian/&gt;squeeze\u00a0main\u00a0contrib\u00a0non-free\nEOF\n#Change\u00a0root-pwd\u00a0to\u00a0\"xbox\"\u00a0inside\u00a0chroot\nchroot\u00a0/mnt/debian\u00a0echo\u00a0\"root:xbox\"\u00a0|\u00a0chroot\u00a0/mnt/debian\u00a0/usr/sbin/chpasswd\n#\u00a0Add\u00a0user:\u00a0xbox\u00a0with\u00a0password:\u00a0xbox\nchroot\u00a0/mnt/debian\u00a0/usr/sbin/useradd\u00a0-m\u00a0-d\u00a0/home/xbox\u00a0-p\u00a0paRRy2CC47LXY\u00a0xbox\n#\u00a0create\u00a0.second_stage\u00a0script\u00a0on\u00a0hdd\ncat\u00a0&gt;&gt;\u00a0/mnt/debian/root/.second_stage\u00a0&lt;&lt;\u00a0EOF\n#!/bin/bash\ndate\u00a0-s\u00a01/1/2009\napt-get\u00a0update\napt-get\u00a0install\u00a0ntp\u00a0wget\u00a0openssh-server\u00a0locales\u00a0-y\u00a0--force-yes\ndpkg-reconfigure\u00a0locales\napt-get\u00a0install\u00a0gnome\u00a0-y\necho\u00a0\"AVAHI_DAEMON_START=0\"\u00a0&gt;\u00a0/etc/default/avahi-daemon\n/etc/init.d/networking\u00a0restart\ncd\u00a0/usr/lib/xorg/modules/drivers/\nwget\u00a0-O\u00a0xenosfb_drv.so\u00a0http://file.libxenon.org/free60/linux/xenosfb/xenosfb_drv.so_squeeze\ncd\u00a0/etc/X11/\nwget\u00a0http://file.libxenon.org/free60/linux/xenosfb/xorg.conf\nrm\u00a0-r\u00a0-f\u00a0/work/\necho\u00a0\"Installation\u00a0completed.\"\necho\u00a0\"To\u00a0boot\u00a0the\u00a0system:\u00a0Reboot\u00a0and\u00a0load\u00a0the\u00a0kernel\u00a0with\u00a0correct\u00a0root=\u00a0params.\"\necho\u00a0\"You\u00a0should\u00a0be\u00a0greeted\u00a0by\u00a0a\u00a0fresh\u00a0install\u00a0of\u00a0Debian\u00a06\u00a0Squeeze\"\nEOF\nchmod\u00a0a+x\u00a0/mnt/debian/root/.second_stage\n#\u00a0Execute\u00a0second\u00a0part\u00a0of\u00a0installation\u00a0in\u00a0the\u00a0chroot\u00a0environment\nmount\u00a0-t\u00a0proc\u00a0none\u00a0/mnt/debian/proc\nmount\u00a0--rbind\u00a0/dev\u00a0/mnt/debian/dev\ncp\u00a0-L\u00a0/etc/resolv.conf\u00a0/mnt/debian/etc/resolv.conf\nchroot\u00a0/mnt/debian\u00a0/root/.second_stage\numount\u00a0/mnt/debian/dev\u00a0/mnt/debian/proc\u00a0/mnt/debian\n</code></pre></p>"},{"location":"Linux/Distros/Debian/squeeze/#fix-possible-xorg-fail","title":"Fix possible xorg fail","text":"<p>After it has finished installing and has rebooted into gnome open a new shell by typing Ctrl+Alt+F6 or Ctrl+Alt+F1 and type,</p> <p><code>sudo\u00a0dpkg-reconfigure\u00a0xserver-xorg</code></p> <p>Then follow the instructions below.</p> <ol> <li>Attempt to autodetect video hardware? &gt; No</li> <li>X Server Driver: Xenosfb</li> <li>Generic Video Card &gt; Enter</li> <li>Video card\u2019s bus identifier: Press enter for default</li> <li>Amount of memory: Press enter for default</li> <li>Use kernel framebuffer device interface? &gt; Yes</li> <li>Autodetect keyboard layout? &gt; Yes</li> <li>Keyboard layout: us</li> <li>XKB rule set to use: xorg</li> <li>Keyboard model: choose your rule set based on the options</li> <li>Keyboard variant: leave blank if you\u2019re in the U.S.</li> <li>Keyboard options: Leave as default</li> <li>Mouse Protocol: ImPS/2</li> <li>Emulate a 3 button mouse? &gt; Your choice</li> <li>Xorg server modules: Default</li> <li>Write default Files section to configuration file? &gt; Yes</li> <li>Attempt monitor detection? &gt; Yes</li> <li>Use generic monitor if it doesn\u2019t detect it.</li> <li>Video modes to be used by the X server: 1280x768 (1024x768 if garbled)</li> <li>Method for selecting the monitor characteristics: Medium</li> <li>Monitors best video mode: Choose what\u2019s best for your monitor.</li> <li>Write monitor sync ranges to the configuration file? &gt; Yes</li> <li>Desired default color depth in bits: 24.</li> </ol> <p>After that go back to gnome by typing Ctrl+Alt+F7.</p> <p>Reboot X by typing Ctrl+Alt+Backspace.</p> <p>Category: Linux</p>"},{"location":"Linux/Distros/Ubuntu/","title":"Ubuntu","text":"<p>Ubuntu is a computer operating system based on the Debian GNU/Linux distribution and is distributed as free and open source software with additional proprietary software available.</p> <p>Ubuntu is composed of many software packages, of which the vast majority are distributed under a free software license (also known as open source). The main license used is the GNU General Public License (GNU GPL) which, along with the GNU Lesser General Public License (GNU LGPL), explicitly declares that users are free to run, copy, distribute, study, change, develop and improve the software.</p> <p>Canonical, the company that endorses the Ubuntu project (as well as Kubuntu and other Ubuntu-based derivations) releases new versions of Ubuntu every six months and supports Ubuntu for eighteen months by providing security fixes, patches to critical bugs and minor updates to programs. LTS (Long Term Support) versions, which are released every two years, are supported for three years on the desktop and five years for servers. The latest version of Ubuntu, 10.04 (Lucid Lynx), is such an LTS version, and was released on April 29, 2010.</p> <p>It is possible to boot Ubuntu by using an Xbox 360 which has had the SMC Hack applied.</p> <p>You find the current working Ubuntu-installationscript here: Ubuntu 7.10</p> <p>Category: Linux</p>"},{"location":"Linux/Distros/Ubuntu/11_10/","title":"Install Ubuntu 11.10 from a Linux LiveCD","text":"<p>WARNING: This script will WIPE your Xbox 360 internal harddisk (/dev/sda) and install Ubuntu 11.10</p> <p>If you have XeXmenu or another dashboard homebrew on that drive, you will loose it all: Follow these instructions only if you understand what you are doing.</p> <p>ubuntu_oneiric.sh will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the a Linux LiveCD. You will need a DHCP-server on your network for this script.</p> <p>How do I run it?</p> <p>Click \"Application &gt; Accessories &gt; Terminal\" and type the following commands:</p> <p><code>sudo\u00a0su</code> <code>wget</code>http://file.libxenon.org/free60/linux/script/ubuntu_oneiric.sh <code>sh\u00a0./ubuntu_oneiric.sh</code></p> <p>Reboot the 360 when you are told. Boot with http://file.libxenon.org/latest_kern, supply correct \"root=\" parameter via kboot.conf (*kboot currently only supported via xell-reloaded-testing builds), boot the kernel/system and login as user: xbox, password: xbox. Have fun :) (If you are not having fun, let us know about the errors you are experiencing.)</p>"},{"location":"Linux/Distros/Ubuntu/11_10/#debootstrapping-script","title":"debootstrapping script","text":"<p>ubuntu_oneiric.sh #!/bin/bash</p> <p><code>#\u00a0set\u00a0the\u00a0date\u00a0to\u00a0anything\u00a0except\u00a01/1/1970\u00a0since\u00a0this\u00a0causes\u00a0issues</code> <code>#\u00a0time\u00a0is\u00a0now\u00a0also\u00a0set\u00a0after\u00a0first\u00a0boot\u00a0by\u00a0.bashrc\u00a0script\u00a0below</code> <code>date\u00a0-s\u00a01/1/2009</code> <code>#\u00a0if\u00a0/dev/sda\u00a0is\u00a0mounted\u00a0then\u00a0paritions\u00a0get\u00a0wiped\u00a0by\u00a0dd\u00a0but\u00a0sfdisk\u00a0fails!</code> <code>swapoff\u00a0/dev/sda1</code> <code>umount\u00a0/mnt/ubuntu</code> <code>#\u00a0partition\u00a0and\u00a0mkfs\u00a0hdd\u00a0(all\u00a0data\u00a0is\u00a0lost!)</code> <code>dd\u00a0if=/dev/zero\u00a0of=/dev/sda\u00a0bs=512\u00a0count=1</code> <code>sfdisk\u00a0/dev/sda\u00a0&lt;&lt;\u00a0EOF</code> <code>,124,S</code> <code>,,L</code> <code>EOF</code> <code>dd\u00a0if=/dev/zero\u00a0of=/dev/sda2\u00a0bs=512\u00a0count=1</code> <code>mkfs.ext3\u00a0/dev/sda2</code> <code>mkswap\u00a0/dev/sda1</code> <code>sync;\u00a0sync;\u00a0sync</code> <code>swapon\u00a0/dev/sda1</code> <code>#\u00a0setup\u00a0paths</code> <code>mkdir\u00a0/mnt/ubuntu</code> <code>mount\u00a0/dev/sda2\u00a0/mnt/ubuntu</code> <code>cd\u00a0/mnt/ubuntu</code> <code>mkdir\u00a0/mnt/ubuntu/work</code> <code>cd\u00a0/mnt/ubuntu/work</code> <code>#\u00a0download\u00a0extract\u00a0and\u00a0run\u00a0debootstrap</code> <code>wget</code>http://ftp.nl.debian.org/debian/pool/main/d/debootstrap/debootstrap_1.0.38_all.deb <code>ar\u00a0-xf\u00a0debootstrap_1.0.38_all.deb</code> <code>cd\u00a0/mnt/ubuntu</code> <code>zcat\u00a0&lt;\u00a0/mnt/ubuntu/work/data.tar.gz\u00a0|\u00a0tar\u00a0xv</code> <code>export\u00a0DEBOOTSTRAP_DIR=/mnt/ubuntu/usr/share/debootstrap</code> <code>export\u00a0PATH=$PATH:/mnt/ubuntu/usr/sbin</code> <code>debootstrap\u00a0--arch\u00a0powerpc\u00a0oneiric\u00a0/mnt/ubuntu</code>http://ports.ubuntu.com/ <code>#\u00a0create\u00a0needed\u00a0files\u00a0on\u00a0hdd</code> <code>echo\u00a0Xenon\u00a0&gt;\u00a0/mnt/ubuntu/etc/hostname</code> <code>cat\u00a0&gt;\u00a0/mnt/ubuntu/etc/fstab\u00a0&lt;&lt;\u00a0EOF</code> <code>/dev/sda2\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ext3\u00a0\u00a0\u00a0\u00a0\u00a0defaults\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00</code> <code>/dev/sda1\u00a0\u00a0\u00a0\u00a0\u00a0none\u00a0\u00a0\u00a0\u00a0swap\u00a0\u00a0\u00a0\u00a0sw\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00</code> <code>proc\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/proc\u00a0\u00a0\u00a0\u00a0proc\u00a0\u00a0\u00a0\u00a0defaults\u00a0\u00a00\u00a0\u00a0\u00a00</code> <code>EOF</code> <code>cat\u00a0&gt;\u00a0/mnt/ubuntu/etc/network/interfaces\u00a0&lt;&lt;\u00a0EOF</code> <code>iface\u00a0lo\u00a0inet\u00a0loopback</code> <code>auto\u00a0lo</code> <code>auto\u00a0eth0</code> <code>iface\u00a0eth0\u00a0inet\u00a0dhcp</code> <code>EOF</code> <code>cat\u00a0&gt;\u00a0/mnt/ubuntu/etc/apt/sources.list\u00a0&lt;&lt;\u00a0EOF</code> <code>#\u00a0Main</code> <code>deb</code>http://ports.ubuntu.com/ubuntu-ports/<code>oneiric\u00a0main\u00a0restricted</code> <code>deb</code>http://ports.ubuntu.com/ubuntu-ports/<code>oneiric\u00a0universe\u00a0multiverse</code> <code>#\u00a0Updates</code> <code>deb</code>http://ports.ubuntu.com/ubuntu-ports/<code>oneiric-updates\u00a0main\u00a0restricted</code> <code>deb-src</code>http://ports.ubuntu.com/ubuntu-ports/<code>oneiric-updates\u00a0restricted</code> <code>deb</code>http://ports.ubuntu.com/ubuntu-ports/<code>oneiric-updates\u00a0universe\u00a0multiverse</code> <code>#\u00a0Security</code> <code>deb</code>http://ports.ubuntu.com/ubuntu-ports/<code>oneiric-security\u00a0main\u00a0restricted</code> <code>deb-src</code>http://ports.ubuntu.com/ubuntu-ports/<code>oneiric-security\u00a0main\u00a0restricted</code> <code>deb</code>http://ports.ubuntu.com/ubuntu-ports/<code>oneiric-security\u00a0universe\u00a0multiverse</code> <code>deb-src</code>http://ports.ubuntu.com/ubuntu-ports/<code>oneiric-security\u00a0universe\u00a0multiverse</code> <code>EOF</code> <code>#Change\u00a0root-pwd\u00a0to\u00a0\"xbox\"\u00a0inside\u00a0chroot</code> <code>chroot\u00a0/mnt/ubuntu\u00a0echo\u00a0\"root:xbox\"\u00a0|\u00a0chroot\u00a0/mnt/ubuntu\u00a0/usr/sbin/chpasswd</code> <code>#\u00a0Add\u00a0user:\u00a0xbox\u00a0with\u00a0password:\u00a0xbox\u00a0and\u00a0add\u00a0it\u00a0to\u00a0the\u00a0sudo-group</code> <code>chroot\u00a0/mnt/ubuntu\u00a0/usr/sbin/useradd\u00a0-m\u00a0-d\u00a0/home/xbox\u00a0-p\u00a0paRRy2CC47LXY\u00a0xbox</code> <code>chroot\u00a0/mnt/ubuntu\u00a0/usr/sbin/adduser\u00a0xbox\u00a0sudo</code> <code>#\u00a0create\u00a0.second_stage\u00a0script\u00a0on\u00a0hdd</code> <code>cat\u00a0&gt;&gt;\u00a0/mnt/ubuntu/root/.second_stage\u00a0&lt;&lt;\u00a0EOF</code> <code>#!/bin/bash</code> <code>date\u00a0-s\u00a01/1/2009</code> <code>apt-get\u00a0update</code> <code>apt-get\u00a0install\u00a0ntp\u00a0wget\u00a0openssh-server\u00a0locales\u00a0-y\u00a0--force-yes</code> <code>dpkg-reconfigure\u00a0locales</code> <code>apt-get\u00a0install\u00a0ubuntu-desktop\u00a0-y</code> <code>echo\u00a0\"AVAHI_DAEMON_START=0\"\u00a0&gt;\u00a0/etc/default/avahi-daemon</code> <code>/etc/init.d/networking\u00a0restart</code> <code>cd\u00a0/usr/lib/xorg/modules/drivers/</code> <code>wget\u00a0-O\u00a0xenosfb_drv.so</code>http://file.libxenon.org/free60/linux/xenosfb/xenosfb_drv.so_oneiric <code>cd\u00a0/etc/X11/</code> <code>wget</code>http://file.libxenon.org/free60/linux/xenosfb/xorg.conf <code>rm\u00a0-r\u00a0-f\u00a0/work/</code> <code>echo\u00a0\"Installation\u00a0completed.\"</code> <code>echo\u00a0\"To\u00a0boot\u00a0the\u00a0system:\u00a0Reboot\u00a0and\u00a0load\u00a0the\u00a0kernel\u00a0with\u00a0correct\u00a0root=\u00a0params.\"</code> <code>echo\u00a0\"You\u00a0should\u00a0be\u00a0greeted\u00a0by\u00a0a\u00a0fresh\u00a0install\u00a0of\u00a0Ubuntu\u00a011.10\u00a0Oneiric\"</code> <code>EOF</code> <code>chmod\u00a0a+x\u00a0/mnt/ubuntu/root/.second_stage</code> <code>#\u00a0Execute\u00a0second\u00a0part\u00a0of\u00a0installation\u00a0in\u00a0the\u00a0chroot\u00a0environment</code> <code>mount\u00a0-t\u00a0proc\u00a0none\u00a0/mnt/ubuntu/proc</code> <code>mount\u00a0--rbind\u00a0/dev\u00a0/mnt/ubuntu/dev</code> <code>cp\u00a0-L\u00a0/etc/resolv.conf\u00a0/mnt/ubuntu/etc/resolv.conf</code> <code>chroot\u00a0/mnt/ubuntu\u00a0/root/.second_stage</code> <code>umount\u00a0/mnt/ubuntu/dev\u00a0/mnt/ubuntu/proc\u00a0/mnt/ubuntu</code></p>"},{"location":"Linux/Distros/Ubuntu/11_10/#fix-possible-xorg-fail","title":"Fix possible xorg fail","text":"<p>After it has finished installing and has rebooted into gnome open a new shell by typing Ctrl+Alt+F6 or Ctrl+Alt+F1 and type,</p> <p><code>sudo\u00a0dpkg-reconfigure\u00a0xserver-xorg</code></p> <p>Then follow the instructions below.</p> <p>1. Attempt to autodetect video hardware? &gt; No</p> <p>2. X Server Driver: Xenosfb</p> <p>3. Generic Video Card &gt; Enter</p> <p>4. Video card\u2019s bus identifier: Press enter for default</p> <p>5. Amount of memory: Press enter for default</p> <p>6. Use kernel framebuffer device interface? &gt; Yes</p> <p>7. Autodetect keyboard layout? &gt; Yes</p> <p>8. Keyboard layout: us</p> <p>9. XKB rule set to use: xorg</p> <p>10. Keyboard model: choose your rule set based on the options</p> <p>11. Keyboard variant: leave blank if you\u2019re in the U.S.</p> <p>12. Keyboard options: Leave as default</p> <p>13. Mouse Protocol: ImPS/2</p> <p>14. Emulate a 3 button mouse? &gt; Your choice</p> <p>15. Xorg server modules: Default</p> <p>16. Write default Files section to configuration file? &gt; Yes</p> <p>17. Attempt monitor detection? &gt; Yes</p> <p>18. Use generic monitor if it doesn\u2019t detect it.</p> <p>19. Video modes to be used by the X server: 1280x768 (1024x768 if garbled)</p> <p>20. Method for selecting the monitor characteristics: Medium</p> <p>21. Monitors best video mode: Choose what\u2019s best for your monitor.</p> <p>22. Write monitor sync ranges to the configuration file? &gt; Yes</p> <p>23. Desired default color depth in bits: 24.</p> <p>After that go back to gnome by typing Ctrl+Alt+F7.</p> <p>Reboot X by typing Ctrl+Alt+Backspace.</p> <p>Category: Linux</p>"},{"location":"Linux/Distros/Ubuntu/7_10/","title":"Install Ubuntu 7.10 from the Gentoo LiveCD","text":"<p>gnome Issue Resolved</p> <p>WARNING: This script will WIPE your Xbox 360 internal harddisk (/dev/sda) and install Ubuntu 7.10</p> <p>If you have XeXmenu or another dashboard homebrew on that drive, you will loose it all: Follow these instructions only if you understand what you are doing.</p> <p>I new boot disk that would allow the booting of a USB harddisk would ease the risk of ruining your 360 harddrive.</p> <p>ubuntu_gutsy.sh will create two partitions. 1 GB swap on sda0 and the rest of the disk as a root-filesystem on sda1. Run the script as root from the Gentoo LiveCD v2. You will need a DHCP-server on your network for this script.</p> <p>How do I run it?</p> <p>Click \"Application &gt; Accessories &gt; Terminal\" and type the following commands:</p> <pre><code>sudo\u00a0su\nwget\u00a0http://file.libxenon.org/free60/linux/script/ubuntu_gutsy.sh\nsh\u00a0./ubuntu_gutsy.sh\n</code></pre> <p>Reboot the 360 when you are told. Boot with http://file.libxenon.org/latest_kern, supply correct \"root=\" parameter via kboot.conf (*kboot currently only supported via xell-reloaded-testing builds), boot the kernel/system and login as root. You will be asked to set new password. The rest of the installation will start automatically. The download is about 600Mb. After a while it will ask you to setup the screen resolution, select 1280x768 with the space bar. If the display is garbled use 1024x768.</p> <p>After it has finished installing and has rebooted into gnome open a new shell by typing Ctrl+Alt+F6 or Ctrl+Alt+F1 and type,</p> <p><code>sudo\u00a0dpkg-reconfigure\u00a0xserver-xorg</code></p> <p>Then follow the instructions below.</p> <p>1. Attempt to autodetect video hardware? &gt; No</p> <p>2. X Server Driver: Xenonfb</p> <p>3. Generic Video Card &gt; Enter</p> <p>4. Video card\u2019s bus identifier: Press enter for default</p> <p>5. Amount of memory: Press enter for default</p> <p>6. Use kernel framebuffer device interface? &gt; Yes</p> <p>7. Autodetect keyboard layout? &gt; Yes</p> <p>8. Keyboard layout: us</p> <p>9. XKB rule set to use: xorg</p> <p>10. Keyboard model: choose your rule set based on the options</p> <p>11. Keyboard variant: leave blank if you\u2019re in the U.S.</p> <p>12. Keyboard options: Leave as default</p> <p>13. Mouse Protocol: ImPS/2</p> <p>14. Emulate a 3 button mouse? &gt; Your choice</p> <p>15. Xorg server modules: Default</p> <p>16. Write default Files section to configuration file? &gt; Yes</p> <p>17. Attempt monitor detection? &gt; Yes</p> <p>18. Use generic monitor if it doesn\u2019t detect it.</p> <p>19. Video modes to be used by the X server: 1280x768 (1024x768 if garbled)</p> <p>20. Method for selecting the monitor characteristics: Medium</p> <p>21. Monitors best video mode: Choose what\u2019s best for your monitor.</p> <p>22. Write monitor sync ranges to the configuration file? &gt; Yes</p> <p>23. Desired default color depth in bits: 24.</p> <p>After that go back to gnome by typing Ctrl+Alt+F7.</p> <p>Reboot X by typing Ctrl+Alt+Backspace.</p> <p>(If Java is required, do not install the one in the default repository as it is broken, to attempt to install it http://ubuntuforums.org/showthread.php?t=1116368 , or simply install this http://3dslice.net/downloads/PrimeGen/ibm-j2sdk1.6_1.6.0_powerpc.deb )</p> <p>ubuntu_gutsy.sh #!/bin/bash</p> <p><code>#\u00a0set\u00a0the\u00a0date\u00a0to\u00a0anything\u00a0except\u00a01/1/1970\u00a0since\u00a0this\u00a0causes\u00a0issues</code> <code>#\u00a0time\u00a0is\u00a0now\u00a0also\u00a0set\u00a0after\u00a0first\u00a0boot\u00a0by\u00a0.bashrc\u00a0script\u00a0below</code> <code>date\u00a0-s\u00a01/1/2009</code> <code>#\u00a0if\u00a0/dev/sda\u00a0is\u00a0mounted\u00a0then\u00a0paritions\u00a0get\u00a0wiped\u00a0by\u00a0dd\u00a0but\u00a0sfdisk\u00a0fails!</code> <code>swapoff\u00a0/dev/sda1</code> <code>umount\u00a0/mnt/ubuntu</code> <code>#\u00a0partition\u00a0and\u00a0mkfs\u00a0hdd\u00a0(all\u00a0data\u00a0is\u00a0lost!)</code> <code>dd\u00a0if=/dev/zero\u00a0of=/dev/sda\u00a0bs=512\u00a0count=1</code> <code>sfdisk\u00a0/dev/sda\u00a0&lt;&lt;\u00a0EOF</code> <code>,124,S</code> <code>,,L</code> <code>EOF</code> <code>dd\u00a0if=/dev/zero\u00a0of=/dev/sda2\u00a0bs=512\u00a0count=1</code> <code>mkfs.ext3\u00a0/dev/sda2</code> <code>mkswap\u00a0/dev/sda1</code> <code>sync;\u00a0sync;\u00a0sync</code> <code>swapon\u00a0/dev/sda1</code> <code>#\u00a0setup\u00a0paths</code> <code>mkdir\u00a0/mnt/ubuntu</code> <code>mount\u00a0/dev/sda2\u00a0/mnt/ubuntu</code> <code>cd\u00a0/mnt/ubuntu</code> <code>mkdir\u00a0/mnt/ubuntu/work</code> <code>cd\u00a0/mnt/ubuntu/work</code> <code>#\u00a0download\u00a0extract\u00a0and\u00a0run\u00a0debootstrap</code> <code>wget</code>ftp://old-releases.ubuntu.com/old-images/ubuntu/pool/main/d/debootstrap/debootstrap_1.0.3build1_all.deb <code>ar\u00a0-xf\u00a0debootstrap_1.0.3build1_all.deb</code> <code>cd\u00a0/mnt/ubuntu</code> <code>zcat\u00a0&lt;\u00a0/mnt/ubuntu/work/data.tar.gz\u00a0|\u00a0tar\u00a0xv</code> <code>export\u00a0DEBOOTSTRAP_DIR=/mnt/ubuntu/usr/lib/debootstrap</code> <code>export\u00a0PATH=$PATH:/mnt/ubuntu/usr/sbin</code> <code>debootstrap\u00a0--arch\u00a0powerpc\u00a0gutsy\u00a0/mnt/ubuntu</code>ftp://old-releases.ubuntu.com/old-images/ubuntu/ <code>#\u00a0create\u00a0needed\u00a0files\u00a0on\u00a0hdd</code> <code>echo\u00a0Falcon\u00a0&gt;\u00a0/mnt/ubuntu/etc/hostname</code> <code>cat\u00a0&gt;\u00a0/mnt/ubuntu/etc/fstab\u00a0&lt;&lt;\u00a0EOF</code> <code>/dev/sda2\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ext3\u00a0\u00a0\u00a0\u00a0\u00a0defaults\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00</code> <code>/dev/sda1\u00a0\u00a0\u00a0\u00a0\u00a0none\u00a0\u00a0\u00a0\u00a0swap\u00a0\u00a0\u00a0\u00a0sw\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00</code> <code>proc\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/proc\u00a0\u00a0\u00a0\u00a0proc\u00a0\u00a0\u00a0\u00a0defaults\u00a0\u00a00\u00a0\u00a0\u00a00</code> <code>EOF</code> <code>cat\u00a0&gt;\u00a0/mnt/ubuntu/etc/network/interfaces\u00a0&lt;&lt;\u00a0EOF</code> <code>iface\u00a0lo\u00a0inet\u00a0loopback</code> <code>auto\u00a0lo</code> <code>auto\u00a0eth0</code> <code>iface\u00a0eth0\u00a0inet\u00a0dhcp</code> <code>EOF</code> <code>cat\u00a0&gt;\u00a0/mnt/ubuntu/etc/apt/sources.list\u00a0&lt;&lt;\u00a0EOF</code> <code>deb</code>ftp://old-releases.ubuntu.com/old-images/ubuntu/<code>gutsy\u00a0main\u00a0restricted\u00a0universe\u00a0multiverse</code> <code>EOF</code> <code>#Change\u00a0root-pwd\u00a0inside\u00a0chroot</code> <code>chroot\u00a0/mnt/ubuntu\u00a0echo\u00a0\"root:xbox\"\u00a0|\u00a0chroot\u00a0/mnt/ubuntu\u00a0/usr/sbin/chpasswd</code> <code>cp\u00a0/mnt/ubuntu/root/.bashrc\u00a0/mnt/ubuntu/root/.bashrc.orginal</code> <code>#\u00a0create\u00a0.bashrc\u00a0script\u00a0on\u00a0hdd</code> <code>cat\u00a0&gt;&gt;\u00a0/mnt/ubuntu/root/.bashrc\u00a0&lt;&lt;\u00a0EOF</code> <code>date\u00a0-s\u00a01/1/2009</code> <code>passwd</code> <code>mkdir\u00a0/lib/modules/2.6.24.3</code> <code>touch\u00a0/lib/modules/2.6.24.3/modules.dep</code> <code>apt-get\u00a0update</code> <code>apt-get\u00a0install\u00a0ntp\u00a0wget\u00a0-y\u00a0--force-yes</code> <code>apt-get\u00a0install\u00a0ubuntu-desktop\u00a0-y</code> <code>echo\u00a0\"AVAHI_DAEMON_START=0\"\u00a0&gt;\u00a0/etc/default/avahi-daemon</code> <code>/etc/init.d/networking\u00a0restart</code> <code>cd\u00a0/usr/lib/xorg/modules/drivers/</code> <code>wget\u00a0-O\u00a0xenosfb_drv.so</code>http://file.libxenon.org/free60/linux/xenosfb/xenosfb_drv.so_gutsy <code>cd\u00a0/etc/X11/</code> <code>wget</code>http://file.libxenon.org/free60/linux/xenosfb/xorg.conf <code>mv\u00a0ubuntu.conf\u00a0xorg.conf</code> <code>cd\u00a0/usr/lib/xorg/modules/linux/</code> <code>mv\u00a0libfbdevhw.so\u00a0libfbdevhw.so.bk</code> <code>wget\u00a0-O\u00a0libfbdevhw.so</code>http://file.libxenon.org/free60/linux/xenosfb/libfbdevhw.so_gutsy <code>rm\u00a0-r\u00a0-f\u00a0/work/</code> <code>echo\u00a0\"\"\u00a0&gt;\u00a0/etc/gdm/gdm.conf-custom</code> <code>sed\u00a0-i\u00a0's/AllowRoot=false/AllowRoot=true/'\u00a0/etc/gdm/gdm.conf</code> <code>rm\u00a0/root/.bashrc</code> <code>mv\u00a0/root/.bashrc.orginal\u00a0/root/.bashrc</code> <code>/etc/init.d/gdm\u00a0start</code> <code>EOF</code> <code>#\u00a0done</code> <code>echo\u00a0\"Base\u00a0installation\u00a0completed.\"</code> <code>echo\u00a0\"To\u00a0finish\u00a0the\u00a0installation:\u00a0Reboot\u00a0and\u00a0load\u00a0the\u00a0kernel\u00a0with\u00a0correct\u00a0root=\u00a0params.\"</code> <code>echo\u00a0\"The\u00a0install\u00a0\u00a0may\u00a0take\u00a0up\u00a0to\u00a0two\u00a0hours,\u00a0depending\u00a0on\u00a0your\u00a0internet\u00a0connection\"</code></p> <p>Category: Linux</p>"},{"location":"Support/Attack/","title":"Attack","text":"<p>This page was created when knowledge was low, everything on here is impossible, due to the 360's hypervisor. The only exploit there is and ever will be is the King Kong/JTAG (SMC)/or any other exploit for the 4532 kernel - slasherking823</p> <p>Actually, upon further examination, this page was created by someone with no knowledge even when public knowledge existed.</p> <p>Bad Ideas are as follows:</p> <p>Please reply and comment each attack and tell us if such attacks are possible or not</p> <p>Please do not erase wrong things but reply instead</p>"},{"location":"Support/Attack/#ideas","title":"Ideas","text":""},{"location":"Support/Attack/#software","title":"Software","text":"<ul> <li>Old Xbox games<ul> <li>Known bugs on the old games</li> <li>Maybe it works (small probability that it has not been fixed)</li> <li>It's been noted that few of the Original Xbox's games whose game saves were     exploitable appear on the Xbox 360 backwards list. However it's also     worth knowing that games in addition to 007AUF, MA, and SC1     contain similar flaws - but their exploitation was not felt     neccessary.</li> <li>This probably won't work, since the Xbox 360 emulates the old     Xbox (with a customized emulator for each game). Using     a bug in an old game would just \"break out\" into the emulated     old Xbox. Of course, if the emulator design is sufficiently     sloppy, it might be possible to have a second step that then     compromises the actual Xbox 360 security.</li> </ul> </li> <li>Patched games<ul> <li>Patching (French)</li> <li>(Early Versions?) King Kong will need a patch in order to be playable on some screens</li> <li>The patch needs a HDD</li> </ul> </li> <li>Manipulated media files<ul> <li>Images, Music Files, Video<ul> <li>Windows Media Center, after authenticating with the server,     uses a client compiled for the 360 to access all Media     Center functionality. The software is very buggy. It would be a     prime target for attack.</li> </ul> </li> <li>Start by trying out some exploits that are already known and see     how Xbox 360 reacts to them<ul> <li>There is potential to use a .tiff overflow(?) Certainly if     the hypervisor behaves as suggested, it will catch the     buffer overflow, but it might provide insight as to how it     works.<ul> <li>I emailed the team that did the .tiff overflow with the     PSP (for anyone who knows about their work), and asked     for info regarding how they went about .tiff exploit.     They had some interesting things to say (I can email     anyone their response if they want), and recommended     this.     I'm sure it's old business for a lot of people, but its     over my head; I'm not able enough to get a lot of it. If     someone wants to work in conjunction with me to try this     exploit out, my email is GBW88@comcast.net.</li> </ul> </li> <li>Maybe the recent WMF bug (escape function) will work too.<ul> <li>WMF Files don't play on the 360.</li> </ul> </li> </ul> </li> </ul> </li> <li>Save game attack<ul> <li>Will require another hack first to be able to hijack a game's     save game signing</li> </ul> </li> <li>Network compromise<ul> <li>Fuzzing services/network connections</li> </ul> </li> <li>File system drivers<ul> <li>Manipulating entries like the partition table, etc Hard Drive Mod.htm]</li> </ul> </li> <li>Decompression routines<ul> <li>Cause a buffer overflow</li> </ul> </li> </ul>"},{"location":"Support/Attack/#hardware","title":"Hardware","text":"<ul> <li>DMA attack<ul> <li>Someone has developed an exploit for Firewire DMA FireWire - all your memory belongs to us</li> <li>Firewire can copy data between two Firewire HDDs without using     the CPU at all (no irq gestion ...)</li> <li>Maybe retrieve some data that can't be retrieved</li> <li>USB and IDE that have DMA<ul> <li>Maybe it doesn't work with non-Firewire devices</li> </ul> </li> <li>Video: [2]</li> </ul> </li> <li>Manipulated USB     device<ul> <li>Webcam</li> <li>iPod</li> </ul> </li> </ul>"},{"location":"Support/Attack/#torx-and-solder","title":"Torx and Solder","text":"<ul> <li>Boot     suggests various CPU parameters including the hypervisor mode and boot     vector are set by the I2C/SPI bus on start up. If the I2C/SPI bus is     accessible and modifiable then security features could be disabled     allowing another vector to succeed.</li> <li>Theories are floating around some forums as to the validity of     hacking DVD drive firmware to authenticate all discs as OK. Firmware     has some basic bitswapping and xor-ing which was defeated quickly,     maybe potential to change it?<ul> <li>Good technical thread     here at     xboxhacker.net. Unfortunately, it starts in the name of backups,     but it contains large amounts of insight as to how the DVD     system functions. Signing code would still be a problem, but     bypassing mediachecks could help at least.<ul> <li>(Offtopic) If it is possible to modify the firmware, would     it then not also be possible to read the 'hidden' security     areas on (for example) audio-dvd?</li> </ul> </li> </ul> </li> <li>Buses<ul> <li>If some bus are accessible but at too much high speed (don't     remember well the design of the 360, I should re-read the     documentation and websites) maybe use of highspeed DAC or     professionals osciloscope for electronic design or     aviation (maybe some people have access to such devices) or     home-made ones (using some DAC  of some     cards (video-cards,tv-cards))</li> <li>Easiest way to do DAQ is to use an NI DAQ system of allmost any     kind (w/ fast enough DAC, something like FLASH-DAC) [3]</li> <li>Develop program for a snatching data from the bus. with high     input impendances, megaohm range. If somebody is able to get     those DAQ systems, I'm going to write a program for snatching     data.</li> </ul> </li> </ul>"},{"location":"Support/Attack/#failed-vectors","title":"Failed Vectors","text":"<p>To save people revisiting old ground please list any attempts that have failed here</p>"},{"location":"Support/Attack/#discussion","title":"Discussion","text":""},{"location":"Support/Attack/#page-design","title":"Page design","text":"<p>This is a stub or whatever you call this kind of page...</p> <p>It's as a \"brouillon(french)\" This page has not been reviewed by skilled persons... (maybe they haven't got the time) this page could be reviewed by someone that is not a developer (precious time) but is a press expert and know what is possible and what isn't.</p> <p>So put evrything on the main page and discuss it on the main page it's meant for this.</p> <p>And if something clean and verified can be produced we will make another \"stable\" page that developers should read.</p>"},{"location":"Support/Attack/#ideas_1","title":"Ideas","text":"<p>Xbox 360's OS has its root in the OS of the original Xbox (which is derivate from Windows 2000). I think that some bug and exploit in the Original Xbox (or even 2000) still works on the 360, we have to try every bug/fuzzing/hole knowed to find exploits.</p> <p>Ideas:</p> <ul> <li> <p>File format fuzzing (there are some tools in Sourceforge), example:   image format like WMF (recent exploit in Win 2000 and XP platform due   to implementation of the fct escape() and not a BO!!!!!)</p> </li> <li> <p>XMA is a very good way to find some holes, and Sounds aren't signed   (Demo DVD) Someone has Doc about XMA ? maybe in XACT ?</p> </li> <li> <p>By network UPnP (use XML), it's seems that the norm thinks about   security like not permit to send XML break char, or limit ACL hack, but   if there are an XML implementation (libXML) there are chance to find an   exploit.</p> </li> </ul> <p>We all know Microsoft's security in their implementation of norms (like   IP stack or other).</p> <ul> <li> <p>By DMA, using USB (security hole in Win 2000\\&amp;XP ohcpi) other way:   IDE (sata), we can try to access to DMA with a PC connected to the   Xbox...by SATA ;-) the idea is to use the PC like an IDE device for the   Xbox 360. I'm reading the DMA-API and IDE doc for Linux (if you have   Linux, interessting stuff is in /include/Documentation/DMA-API.txt &amp;   DMA-mapping.txt and in /include/Drivers/ide/ )</p> </li> <li> <p>By threads, if we can use the GPU to access to RAM and access to the   same area as the CPU we can do some buggy things (in fact thread is not   necessary)</p> </li> </ul> <p>Resources:</p> <ul> <li> <p>Metasploit, a huge DB for exloits and shellcodes https://metasploit.com/</p> </li> <li> <p>Milw0rm, exploits milw0rm.com</p> </li> <li> <p>Fuzzing file and network http://rtos.trinux.org/secwiki/FuzzingTools</p> </li> </ul>"},{"location":"Support/Attack/#xex-executables","title":"XEX executables","text":"<p>What security problems are known about the XEX files. They can be burned to DVD/CD and used to install the backwards compatability emulator, so attacking them would be a good idea. Since the OS for the 360 is based on Windows, is the .xex file in any way related to .exe? .xex files renamed to end in .exe do not do anything in Windows. I would like further documentation on what happens when the emulation software is executed via CD/DVD. -- Monsuco 19:29, 9 Mar 2006 (CET)</p> <p>The Xbox 360 CPU is based on the PowerPC architecture, not on Intel like PC CPUs. For that simple reason, an Xbox 360 executable will never run under a PC version of Windows. --Silence 10:59, 10 Mar 2006 (CET)</p> <p>First guy is absolutely retarded &gt;_&gt; - Thilo</p>"},{"location":"Support/Attack/#xna","title":"XNA","text":"<ul> <li>The XNA libraries are .NET wrappers around various DirectX libraries   (XACT, XInput, Direct3D, etc), and runs on the .NET Compact Framework.   Both frameworks are fairly large and complex and it could be a possible   candy store for exploits.</li> </ul> <p>Category: Support</p>"},{"location":"Support/Contribute/","title":"Contribute","text":""},{"location":"Support/Contribute/#from-free60","title":"From Free60","text":"<p>We really appreciate your interest in the Free60 Project, and especially your enthusiasm to want to contribute! If you haven't yet, please have a look at our Goals.</p>"},{"location":"Support/Contribute/#eligibility","title":"Eligibility","text":""},{"location":"Support/Contribute/#who-cant-contribute","title":"Who can't contribute","text":"<p>Unfortunately not everyone can chip in, for example people who have signed an NDA pertaining to the hardware or software used on the Xbox 360 can't as it would break their contract.</p>"},{"location":"Support/Contribute/#who-can-contribute","title":"Who can contribute","text":"<p>If you don't meet the above, congratulations! You're eligible to participate in the project. There are still quite a few areas of expertise we are interested in and need information on, so please keep reading!</p>"},{"location":"Support/Contribute/#areas-of-opportunity","title":"Areas of Opportunity","text":"<p>These are a few areas where we can use assistance.</p>"},{"location":"Support/Contribute/#documentation","title":"Documentation","text":"<p>We always need people willing to update and translate all our current documentation, as well as fill in the missing holes. For example, most of the major file systems used on the Xbox 360 have still not fully been explored here. If you want to help contribute to the advancement of Free60 please read on into the Editing the Wiki section.</p>"},{"location":"Support/Contribute/#donations","title":"Donations","text":"<p>Currently Free60 has no plans to incorporate or provide other such means for easy monetary donations to the project as a whole. If you feel like you have hardware or money that you want to contribute to the project, feel free to donate directly to developers and members. Free60 is not responsible for such donations. Check Stuff we need for a list of items developers are currently seeking.</p>"},{"location":"Support/Contribute/#editing-the-wiki","title":"Editing The Wiki","text":"<p>This website is a Wiki collection of web pages, whose content may be edited anonymously, over the internet.</p>"},{"location":"Support/Contribute/#care-and-feeding","title":"Care and Feeding","text":"<p>Because of it's collaborative and freely-editable nature, writing, updating and maintaining documentation are the most important steps to keeping the system alive.</p> <p>A few guidelines to go by when editing pages on this wiki:</p> <ul> <li>Provide accurate information.</li> <li>Write an edit summary for your change. It takes the guess-work out   of browsing through the changelog.</li> <li>Avoid duplication. New pages that duplicate already existing   information are a bad idea. Work on-top of the existing content to   better it instead.</li> <li>Upload only those images that you own. Or at least get permission   from the owner to do so. Infringing on someone else's copyright does   no one any good, really.</li> </ul>"},{"location":"Support/Contribute/#repair-and-restoration","title":"Repair and Restoration","text":"<p>As a negative side effect, wikis are also a target of and mostly vulnerable to vandalism.</p> <p>Spotting and reverting cases of vandalism can be anywhere from time consuming, to trivial a task. Either way, this is greatly appreciated.</p> <p>Category: Support</p>"},{"location":"Support/Discord/","title":"Discord","text":"<p>Join us in the Free60 Project Discord guild at https://discord.gg/KvMB4HzHym to discuss the Free60 project, the Linux kernel ports, LibXenon and LibXenon homebrew, and XeLL Reloaded.</p> <p>Rules are available in the #rules-and-guidelines channel.</p>"},{"location":"Support/FAQ/","title":"FAQ - Frequently asked questions","text":"<ul> <li> <p>Whats the status of the project?   We can run unsigned code, Linux patches   exist and a second level boot loader as well as   several LiveCDs have been released. But you   still need a first-level boot loader. There are two in the wild, by   Crawler360 and xorloser. Both require you to patch the shaders of   the Xbox 360 title King Kong. The xorloser loader is probably what   you are looking for as it works without soldering a serial cable to   the motherboard of your Xbox 360.</p> </li> <li> <p>Is it possible to run unsigned code on the Xbox 360?   Yes. Look at Run Code.</p> </li> <li> <p>Which hack should I use for my xbox kernel version?</p> </li> </ul> <p>Kernel lower than 2.0.4548: See Timing Attack</p> <p>Kernel up to 2.0.7371: There's a method to run unsigned code if your   Dashboard-Version is not higher than 7371. Have a look at SMC Hack</p> <p>Kernel higher than 7371: The new Reset Glitch Hack   supports many consoles with recent Kernels</p> <ul> <li> <p>Where can I find the latest news?   Relevant news items are posted on the front   page. For what else has changed on the Wiki,   see the recent changes.</p> </li> <li> <p>Will I void my warranty by taking my machine apart?   Yes. There is a tamper-proof seal that must be broken to get any   further than just removing the faceplate. Doing so automatically   voids any warranty you might have had.</p> </li> <li> <p>How can I subscribe to the free60.org mailinglist?   Sorry, Mailing Lists aren't available anymore.</p> </li> <li> <p>I have access to official documentation or official developer   software/hardware. May I help?   No. Contributing any such information would put you in violation of   your Non-Disclosure Agreement, while tainting the project at the   same time. Note, however, IANAL and TINLA.</p> </li> </ul> <p>Category: Support</p>"},{"location":"Support/Help/","title":"Help","text":""},{"location":"Support/Help/#ircdiscord","title":"IRC/Discord","text":"<p>For real-time chat, for either support or to help with the project, you can join us on IRC or Discord.</p>"},{"location":"Support/Help/#want-to-help","title":"Want to Help?","text":"<p>Here is what you can do to help this project:</p> <ul> <li>Documentation: We need the individual bits\\&amp;pieces, for example from     xboxhacker.net, nicely assembled into wiki pages, Howtos etc. This     does not require coding skills!</li> <li>Head over to here     for a list of pages that need some work done on them.</li> <li>Or you can go here for a     list of pages that need images uploaded.</li> <li>Take a look at wiibrew.org: They have nice categories for the     available software, features applications etc.</li> <li>Tell more people about what you can do with Linux on the 360.</li> <li>We need more applications so people have a reason to try out free     Libxenon based code and Linux on 360.</li> <li>Work to implement End User Requirements</li> <li>Test and improve the Linux live CD images</li> <li>Add useful ideas to this list.</li> </ul>"},{"location":"Support/Help/#seeking-information-on","title":"Seeking Information On","text":"<p>Some documentation must already exist, though perhaps not in the wild. We are seeking:</p> <ul> <li>CPU instruction set reference --&gt; See VisualStudio 2005 Reference     (Exact CPU instruction set reference)</li> <li>Verification that the CPUs have a memory management unit (can do     virtual memory)</li> <li>Details of Multi-processor memory coherency and synchronization     requirements</li> </ul>"},{"location":"Support/Help/#documentation-to-develop","title":"Documentation To Develop","text":"<p>Some documentation will either not exist, or won't be made available</p> <ul> <li>Memory usage map for boot code</li> <li>Hypervisor details. What is checked and how it is checked</li> <li>Chain of trust: how execution integrity is designed to work</li> <li>Chinks in the armor: Holes in the chain of trust</li> <li>Hard drive locking (if any) and filesystem details     (Harddrive)</li> <li>Wireless hardware and software protocol for controllers</li> <li>Xbox1 software emulation details</li> </ul>"},{"location":"Support/Help/#xell-libxenon","title":"XeLL / Libxenon","text":"<ul> <li>[Libxenon]: Improve Libxenon and write apps.</li> <li>[Libxenon]/[XeLL]: Fix the usb driver so it gets proper speed     and Power supply does not need to get replugged to get usb mass     storage recognized DONE</li> <li>[Libxenon]/[XeLL]: Write a fatx/xtaf driver</li> <li>[XeLL]: Implement parsing of a bootconfig + passing     bootarguments to the linux kernel DONE</li> <li>[XeLL]: Fix non-workin XeLL-XeLL implementation (chainload XeLL     from a \"base XeLL\") DONE</li> </ul>"},{"location":"Support/Help/#xenon-linux-kernel","title":"Xenon linux kernel","text":"<ul> <li>Needs urgent fixing: Linux Kernel - a hardware CPU bug causes   powerpc locking primitives to fail between hyper threads unless a   special register is set properly</li> <li>Fix usb driver (random freez under heavy usage)</li> <li>Patch RTC driver for hardware clock access</li> <li>Xenosfb: add support for mode switching</li> <li>Audio driver</li> <li>If possible: Modify the ATI 3D driver to work with the Xenos-Chip</li> </ul>"},{"location":"Support/Help/#linux-live-cd-installer","title":"Linux Live CD / Installer","text":"<ul> <li>Open a Boot Menu with the following options:<ul> <li>Load [Linux Kernel] from HDD (default, 10s timeout? auto   detection of valid Linux HDD?)</li> <li>Load [Linux Kernel] from CD and use root filesystem on HDD</li> <li>Load Rescue/Installer Linux LiveCD</li> <li>Load Linux over TFTP (optionally configuring the network)</li> </ul> </li> </ul> <p>The Menu can either be created in XeLL (requiring reading from CD, SATA, plus interactivity over serial / IR remote or USB controller), or possibly in a Linux initramfs (which is easier to implement, but locks the user in to one single kernel)</p> <p>Category: Support</p>"},{"location":"Support/IRC/","title":"IRC","text":"<p>Join us in the Free60 IRC channel(s) #free60 at irc.libera.chat to discuss the Free60 project, the Linux kernel ports, LibXenon and LibXenon homebrew, and XeLL Reloaded.</p>"},{"location":"Support/IRC/#free60-channel-list","title":"Free60 Channel List","text":"<ul> <li>#free60 for general Free60 discussion.</li> <li>#free60-libxenon for LibXenon.</li> <li>#free60-linux for the Free60 Linux patches.</li> <li>#free60-xell for XeLL Reloaded.</li> </ul>"},{"location":"Support/IRC/#guidelines","title":"Guidelines","text":"<p>Free60 and Libera.Chat are happy to facilitate the means for information gathering and dissemination. But, we have some basic guidelines we need you to follow.</p> <p>We're not trying to be dictators, we just want everyone to get along. Libera is a civil network and we'd like to keep it that way.</p>"},{"location":"Support/IRC/#basic-guidelines","title":"Basic Guidelines","text":"<ul> <li> <p>Be polite. Flaming others and the like is considered bad netiquette,     and is frowned upon. This will more than likely result in you and     any participating parties being banned from the channel.</p> </li> <li> <p>Be on-topic. Off-topic discussion is considered noise and should be     directed elsewhere.</p> </li> <li> <p>Do not /msg people with on-topic discussion. Rather, discuss that     in-channel.</p> </li> <li> <p>Do not overly repeat yourself. We heard you the first time.</p> </li> <li> <p>Please don't run any bots without prior permission from an op.</p> </li> <li> <p>Channel operator status is not a privilege, but rather a     responsibilty. Asking for such will more than likely get you banned.</p> </li> <li> <p>#free60 is NOT a distribution point for pirated/illegal material,     be it software or even documentation. We have zero-tolerance towards     any related discussion.</p> </li> <li> <p>Messages sent in the IRC channels are forwarded to the Discord guild.</p> </li> </ul>"},{"location":"Support/IRC/#asking-questions","title":"Asking Questions","text":""},{"location":"Support/IRC/#before-asking","title":"Before Asking","text":"<ul> <li>Search the wiki and GitHub for an answer.</li> </ul>"},{"location":"Support/IRC/#while-asking","title":"While Asking","text":"<ul> <li>Be polite.</li> <li>Be patient.</li> <li>Be pertinent -- that is make sure your question has something to do     with the channel you're in.</li> </ul>"},{"location":"Support/IRC/#after-asking","title":"After Asking","text":"<ul> <li>If your question was answered and can't be found on the wiki please     post that info.</li> <li>Stick around to help others after you.</li> </ul>"},{"location":"Support/IRC/#conclusion","title":"Conclusion","text":"<p>Thank you for your interest in Free60, enjoy your stay!</p> <p>Category: Support</p>"},{"location":"Support/Links/","title":"Links","text":""},{"location":"Support/Links/#modding-community","title":"Modding Community","text":"<ul> <li>Xbox Hacker (archive.org)</li> <li>Xbox-Scene (mirror)</li> <li>Xbox Dream (archive.org)</li> </ul>"},{"location":"Support/Links/#coding-guides","title":"Coding Guides","text":"<ul> <li>Unsigned Xbox 360 Developer Best Practice at xbox.com (archive.org)</li> </ul>"},{"location":"Support/Links/#articles-of-note","title":"Articles of Note","text":"<ul> <li>Xbox 360 Fact Sheet at xbox.com (archiv.org)</li> <li>Inside Microsoft's Xbox 360 at anandtech.com</li> <li>Inside the Xbox 360, Part I at arstechnica.com</li> <li>Inside the Xbox 360, Part II: the Xenon CPU at arstechnica.com</li> <li>[The scoop on the Xbox 360's embedded OS]https://web.archive.org/web/20090506110028/http://www.windowsfordevices.com/news/NS3988467635.html) at windowsfordevices.com (archive.org)</li> <li>Chipworks First Inside Microsoft's Xbox 360 Silicon (archive.org)</li> <li>IBMs Hypervisor project or archive.org mirror</li> <li>Media Center Extender Hardware Requirements</li> </ul>"},{"location":"Support/Links/#photos","title":"Photos","text":"<ul> <li>More 360 pictures (somewhere in .eu?)</li> <li>High resolution motherboard pic, with heatsinks (from informit.com article)</li> <li>Lot of pictures, archive.org mirror</li> </ul>"},{"location":"Support/Links/#disassembly","title":"Disassembly","text":"<ul> <li>How to Disassemble the \"Screwless\" Xbox 360 at digg.com (archiv.org)</li> <li>Xbox 360 Exposed</li> </ul> <p>Category: Support</p>"},{"location":"System-Software/1bl_Code/","title":"1BL - Pseudocode","text":"<p>Have not reversed all of the hardware error subroutines.</p> <pre><code>// version 0x583\n\n#define STACK 0x800002000001F700 // r1\n#define TOCP 0x8000020000000000 // r2\n#define SRAM 0x8000020000010000\n#define NAND 0x80000200C8000000\n#define PCI 0x80000200D0000000\n\n#define _HW_REG_POST 0x8000020000061010\n#define _HW_REG_61008 0x8000020000061008\n#define HW_REG_POST (*((volatile QWORD *)_HW_REG_POST))\n#define HW_REG_61008 (*((volatile QWORD *)_HW_REG_61008))\n\n#define BITMASK32(n) ((~0ul) &gt;&gt; 32-bits)\n#define BITMASK32_L(n) ~((~0ul) &gt;&gt; bits) // left justified bitmask, assumes the hardware makes bits shifted in 0\n#define BITMASK64(n) ((~0ull) &gt;&gt; 64-bits)\n#define BITMASK64_L(n) ~((~0ull) &gt;&gt; bits) // left justified bitmask, assumes the hardware makes bits shifted in 0\n#define ROTL32(data, bits) ((data &lt;&lt; bits) | data &gt;&gt; 32-bits) &amp; ~0ul\n#define ROTR32(data, bits) ((data &gt;&gt; bits) | data &lt;&lt; 32-bits) &amp; ~0ul\n#define ROTL64(data, bits) ((data &lt;&lt; bits) | data &gt;&gt; 64-bits) &amp; ~0ull\n#define ROTR64(data, bits) ((data &gt;&gt; bits) | data &lt;&lt; 64-bits) &amp; ~0ull\n\nBYTE Salt[0xB] = &lt;redacted&gt;;\nBYTE BLKey[0x10] = { &lt;redacted&gt; };\nXECRYPT_RSAPUB_2048 xRSA;\nxRSA = &lt;redacted&gt;\n\ntypedef struct _BLHeader\n{\n    WORD Magic;         // 0 : 2\n    WORD Version;       // 2 : 2\n    DWORD Flags;        // 4 : 4\n    DWORD EntryPoint;   // 8 : 4\n    DWORD Size;         // 0xC : 4\n    BYTE key[0x10];     // 0x10 : 0x10\n    QWORD Pad[4];       // 0x20 : 0x20\n    XECRYPT_SIG Sig;    // 0x40 : 0x100\n    // Header: 0x140\n}BLHeader, *PBLHeader;\n\n// write to the post bus\nvoid POST(QWORD postCode)\n{\n    HW_REG_POST = (postCode &lt;&lt; 56);\n}\n\n// outputs a given byte, then the same byte OR'ed with 0x80\n// probably for their internal post sniffer\nvoid POST_DATA(BYTE outPost)\n{\n    POST(outPost);\n    POST(outPost | 0x80);\n}\n\n// outputs a given amount of bytes from a given address in high-low format\nvoid POST_ADDRESS(QWORD pqwAddy, DWORD cbAddy)\n{\n    for(int i = 0;i &lt; cbAddy;i++)\n    {\n        BYTE bData = *(BYTE*)pqwAddy+i;\n        POST(data &gt;&gt; 4); // output high\n        POST(data &amp; 0xF); // output low\n    }\n}\n\nvoid PanicGen()\n{\n    while(1)\n        continue;\n}\n\nvoid Panic(QWORD postCode)\n{\n    POST(postCode);\n    PanicGen();\n}\n\nQWORD ReadHighestByte(QWORD Address)\n{\n    return ((*(QWORD*)Address) &gt;&gt; 56);\n}\n\nDWORD sub_36A8()\n{\n    DWORD ret = ReadHighestByte(HW_REG_61008);\n    if((ret &amp; 0x80) != 0)\n        ret = (~ret) &amp; 0xFF;\n    return = ret &amp; 0xF8;\n}\n\n// rough translation for the cntlzw instruction\nDWORD countLeadingZeros(DWORD data)\n{\n    DWORD count = 0;\n    for(int i = 0;i &lt; 31;i++)\n    {\n        if(data &gt;&gt; 31-i)\n            return count;\n        count++;\n    }\n}\n\n/*\nBasically this happens when its detected that the\nSOC doesn't carry correct values, it goes into a loop\nand starts outputting data from a certain SOC register\n(0x8000020000061008) - possibly error register?\n\nIt doesn't repeat it's output unless the SOC register changes\n*/\nvoid HARDWARE_ERROR_PRINT(DWORD dwUnk1)\n{\n    while(1)\n    {\n        BYTE bUnk1_p = ROTL32(dwUnk1, 3) &amp; 0x1F;\n        POST_DATA(bUnk1_p | 0x60);\n\n        BYTE tmp = 0;\n        BYTE bUnk1 = dwUnk1 &amp; FF;\n\n        if(bUnk1 == 0x78)\n            tmp = 1;\n        else\n        {\n            if(bUnk1 == 0)\n                sub_3878(tmp);\n            else if(bUnk1 == 8)\n                sub_38B8(tmp);\n            else if(bUnk1 == 0x10)\n                sub_3AE0(tmp);\n            else if(bUnk1 == 0x18)\n                sub_3B30(tmp);\n            else if(bUnk1 == 0x20)\n                sub_3BB0(tmp);\n            else if(bUnk1 == 0x28)\n                sub_39C8(tmp);\n            else if(bUnk1 == 0x30)\n                sub_3F88(tmp, PCI + 0x8000);\n            else if(bUnk1 == 0x38)\n                sub_3C78(tmp);\n            else if(bUnk1 == 0x40)\n                sub_3D08(tmp);\n            else if(bUnk1 == 0x48)\n                sub_3DE0(tmp);\n            else if(bUnk1 == 0x50)\n                POST_ADDRESS(TOCP+2, 2);\n            else if(bUnk1 == 0x58)\n                sub_3F88(tmp, PCI);\n            else if(bUnk1 == 0x60)\n                sub_4008(tmp);\n            tmp = 0;\n        }\n\n        POST_DATA(bUnk1_p | 0x70);\n\n        DWORD r30 = (countLeadingZeros(bUnk1-0x50) &gt;&gt; 27) &amp; 1;\n        do\n        {\n            for(int i = 1;i &lt; 6;i++)\n            {\n                DWORD dwUnk2 = sub_36A8();\n                if(dwUnk1 &amp; 0xFF != dwUnk2 &amp; 0xFF)\n                {\n                    dwUnk1 = dwUnk2;\n                    i = 0;\n                }\n            }\n        } while(((countLeadingZeros((dwUnk1 &amp; 0xFF) - 0x50) &gt;&gt; 27) &amp; 1) == r30);\n    }\n}\n\nbool CB_VerifyOffset(DWORD offset, DWORD arg2)\n{\n    if(offset != (offset + 0xF) &amp; 0xFFFFFFF0)\n        return false;\n    if(offset - 0x80 &gt; 0x7FFFF7F)\n        return false;\n    if((arg2 + 0xF) &amp; 0xFFFFFFF0 &gt;= offset - 0x8000000)\n        return false;\n    return true;\n}\n\n// Copies by 0x10 byte blocks\n// cBlocks: how many 0x10 byte blocks to copy\nvoid CB_Copy(QWORD dest, QWORD src, DWORD cBlocks)\n{\n    for(int i = 0; i &lt; cBlocks; i++)\n    {\n        *(QWORD*)dest+(i*0x10) = *(QWORD*)src+(i*0x10);\n        *(QWORD*)dest+(i*0x10)+8 = *(QWORD*)src+(i*0x10)+8;\n    }\n}\n\nvoid CB_Jump(QWORD address, QWORD arg2)\n{\n    // grabs data from the CB before nulling the area\n    QWORD r27 = *(QWORD*)SRAM+0x20;\n    QWORD r28 = *(QWORD*)SRAM+0x28;\n    QWORD r29 = *(QWORD*)SRAM+0x30;\n    QWORD r30 = *(QWORD*)SRAM+0x38;\n    // nulls 0x20-0x140(?)\n    QWORD tmp = SRAM+0x20;\n    for(int i = 0; i &lt; 0x12; i++)\n    {\n        *tmp+(i*0x10) = 0ULL;\n        *tmp+(i*0x10)+8 = 0ULL;\n    }\n\n    // check the size\n    tmp = (((*(DWORD*)SRAM+0xC) + 0xF) &amp; 0xFFFFFFF0);\n    if(tmp &gt;= 0x10000)\n        Panic(0x98);\n\n    // nulls the area after the CB\n    QWORD addy = tmp + SRAM;\n    for(int i = 0; i &lt; (tmp - 0x10000) &gt;&gt; 4; i++)\n    {\n        *addy+(i*0x10) = 0ULL;\n        *addy+(i*0x10)+8 = 0ULL;\n    }\n\n    // sets up tlb page\n    // sets registers r0-r26 to 0\n    // jump to CB\n    goto (address &amp; 0xFFFF) + 0x2000000;\n    return;\n}\n\nvoid CB_Load()\n{\n    POST(0x11);\n    FSB1(); // sub_3450\n\n    POST(0x12);\n    FSB2(); // sub_34D0\n\n    POST(0x13);\n    FSB3(); // sub_35A8\n\n    POST(0x14);\n    FSB4(); // sub_3658\n\n    POST(0x15);\n    DWORD cbOffset = *(DWORD*)NAND+8; // r25\n    if(!CB_VerifyOffset(cbOffset, 0x10))\n        Panic(0x94);\n\n    POST(0x16);\n    QWORD cbNAddy = NAND+cbOffset; // r26\n    CB_Copy(SRAM, cbNAddy, 1);\n\n    POST(0x17);\n    PBLHeader cbHeader = (PBLHeader)SRAM;\n    if((cbHeader-&gt;Size - 0x264) &gt; 0xBD9C\n        || (cbHeader-&gt;Magic &amp; 0xFFF) != 0x342\n        || (cbHeader-&gt;EntryPoint &amp; 0x3)\n        || (cbHeader-&gt;EntryPoint) &lt; 0x264 // on slim its &lt; 0x3B8\n        || (cbHeader-&gt;Size &amp; 0xFFFFFFFC) &gt;= (cbHeader-&gt;EntryPoint &amp; 0x3) // doesn't make sense, check later offset 0x4340 - On slim it makes sense: if(entrypoint &gt;= size &amp; 0xFFFFFFFC) panic\n        || !CB_VerifyOffset(cbOffset, cbHeader-&gt;Size))\n        Panic(0x95);\n\n    POST(0x18);\n    QWORD tmp = ((cbHeader-&gt;Size + 0xF) &amp; 0xFFFFFFF0);\n    CB_Copy(SRAM+0x10, cbNAddy+0x10, (tmp - 0x10) &gt;&gt; 4);\n\n    POST(0x19);\n    // overwrites the old key with the new one\n    XeCryptHmacSha(BLKey, 0x10, &amp;cbHeader-&gt;key, 0x10, 0, 0, 0, 0, &amp;cbHeader-&gt;key, tmp);\n\n    POST(0x1A);\n    XECRYPT_RC4_STATE rc4;\n    XeCryptRc4Key(&amp;rc4, cbHeader-&gt;key, 0x10); // key = HmacSha(1BLKey, cbKey, 0x10)\n\n    POST(0x1B);\n    XeCryptRc4Ecb(&amp;rc4, SRAM+0x20, tmp - 0x20); // Decrypts everything after the header\n\n    POST(0x1C);\n    BYTE Hash[0x14] = { 0 };\n    XeCryptRotSumSha(SRAM, 0x10, SRAM+0x140, tmp - 0x140, Hash, 0x14); // hashes everything after the sig\n\n    POST(0x1D);\n    if(XeCryptBnQwBeSigDifference(&amp;cbHeader-&gt;Sig, Hash, Salt, &amp;xRSA)) // checks sig against hash with public rsa key\n        Panic(0x96);\n\n    POST(0x1E);\n    CB_Jump(cbHeader-&gt;EntryPoint, tmp+cbOffset); // sets up tbl page and loads some registers before jumping to cb\n    return;\n}\n\nvoid BL_1()\n{\n    // thread check?\n\n    POST(0x10); // entered 1bl\n\n    // null the sram area\n    for(int i = 0; i &lt; 0x1000; i++)\n    {\n        *(QWORD*)SRAM+(i*0x10) = 0ULL;\n        *(QWORD*)SRAM+((i*0x10)+8) = 0ULL;\n    }\n\n    DWORD tmp = sub_36A8();\n    if((tmp &amp; 0xFF) == 0x50)\n        HARDWARE_ERROR_PRINT(tmp); // look into later\n\n    // load and execute the CB\n    CB_Load();\n\n    // CB_Load shouldn't return...\n    PanicGen();\n\n    return;\n}\n</code></pre>"},{"location":"System-Software/360_System_Software/","title":"System Software","text":"<p>The Xbox's Original Software is composed of many things, including the bootloaders, the kernel, the dashboard and more.</p>"},{"location":"System-Software/360_System_Software/#bootloaders","title":"Bootloaders","text":"<p>The Xbox 360 system uses a series of bootloaders to load the hv/kernel and dashboard. These loaders are explained at Boot Process.</p>"},{"location":"System-Software/360_System_Software/#hypervisor","title":"Hypervisor","text":"<p>The Hypervisor is the main operating system being run on the console. It looks after the kernel and stops things like buffer overflows from happening. It also manages a lot of the security aspects of the 360, including memory encryption and region protection. It has code to handle the XeKeys (keyvault + some static ones) and XEXs. The end-user of an Xbox would never have any knowledge of the hypervisor, it's only really interesting for hackers.</p>"},{"location":"System-Software/360_System_Software/#kernel","title":"Kernel","text":"<p>The Xbox 360's Kernel is responsible for low level hardware communication and more. This is the main part of the 360, the kernel is where all the user-based stuff happens. The drivers for accessing most of the hardware is located in the Kernel, along with certain drivers for other things used by the system (e.g. FATX (File Allocation Table for Xbox), STFS (Secure Transacted File System), SFCX (System Flash Controller for Xbox). This is the most interesting part of the console because of all the functions it performs.</p> <p>You can check your kernel version in \"System -&gt; Console Settings -&gt; System Info\". The line at the bottom contains your kernel version in the format K:2.0.nnnnn.0, where nnnnn is your kernel version.</p>"},{"location":"System-Software/360_System_Software/#xam","title":"XAM","text":"<p>A lot of fun things are inside XAM. XAM handles gamer profiles and online interactivity, so as you can guess not a lot of information is made public about it. XeDevWiki hopes to change that. XAM handles such things as XDBF (Xbox Database File) files (GPD (Gamer Progress Data)/SPA) and PEC (Profile Embedded Content) files.</p>"},{"location":"System-Software/360_System_Software/#file-systems","title":"File Systems","text":"<p>The Xbox 360 uses various File Systems for storing games, user content and more.</p> <p>FATX (File Allocation Table for Xbox) is used as the storage filesystem on hard drives/memory units/USB devices/xlaunch.fdf files.</p> <p>GDFX/XSF (Game Disc Format for Xbox) is the filesystem used on X360 CD/DVD Media.</p> <p>STFS (Secure Transacted File System) is used for game saves, profiles, arcade games, downloadable content and more. STFS is also referred to as CON/LIVE/PIRS files, as they are all STFS files, just signed with a different header.</p> <p>(SFCX Secure File Cache for Xbox) :is used for cache storage for games.</p> <p>NAND File System is used to store the bootloaders, kernel, keyvault and other files on the NAND.</p>"},{"location":"System-Software/360_System_Software/#file-formats","title":"File Formats","text":"<p>The Xbox 360 also uses different File Formats for storage of data, as storage on the Xbox is limited, these files are usually binary. XeNTaX.com is a DataBase of hundreds of different file formats, which may be of help.</p> <p>PEC (Profile Embedded Content) is used as another layer of security inside profiles.</p> <p>STFS (Secure Transacted File System) is used for secure storage of files on memory devices.</p> <p>XDBF/GPD/SPA (Xbox Dashboard File/Gamer Profile Data/Statistics, Presence and Achievements) is used for profiles (achievements/settings/titles) and games (achievements/strings/ratings).</p> <p>XEX (Xenon Executable) is the executable format used by the Xbox 360.</p> <p>XMI(Xenon Music Index) is used to index music on the Xbox.</p> <p>System Software</p>"},{"location":"System-Software/849x_System_Update/","title":"From Free60","text":"<p>Felix Domke, Michael Steil, Free60 Project 11 August 2009</p>"},{"location":"System-Software/849x_System_Update/#dangerous-xbox-360-update-killing-homebrew","title":"Dangerous Xbox 360 Update Killing Homebrew**","text":"<p>On Tuesday, Microsoft has released an Xbox 360 software update that overwrites the first stage bootloader of the system. Although there have been numerous software updates for Microsoft's gaming console in the past, this is the first one to overwrite the vital boot block. Any failure while updating this will break the Xbox 360 beyond repair. Statistics from other systems have shown that about one in a thousand bootloader updates goes wrong, and unless Microsoft has a novel solution to this problem, this puts tens of thousands of Xboxes at risk.</p> <p>It seems that this update is being done to fix a vulnerability already known to the Free60 Project. This vulnerability has been successfully exploited to run arbitrary code, and a complete end user compatible hack has been in development for some time and is planned to be released on free60.org shortly. It will allow users to take back control of their Xboxes and run arbitrary code like homebrew applications or Linux right after turning on the console and without the need of a modchip, finally opening up the Xbox 360 to a level of hacking as the original Xbox.</p> <p>Because of the dangerousness of the update and the homebrew lockout, the Free60 Project advises all Xbox 360 users to not update their systems to the latest software version. The Project website at http://free60.org/ will provide the latest information on this ongoing topic, including the final hack software.</p> <p>Free60 (www.free60.org) is a project that aims to enable Xbox 360 users to run homebrew applications and operating systems like Linux on their consoles. The effort is headed by Felix Domke and Michael Steil, who have a background in dbox2, Xbox and GameCube hacking, and who have spoken at various conferences about their findings. Two years ago, Free60 released a hack that allowed arbitrary code execution using a game (\"King Kong Hack\") as well as an adapted version of Linux, but this possibility has been disabled by Microsoft in subsequent updates of the Xbox 360 software.</p> <p>Felix and Michael have repeatedly argued that game console manufacturers should open up their platforms to Linux and homebrew, similar to what Sony has done with the PlayStation 3, before they removed the functionality of course.</p> <p>System Software</p>"},{"location":"System-Software/Boot_Process/","title":"Boot process","text":"<p>This page details the boot process used in the Xbox 360. The process is slightly different between Devkit/Retail and certain boxes which have a secondary CB loader (trinity/some jaspers)</p>"},{"location":"System-Software/Boot_Process/#retail","title":"Retail","text":"<p>In Summary:</p> <ul> <li>Slim: 1BL -&gt; CB_A -&gt; CB_B -&gt; CD -&gt; CF -&gt; CD -&gt; HV -&gt; Kernel -&gt; Dashboard</li> <li>Phat (older): 1BL -&gt; CB -&gt; CD -&gt; CF -&gt; CD -&gt; HV -&gt; Kernel -&gt; Dashboard</li> <li>Phat (newer): 1BL -&gt; CB_A -&gt; CB_B -&gt; CD -&gt; CF -&gt; CD -&gt; HV -&gt; Kernel -&gt; Dashboard</li> </ul>"},{"location":"System-Software/Boot_Process/#1bl-inside-cpu","title":"1BL (Inside CPU)","text":"<p>Loads and decrypts CB(_A) into ram, it computes a RotSumSha1 of CB(_A) and uses it to verify its RSA signature. If the signature is valid, 1BL jumps to CB(_A).</p> <p>You can find reversed pseudocode of the 1bl here: 1BL Code</p>"},{"location":"System-Software/Boot_Process/#cb","title":"CB","text":"<p>SLIMS ONLY: CB_A loads and decrypts CB_B into ram, it computes a RotSumSha1 of CB_B and checks it against the known hash. If it matches CB_A jumps to CB_B.</p> <p>CB(_B) starts up a virtual machine, which does:</p> <pre><code>- initializes the PCI Bridge\n- disables the GPU PCIE JTAG test port\n- initializes the serial port\n- talks to the SMC to clear the \"handshake\" bit\n- initializes memory\n- generates RROD if memory init fails\n</code></pre> <p>CB(_B) loads and decrypts CD into ram, it computes a RotSumSha1 of CD and checks it against the known hash. If it matches CB(_B) jumps to CD.</p> <p>Methods to dump the CB bootloaders and examples of them reversed can be found here: CB Code</p>"},{"location":"System-Software/Boot_Process/#cd","title":"CD","text":"<p>Loads and decrypts CE into ram, computes a RotSumSha1 of CE. If it matches the known hash, it decompresses the LZX compressed base kernel. It then checks for patch slots. If it finds one, it will load and decrypt the corresponding CF bootloader for that patch. It then computes a RotSumSha1 of CF and uses it to verify the CF loaders signature. If the signature is valid, CD stays in memory but jumps to CF.</p> <p>There can be up to 2 CF/CG pairs for patching the kernel.</p>"},{"location":"System-Software/Boot_Process/#cf","title":"CF","text":"<p>Loads CG into memory by reading the CG data in the NAND header and then reads the rest of the CG data from the CG blocks specified in CF header. It then decrypts the CG in memory using the key generated from decrypting CF. To verify it, it computes a RotSumSha1 and checks it against the known hash. If it matches, it uses LZX delta decompress to apply the patch to the base kernel in memory. Once its done, it jumps back to CD and once CD has finished up, it jumps to the reset vector in the Hypervisor.</p>"},{"location":"System-Software/Boot_Process/#devkit","title":"Devkit","text":"<p>In Summary:</p> <ul> <li>Phat: 1BL -&gt; SB -&gt; SC -&gt; SD -&gt; HV -&gt; Kernel -&gt; Dashboard</li> </ul> <p>The devkit bootloaders are nearly identical to their retail counterparts; however instead of hardcoded hash checks, devkits verify bootloaders SD and SE by signature checks.</p> <p>The SC bootloader is the hardware initialization virtual machine run by SB.</p> <p>Because devkits do not update over the air, they use a pre-patched SE (HV + kernel) bootloader) without delta patching CF/CG pairs.</p>"},{"location":"System-Software/Boot_Process/#kernel","title":"Kernel","text":"<p>Once control is handed off to the kernel, as denoted by the POST output, the kernel does the following (on development systems):</p> <ul> <li>Initialize memory manager</li> <li>Initialize stack(s)</li> <li>Initialize object system (?)</li> <li>Initialize phase 1 thread (?)</li> <li>Phase 1 initialization and processors initialization</li> <li>Initialize keyvault</li> <li>Initialize HAL phase 1</li> <li>Initialize SFC driver (?)</li> <li>Initialize security (?)</li> <li>INIT_KEY_EX_VAULT</li> <li>Initialize settings (?)</li> <li>Initialize power mode</li> <li>Initialize video driver</li> <li>Initialize audio driver</li> <li>Initialize boot animation<ul> <li>Loads bootanim.xex</li> </ul> </li> <li>Initialize SATA driver</li> <li>Initialize Shadowboot (not on retail   systems)</li> <li>INIT_DUMP_SYSTEM (?) (not on retail systems)</li> <li>INIT_SYSTEM_ROOT (?)</li> <li>Initialize other drivers</li> <li>Initialize STFS driver</li> <li>Initialize XAM</li> </ul>"},{"location":"System-Software/Boot_Process/#core-os-executables","title":"Core OS Executables","text":"<p>After its initialization sequence, the kernel loads the following executables (in order)</p> <ul> <li>xam.xex</li> <li>xbdm.xex</li> <li>xstudio.xex</li> <li>ximecore.xex</li> <li>Xam.Community.xex (from disk)</li> <li>huduiskin.xex</li> <li>xshell.xex (devkits) / dash.xex (retail)</li> </ul> <p>It then unloads the following:</p> <ul> <li>huduiskin.xex</li> <li>bootanim.xex</li> </ul> <p>By this time the console will have booted into the dashboard</p> <p>System Software</p>"},{"location":"System-Software/Bootloaders/","title":"Bootloaders","text":"<p>The Xbox 360 system uses a series of bootloaders to load the hv/kernel and dashboard. These loaders are explained at Boot Process.</p>"},{"location":"System-Software/Bootloaders/#header","title":"Header","text":"<p>The header is at the start of the bootloader and is usually 0x20 bytes long.</p> Offset Length Type Information 0x0 0x2 ASCII characters Loader name 0x2 0x2 unsigned short Loader build number 0x4 0x2 unsigned short Loader pairing data 0x6 0x2 unsigned short Loader flags 0x8 0x4 unsigned integer Loader entrypoint 0xC 0x4 unsigned integer Loader length (including header) 0x10 0x10 bytes HMAC salt (used for decrypting the loader) <p>System Software</p>"},{"location":"System-Software/CB_Code/","title":"CB Code","text":"<p>Some notes on the mfg version to start with:</p> <ul> <li>In the mfg version of the CB_A, the cpukey is set to null and   XeCryptHmacSha is given the null buffer to generate the next key</li> <li>Other than that there is no other change in the mfg version, boot   process seems to continue as normal unless I'm overlooking a flag   being set</li> <li>It seems the mfg version is signed, which means we should be   able to flash it to consoles without an issue and then we wouldn't   have to worry about cpukeys for the cb at least. xebuild doesn't do   that, I wonder why</li> </ul>"},{"location":"System-Software/CB_Code/#cb-dump","title":"CB Dump","text":"<pre><code>// BLKey = 1BL Key\n// Hvx methods are meant to be proxies to read HV memory from user mode.\n#define SPACE_NAND 0x80000200C8000000ULL\n\nvoid getCB_AKey(PBYTE Keybuf)\n{\n    QWORD cbAddy = SPACE_NAND + Hvx::HvPeekDWORD(SPACE_NAND + 8);\n    BYTE cbSalt[0x10];\n    Hvx::HvPeekBytes(cbAddy+0x10, cbSalt, 0x10);\n    XeCryptHmacSha(BLKey, 0x10, cbSalt, 0x10, 0, 0, 0, 0, Keybuf, 0x10);\n}\n\nvoid getCB_BKey(PBYTE Keybuf)\n{\n    DWORD cbOffs = Hvx::HvPeekDWORD(SPACE_NAND + 8);\n    DWORD cbbOffs = cbOffs + (Hvx::HvPeekDWORD(SPACE_NAND + cbOffs + 0xC) + 0xF) &amp; 0xFFFFFFF0;\n    QWORD cbbAddy = SPACE_NAND + cbbOffs;\n\n    BYTE cbbSalt[0x10];\n    BYTE cbKey[0x10];\n    BYTE CPUKey[0x10];\n    getCB_AKey(cbKey);\n    getCPUKey(CPUKey);\n    Hvx::HvPeekBytes(cbbAddy+0x10, cbbSalt, 0x10);\n    XeCryptHmacSha(cbKey, 0x10, cbbSalt, 0x10, CPUKey, 0x10, 0, 0, Keybuf, 0x10);\n}\n\nvoid DumpCB_A()\n{\n    DbgOut(\"Dumping CB_A....\\n\");\n    QWORD cbAddy = SPACE_NAND + Hvx::HvPeekDWORD(SPACE_NAND + 8);\n    DWORD size = Hvx::HvPeekDWORD(cbAddy+0xC);\n    printf(\"cbAddy: %016llX\\nSize: %X\\n\", cbAddy, size);\n    PBYTE cb = (PBYTE)XPhysicalAlloc(size, MAXULONG_PTR, NULL, PAGE_READWRITE);\n    Hvx::HvPeekBytes(cbAddy, cb, size);\n    CWriteFile(\"Hdd:\\\\cb_enc.bin\", cb, size);\n\n    BYTE rc4key[0x10];\n    getCB_AKey(rc4key);\n    XECRYPT_RC4_STATE rc4;\n    XeCryptRc4Key(&amp;rc4, rc4key, 0x10);\n    XeCryptRc4Ecb(&amp;rc4, cb + 0x20, size - 0x20);\n    CWriteFile(\"Hdd:\\\\cb_dec.bin\", cb, size);\n    XPhysicalFree(cb);\n}\n\nvoid DumpCB_B()\n{\n    DbgOut(\"Dumping CB_B....\\n\");\n    DWORD cbOffs = Hvx::HvPeekDWORD(SPACE_NAND + 8);\n    DWORD cbbOffs = cbOffs + (Hvx::HvPeekDWORD(SPACE_NAND + cbOffs+0xC) + 0xF) &amp; 0xFFFFFFF0;\n    QWORD cbbAddy = SPACE_NAND + cbbOffs;\n    DWORD size = Hvx::HvPeekDWORD(cbbAddy + 0xC);\n    printf(\"cbbOffs: 0x%08X\\ncbbAddy: 0x%016llX\\nSize: 0x%X\\n\", cbbOffs, cbbAddy, size);\n    PBYTE cbb = (PBYTE)XPhysicalAlloc(size, MAXULONG_PTR, NULL, PAGE_READWRITE);\n    Hvx::HvPeekBytes(cbbAddy, cbb, size);\n    CWriteFile(\"Hdd:\\\\cbb_enc.bin\", cbb, size);\n\n    BYTE cbbKey[0x10];\n    getCB_BKey(cbbKey);\n    XECRYPT_RC4_STATE rc4;\n    XeCryptRc4Key(&amp;rc4, cbbKey, 0x10);\n    XeCryptRc4Ecb(&amp;rc4, cbb + 0x20, size - 0x20);\n    CWriteFile(\"Hdd:\\\\cbb_dec.bin\", cbb, size);\n    XPhysicalFree(cbb);\n}\n</code></pre>"},{"location":"System-Software/CB_Code/#cb_a-pseudocode","title":"CB_A Pseudocode","text":"<p>Version: 9188 retail</p> <pre><code>// version: 0x23E4\n// entry: 0x3C0\n// size: 0x1AC0\n\n// registers preset by the 1bl\n// r27: not used\n// r28: not used\n// r29: not used\n// r30: not used\n// r31: next bl (cbb nand offset)\n//          CB_A nand offset + CB_A size aligned to the upper 0x10 byte (ex: size = (size+0xF) &amp; 0xFFFFFFF0)\n\n#define STACK   0x800002000001F700 // r1\n#define TOC     0x800002000001C000 // r2\n#define SRAM    0x8000020000010000\n#define POSTo   0x8000020000061010\n#define NAND    0x80000200C8000000\n#define SOC     0x8000020000020000\n\n// an attempt to make this easier to read\n#define read64(addy) *(QWORD*)addy\n#define read32(addy) *(DWORD*)addy\n#define read16(addy) *(WORD*)addy\n#define write64(addy, data) *(QWORD*)addy = data\n#define write32(addy, data) *(DWORD*)addy = data\n#define write16(addy, data) *(WORD*)addy = data\n\ntypedef struct _BLHeader\n{\n    WORD Magic;         // 0 : 2\n    WORD Version;       // 2 : 2\n    DWORD Flags;        // 4 : 4\n    DWORD EntryPoint;   // 8 : 4\n    DWORD Size;         // 0xC : 4\n    BYTE key[0x10];     // 0x10 : 0x10\n    QWORD Pad[4];       // 0x20 : 0x20\n    // not used here? XECRYPT_SIG Sig;  // 0x40 : 0x100\n    // Header: 0x140\n}BLHeader, *PBLHeader;\n\nvoid POST(BYTE postCode)\n{\n    write64(POSTo, (postCode &lt;&lt; 56));\n}\n\nvoid PanicGen()\n{\n    while(1)\n        continue;\n}\n\nvoid Panic(QWORD postCode)\n{\n    POST(postCode);\n    PanicGen();\n}\n\nbool VerifyOffset(DWORD offset, DWORD arg2)\n{\n    if(offset != (offset + 0xF) &amp; 0xFFFFFFF0)\n        return false;\n    if(offset - 0x80 &gt; 0x7FFFF7F)\n        return false;\n    if(arg2 &amp; 0xFFFFFFF0 &gt;= offset - 0x8000000)\n        return false;\n    return true;\n}\n\n// Copies by 0x10 byte blocks\n// cBlocks: how many 0x10 byte blocks to copy\nvoid CopyBy128(QWORD dest, QWORD src, DWORD cBlocks)\n{\n    for(int i = 0; i &lt; cBlocks; i++)\n    {\n        write64(dest+(i*0x10), read64(src+(i*0x10)));\n        write64(dest+(i*0x10)+8, read64(src+(i*0x10)+8))\n    }\n}\n\nvoid ZeroBy128(QWORD addy, QWORD count)\n{\n    for(int i = 0; i &lt; count; i++)\n    {\n        write64(addy+(i*0x10), 0ULL);\n        write64(addy+(i*0x10)+8, 0ULL);\n    }\n\n}\n\nQWORD getFuseline(DWORD fuse)\n{\n    if ((fuse * 0x40) &lt; 0x300)\n        return read64(SOC + ((fuse * 0x40) &lt;&lt; 3));\n    return 0;\n}\n\nvoid CBB_Jump(QWORD EntryPoint, QWORD NextBL)\n{\n    // presets for the next bootloader\n    QWORD r27 = read64(SRAM + 0x20);\n    QWORD r28 = read64(SRAM + 0x28);\n    QWORD r29 = read64(SRAM + 0x30);\n    QWORD r30 = read64(SRAM + 0x38);\n    QWORD r31 = NextBL; // nand offset of the next bl\n\n    // null the beginning of the cbb\n    ZeroBy128(SRAM + 0x20, 0x12);\n\n    DWORD tSize = (read32(SRAM + 0xC) + 0xF) &amp; 0xFFFFFFF0;\n    if(tSize &gt; 0xC000)\n        Panic(0xF3);\n\n    // null the area after the cbb\n    ZeroBy128(SRAM + tSize, (0xC000 - tSize) &gt;&gt; 4);\n\n    // Sets r0-r26 and the CTR to 0\n\n    // jump to cbb\n    EntryPoint = (EntryPoint &amp; 0xFFFF) + 0x2000000;\n    goto EntryPoint;\n}\n\nvoid CBB_Load(const QWORD offCBB, QWORD destCBB)\n{\n    // first null the stack\n    for(int i = 0; i &lt; 0xB; i++)\n        write64(stack-0x1A8+(i*8), 0ULL);\n\n    POST(0xD1); // copy fuses for CBB decryption\n    QWORD fuses[12] = { 0 };\n    BYTE CPUKey[0x10] = { 0 };\n\n    // if this is the mfg cb_a or a dev cb_a then the cpukey is set to 0\n#ifdef RETAIL\n    for(int i = 0; i &lt; 12; i++)\n        getFuseline(i);\n    QWORD fuse = fuses[3] | fuses[4]; // first CPUKey fuses\n    write64(CPUKey, fuse);\n    fuse = fuses[5] | fuses[6]; // second CPUKey fuses\n    write64(CPUKey+8, fuse);\n#endif\n\n    POST(0xD2); // verify CBB offset\n    DWORD cbbOffset = offCBB &amp; 0xFFFFFFFF; // r28\n    if(!VerifyOffset(cbbOffset, 0x10))\n        Panic(0xF0);\n\n    POST(0xD3); // copy cbb header to sram\n    QWORD cbbAddy = NAND + cbbOffset;\n    CopyBy128(destCBB, cbbAddy, 1);\n\n    POST(0xD4); // verify header\n    PBLHeader cbbHeader = (PBLHeader)destCBB;\n    if((cbbHeader-&gt;Size - 0x3C0) &gt; 0xBC40 // size check\n        || cbbHeader-&gt;Magic != read64(TOC) &amp; 0xFFFF // magic check\n        || cbbHeader-&gt;EntryPoint &amp; 0x3 // alignment check\n        || cbbHeader-&gt;EntryPoint &lt; 0x3C0 // EntryPoint check\n        || cbbHeader-&gt;EntryPoint &gt;= cbbHeader-&gt;Size &amp; 0xFFFFFFFC // entrypoint/size relation check\n        || !VerifyOffset(cbbOffset, cbbHeader-&gt;Size))\n        Panic(0xF1);\n\n    POST(0xD5); // copy cbb to SRAM\n    QWORD tSize = (cbbHeader-&gt;Size + 0xF) &amp; 0xFFFFFFF0;\n    CopyBy128(destCBB + 0x10, cbbAddy + 0x10, ((tSize - 0x10) &gt;&gt; 4) &amp; 0xFFFFFFFF);\n\n    POST(0xD6); // Gen cbb key\n    // cbb key = hmacsha of the cb_a key, cb_b salt, and CPUKey\n    XeCryptHmacSha(TOC+0x10, 0x10, &amp;cbbHeader-&gt;key, 0x10, CPUKey, 0x10, 0, 0, &amp;cbbHeader-&gt;key, 0x10);\n\n    POST(0xD7); // set key\n    XECRYPT_RC4_STATE rc4;\n    XeCryptRc4Key(&amp;rc4, &amp;cbbHeader-&gt;key, 0x10);\n\n    POST(0xD8); // decrypt cbb\n    XeCryptRc4Ecb(&amp;rc4, SRAM+0x20, tSize-0x20);\n\n    POST(0xD9); // generate hash\n    BYTE Hash[0x14] = { 0 };\n    XeCryptRotSumSha(SRAM, 0x10, SRAM+0x140, tSize-0x140, Hash, 0x14);\n\n    POST(0xDA); // verify integrity\n    if(memcmp(Hash, TOC+0x39C, 0x14))\n        Panic(0xF2);\n\n    POST(0xDB); // jump to cbb\n    write16(SRAM+6, read16(SRAM+6)); // copy flags\n    CBB_Jump(cbbHeader-&gt;EntryPoint, tSize+offCBB);\n    return;\n}\n\nvoid CBA_Main()\n{\n    // registers 27-31 are preset by the 1bl opon entry\n    POST(0xD0); // CB_A entry, copy self to 0x800002000001C000 and continue from there\n    DWORD size = *(QWORD*)SRAM+0xC;\n    size = (size+0xF) &gt;&gt; 3;\n    for(int i = 0; i &lt; size; i++)\n        write64(TOC+(i*8), read64(SRAM+(i*8)));\n\n    // from now on we're executing from 0x800002000001C000\n    CBB_Load(r31, SRAM);\n}\n</code></pre>"},{"location":"System-Software/Console_Security_Certificate/","title":"Console Security Certificate","text":"<p>The Console Security Certificate is used by the Xbox 360 as the format of all RSA signatures generated by it. The total length of the certificate is 552 (0x228) bytes.</p>"},{"location":"System-Software/Console_Security_Certificate/#structure","title":"Structure","text":"Offset Length Type Information 0x0 0x2 bytes Public Key Certificate Size 0x2 0x5 bytes Console ID 0x7 0xB ascii string Console Part Number 0x12 0x4 int Reserved 0x16 0x2 short Privileges 0x18 0x4 int Console Type (0x02 for retail, anything different is devkit) 0x1C 0x8 ascii string Certificate Date of Generation 0x24 0x4 bytes Public Exponent 0x28 0x80 bytes Public Modulus 0xA8 0x100 bytes Certificate Signature 0x1A8 0x80 bytes Signature"},{"location":"System-Software/Console_Security_Certificate/#notes","title":"Notes","text":"<p>The console type field can be very strange, especially with older pre-1888 dashboards, for example two different 1838 keyvaults identify their console type as 0x80000002. If you want to check if something is devkit or retail, I'd suggest something like:</p> <pre><code>if(consoletype == 0x02)\n    return retail;\nelse\n    return devkit;\n</code></pre> <p>System Software</p>"},{"location":"System-Software/Error_Codes/","title":"Error codes","text":""},{"location":"System-Software/Error_Codes/#general-information","title":"General Information","text":"<p>E64: Unknown</p> <p>E66: The key of the DVD drive firmware doesn't match the key of the motherboard.</p> <p>E68: HDD Failed to initialize.</p> <p>E74: According to Dennis Mooney (Xbox ATG) on the 360 dev forums E 74 is HSIO Calibration failed. (HSIO is that insanely fast bus between the EDRAM and the Xenos core. It needs to be \"trained\" to be reliable.)</p> <p>E79: Unknown</p>"},{"location":"System-Software/Error_Codes/#confirmed-facts","title":"Confirmed facts","text":"<p>When the Xbox crashes half way loading a game disc (e.g. Due to bad unreadable sectors half way)</p> <ul> <li>It halts itself to a freeze: The Screen which was active, remains.</li> <li>Eject does not do anything</li> <li>USB Devices are no longer working</li> <li>Wireless Controller does not connect</li> <li>Plugging in a USB Controler only lights up Left Corner, and Right   Down Corner</li> <li>Unconnected Video Out Cable results in red flash, Reconnecting   removes red light</li> <li>The only way to get your box back is to unplug the power cable</li> </ul>"},{"location":"System-Software/Error_Codes/#speculation","title":"Speculation","text":"<p>Error 79 has been known during obvious signs of graphic corruption. (Overheating?, Power supply insufficient?)</p> <ul> <li>Error 79 can occur if the Xbox 360 firmware is corrupt.</li> <li>Error 74 can be fixed by disconnecting and reconnecting the hard   drive. This would be in contrast to the Dennis-Mooney-Quote.</li> </ul> <p>Category: System Software Category: Hardware</p>"},{"location":"System-Software/HvxExpansionInstall/","title":"HvxExpansionInstall","text":"<p>A system call for \"installing\" code under Hypervisor context. Registers an HvxExpansion structure in the expansion table</p>"},{"location":"System-Software/HvxExpansionInstall/#reversed-pseudocode","title":"Reversed Pseudocode","text":"<pre><code>// r0 is 0x70\n// Parameters are taken in r3 and r4, respectively\n// r2, r5 - r9 are 0\n\ntypedef struct _EXP_HEADER\n{\n    DWORD Magic;        // \"SIGM\" or \"SIGC\"\n    DWORD Flags;        // Used in verifcation Flags = 1, 2\n    DWORD Size;         // Should be &lt;= size used to install\n    BYTE ShaHash[0x14]; // SHA-1 digest of everything after header\n    BYTE AESFeed[0x10];\n    XECRYPT_SIG Sig;    // RSA sig of the first 0x30 bytes of the header ; 0x100 length ; encrypted\n    //DWORD ExpID;\n} EXP_HEADER, *PEXP_HEADER\n\ntypedef struct _HV_EXPANSION_SECTION_INFO {\n    DWORD Size1;   // Length of some kind\n    DWORD Size2;   // Length of code data\n    DWORD Size3;   // Length of some kind\n    DWORD Padding; // 0x10 Align\n} EXP_SECTION_INFO;\n\ntypedef struct _HV_EXPANSION_INFO {\n    DWORD ExpansionId;       // Id to be used when called after install\n    DWORD ExpansionFlags;    // Compared with something in HV\n    DWORD ExpansionVersion;  // Used to lock to a hv version\n    DWORD ExpansionVersion2; // Used to lock to a hv version\n    QWORD Reserved;          // Havent seen this used\n    QWORD Unknown;           // Compared with something in HV\n    DWORD ExpansionDataPos1; // Position of expansion data/info\n    DWORD ExpansionDataLen1; // Length\n    DWORD ExpansionDataPos2; // Position of expansion data/info\n    DWORD ExpansionDataLen2; // Length\n} EXP_INFO;\n\ntypedef struct _HV_EXPANSION {\n    EXP_HEADER       Header;           // Expansion Header\n    EXP_INFO         ExpansionInfo;    // Expansion Info\n    EXP_SECTION_INFO SectionInfo;      // Sections pointed to by ExInfo\n    DWORD            ExpansionCode[1]; // 0x10 Align\n} EXP;\n\nQWORD HvxExpansionInstall(PVOID pExpAddy, DWORD cExpSize)\n{\n    // Check 0x80 byte alignment on payload address\n    if(pExpAddy &amp; 0x7F)\n        return 0xC8007000;\n    // Check 0x80 byte alignment on payload size\n    if(cExpSize &amp; 0x7F)\n        return 0xC8007001;\n    // Unknown check, if I had to guess its checking if you requested too much memory or if the address is out of range\n    // Similar check is found in similar operations\n    if(((((pExpAddy + cExpSize) - 1) ^ pExpAddy) &amp; 0xFFFF0000) != 0)\n        return 0xC8007001;\n\n    // relocates exp data to an internal location, replaces pExpAddy with new address\n    HvpAquireSpinLock(0x200016918);\n    pExpAddy = HvpRelocatePhysicalToProtected(pExpAddy, cExpSize, 0x3A);\n\n    BYTE Hash1[0x14] = 0;\n    PBYTE AESKey = 0;\n    XECRYPT_RSA xRsa;\n    PEXP_HEADER pExpHeader = (PEXP_HEADER)pExpAddy;\n    DWORD MagicVersion = pExpHeader-&gt;Magic;\n\n    // Check what type of expansion we're dealing with\n    if(MagicVersion == 0x48585052) // \"HVPR\"\n    {\n        if(pExpHeader-&gt;Flags &amp; 3) //bits 1 and 2 in flags must be cleared for this type\n            return 0xC8007003;\n        xRsa = *(XECRYPT_RSA*)0x0000000200016280; // public RSA key\n        AESKey = (PBYTE)0x0000000200016270; // 1BL Key\n        XeCryptRotSumSha(pExpAddy, 0x30, 0, 0, Hash1, 0x14); // hash the header minus the sig\n    }\n    else if(MagicVersion == 0x48585043) // \"HVPC\"\n    {\n        // RSA Key check? Data its checking is null on RGH and XDK. Possible variable key?\n        #ifdef DEVKIT\n        xRsa = *(XECRYPT_RSA*)(*(QWORD*)0x0000000200016A00)+0x200;\n        #else\n        xRsa = *(XECRYPT_RSA*)(*(QWORD*)0x0000000200016950)+0x200;\n        #endif\n        if(xRsa.cqw != 0x20)\n        return 0xC8007002;\n        if((pExpHeader-&gt;Flags &amp; 3) != 3) // flags 1 and 2 must be set for this type\n        return 0xC8007003;\n        #ifdef DEVKIT\n        if(!(pExpHeader-&gt;Flags &amp; 2)) // if bit 2 is cleared, data is not encrypted\n        AESKey = 0; // data is decrypted, do not decrypt\n        else\n        #endif\n        AESKey = (PBYTE)0x20; // CPU Key\n        XeCryptHmacSha(0x20, 0x10, pExpAddy, 0x30, 0, 0, 0, 0, Hash1, 0x14);\n    }\n    else\n        return 0xC8007002; // invalid expansion type\n\n    // check if the header has been tampered with\n    if(!XeCryptBnQwBeSigVerify(pExpHeader-&gt;Sig, Hash1, (PBYTE)0x0000000200016664, xRsa))\n        return 0xC8007003;\n    if(pExpHeader-&gt;Size &gt; cExpSize) // size in header must be &lt;= size requested\n        return 0xC8007003;\n    if(AESKey != 0) // check if the key has been set. if not, skip decryption\n    {\n        XECRYPT_AES_STATE aes;\n        XeCryptAesKey(&amp;aes, AESKey);\n        XeCryptAesCbc(&amp;aes, pExpAddy+0x130, (pExpHeader-&gt;Size)-0x130, pExpAddy+0x130, &amp;(pExpHeader-&gt;AESFeed), 0);\n    }\n\n    // check if the expansion has been tampered with\n    XeCryptSha(pExpAddy+0x130, (pExpHeader-&gt;Size)-0x130, 0, 0, 0, 0, Hash1, 0x14);\n    if(XeCryptMemDiff(pExpHeader-&gt;ShaHash, Hash1, 0x14))\n        return 0xC8007003;\n\n    // go to the install function\n    QWORD ret = InstallExpansion(pExpAddy);\n\n    HvpZeroCacheLines(pExpAddy, cExpSize &gt;&gt; 7);\n    HvpRelocateProtectedToPhysical(pExpAddy, cExpSize, 0x3A);\n    HvpReleaseSpinLock(0x200016918);\n\n    return ret;\n}\n</code></pre>"},{"location":"System-Software/HvxKeysExecute/","title":"HvxKeysExecute","text":"<p>HvxKeysExecute is a syscall to execute a payload in privileged mode</p> <ul> <li>Microsoft uses it as a back door to xbox 360s</li> <li>On retails: Payloads must be signed</li> <li>On exploited consoles: Signature check must be patched</li> </ul> <p>Because this function has to do with online related services, I have altered some function names, with the intention to reduce abusing this for online purposes.</p> <p>Why is this here if it has to do with online? Because while it is used in the xbox live auth process, that does not appear to be its main function. For example I have used it many times to help debug other HV system calls.</p> <pre><code>#define KEYS_PARAMETER_FAIL 0xC8000030\n#define KEYS_MAGIC_FAIL 0xC8000032\n#define KEYS_HVMAGIC_FAIL 0xC8000033\n#define KEYS_HEADER_FAIL 0xC8000034\n#define KEYS_ENTRYPOINT_FAIL 0xC8000035\n#define KEYS_CRYPT_FAIL 0xC8000036\n\n// similar header to a bootloader, without the presets (probably because presets are passed as arguments)\ntypedef struct _BLHeader\n{\n    WORD Magic;     // 0 : 2\n    WORD Version;       // 2 : 2\n    DWORD Flags;        // 4 : 4\n    DWORD EntryPoint;   // 8 : 4\n    DWORD Size;     // 0xC : 4\n    BYTE key[0x10];     // 0x10 : 0x10\n    XECRYPT_SIG Sig;    // 0x20 : 0x100\n    // Header: 0x120\n}BLHeader, *PBLHeader;\n\nBYTE BLKey[0x10] = { &lt;redacted&gt; };\nBYTE ExSalt[0xA] = &lt;redacted&gt;; // NOTE: They use the same RSA key and BLKey as 1bl but different signature salt\nXECRYPT_RSAPUB_2048 xRSA;\nxRSA = &lt;redacted&gt;\n\ntypedef QWORD PayloadJump(PBYTE pbPayload, QWORD Arg1, QWORD Arg2, QWORD Arg3, QWORD Arg4);\n\nQWORD HvxKeysExecute(PBYTE pbPayload, DWORD cbPayload, QWORD Arg1, QWORD Arg2, QWORD Arg3, QWORD Arg4)\n{\n    if(pbPayload &amp; 0x7F // 0x80 byte alignment check\n        || cbPayload &amp; 0x7F // 0x80 byte alignment check\n        || cbPayload &gt; 0x10000 // size check\n        || (((pbPayload + cbPayload) - 1) ^ pbPayload) &amp; 0xFFFF0000)\n        return KEYS_PARAMETER_FAIL;\n\n    HvpAquireSpinLock(0x200016460);\n\n    // our payload will be executed in realmode, to maintain security make sure it will be in a secure area\n    DWORD origPayload = pbPayload;\n    pbPayload = HvpRelocatePhysicalToInternal(pbPayload, cbPayload, 0x3E);\n\n    // from now on if something fails, we need to invalidate the block in protected memory\n    QWORD ret = 0;\n\n    PBLHeader phPayload = (PBLHeader)pbPayload;\n    if(phPayload-&gt;Magic &amp; 0xF0F == 0xD0D) // Payload Magic check\n    {\n        if((*(WORD*)0 ^ phPayload-&gt;Magic) &amp; 0xF000 == 0) // HV &amp; Payload magic check\n        {\n            if(phPayload-&gt;Size &gt;= 0x120 // sanity check\n                || (phPayload-&gt;Size + 0xF) &amp; 0xFFFFFFF0 &gt;= phPayload-&gt;Size // ? dont see the point...?\n                || (phPayload-&gt;Size + 0xF) &amp; 0xFFFFFFF0 &lt;= cbPayload) // sanity check\n            {\n                if(!phPayload-&gt;EntryPoint &amp; 3 // 4 byte alignment check\n                    || phPayload-&gt;EntryPoint &gt;= 0x120 // sanity check\n                    || phPayload-&gt;EntryPoint &lt;= phPayload-&gt;Size &amp; 0xFFFFFFFC) // sanity check\n                {\n                    BYTE rc4Key[0x10];\n                    XeCryptHmacSha(BLKey, 0x10, &amp;phPayload-&gt;key, 0x10, 0, 0, 0, 0, rc4Key, 0x10);\n                    XECRYPT_RC4_STATE rc4;\n                    XeCryptRc4Key(&amp;rc4, rc4Key, 0x10);\n                    XeCryptRc4Ecb(&amp;rc4, pbPayload+0x20, phPayload-&gt;Size - 0x20);\n                    BYTE Hash[0x14];\n                    XeCryptRotSumSha(pbPayload, 0x10, pbPayload+0x120, phPayload-&gt;Size - 0x120, Hash, 0x14);\n                    if(XeCryptBnQwBeSigVerify(phPayload-&gt;Sig, Hash, ExSalt, &amp;xRSA))\n                    {\n                        // key and sig will not be used anymore, null them\n                        *(QWORD*)pbPayload+0x10 = 0ull;\n                        *(QWORD*)pbPayload+0x18 = 0ull;\n                        memset(&amp;phPayload-&gt;Sig, 0, 0x100);\n                        if(phPayload-&gt;Size &lt; cbPayload)\n                            memset((pbPayload + phPayload-&gt;Size), 0, (cbPayload - phPayload-&gt;Size));\n\n                        // jump to our payload\n                        PayloadJump* pfPayload = (PayloadJump*)(pbPayload + phPayload-&gt;EntryPoint);\n                        ret = pfPayload(pbPayload, Arg1, Arg2, Arg3, Arg4);\n                    }\n                    else ret = KEYS_CRYPT_FAIL;\n                }\n                else ret = KEYS_ENTRYPOINT_FAIL;\n            }\n            else ret = KEYS_HEADER_FAIL;\n        }\n        else ret = KEYS_HVMAGIC_FAIL;\n    }\n    else ret = KEYS_MAGIC_FAIL;\n\n    BYTE retBuf[0x100];\n    if(ret == 0) // assumed as success (payload return can change this)\n        memcpy(retBuf, pbPayload+0x20, 0x100);\n    else // assumed something failed, null retBuf (NOTE: if you want to use retBuf as a return buffer, payload must return 0)\n        for(int i = 0;i &lt; 0x20;i++)\n            retBuf[i*8] = 0ull;\n\n    // clean up\n    HvpInvalidateCachelines(pbPayload, cbPayload);\n    pbPayload = HvpPhysicalToReal(origPayload, cbPayload);\n    HvpZeroCacheLines(pbPayload, cbPayload &gt;&gt; 7);\n    memcpy(pbPayload + 0x20, retBuf, 0x100);\n\n    HvpReleaseSpinLock(0x200016460);\n\n    return ret;\n}\n</code></pre>"},{"location":"System-Software/HvxPostOutput/","title":"HvxPostOutput","text":"<pre><code> static QWORD _declspec(naked) HvxPostOutput(BYTE code)\n {\n    __asm\n    {\n        li  r0, 0xD\n        sc\n        blr\n    }\n }\n</code></pre> <p>HvxPostOutput(0xFF);</p> <p>Returns 0</p>"},{"location":"System-Software/Kernel/","title":"Kernel","text":"<p>Version 2.0.13146.0 is currently the latest public version.</p> <p>You can check your kernel version in \"System -&gt; Console Settings -&gt; System Info\". The line at the bottom contains your kernel version in the format K:2.0.XXXX.0, where XXXX is your kernel version.</p> Version Release Date Comment 2.0.1888.0 November 22, 2005 Original shipped version 2.0.2241.0 November 22, 2005 Update available at product launch 2.0.2255.0 January 30, 2006 Blocklist for certain .xex file 2.0.2258.0 March 2, 2006 2.0.2858.0 June 05, 2006 2.0.4532.0 October 31, 2006 New identifier X with value 2BB7-8E09-0188-D795 2.0.4548.0 November 30, 2006 2.0.4552.0 January 9, 2007 Fix unsigned code vulnerability 2.0.5759.0 May 9, 2007 Added Instant Messaging 2.0.5766.0 August 7, 2007 Wireless guitars Yet unknown fixes 2.0.6683.0 December 4, 2007 Fall Update. Timing attack works (dependant on CB). 2.0.6717.0 August 6, 2008 Scalability Updates 2.0.7357.0 November 19, 2008 New dashboard (\"NXE\") 2.0.7363.0 February 3, 2009 HDMI audio fix 2.0.7371.0 April 2, 2009 Fixes Xbox Live issues 2.0.8495.0 July, 2009 Update preview 2.0.8496.0 July 31, 2009 Update preview (second) 2.0.8498.0 August 11, 2009 Public Dashboard Released 2.0.8507.0 September 23, 2009 Preparation for newer dash 2.0.8955.0 October 28, 2009 Blocking 3rd party storage devices, adding WPA2 support for wireless adapters 2.0.9199.0 April 6, 2010 USB storage support added 2.0.12611.0 November 1, 2010 GUI upgrade for Kinect release, ESPN on Xbox LIVE released 2.0.12625.0 January 19, 2011 Adds further anti-piracy 2.5 scheme to more popular games Halo: Reach, Call of Duty: Black Ops and Call of Duty: Modern Warfare 2. Fixes \u2018Boot to Disc\u2019 option. 2.0.13146.0 May 19, 2011 Reflashes the DVD drives to support XGD3 Media : PLDS DG-16D4S, PBDS VAD6038 and PLDS DG-16D2S, to a new stock firmware : 0272, 04421C, 02510C. Also patches Samsung MS25 &amp; MS28 Anti-Piracy 2.5 scheme updated. Support for the new XGD3 disk format for games, adds 1GB of usable disk space and extra anti-piracy features to new games Adds a new 1 hour Auto-Off setting in addition to the 6 hour Auto-Off setting previously available. Adds PayPal support as a payment option for all Xbox Live users. Minor bugfix. <p>Please note: In order to use the SMC Hack, you must not have installed any of the 849x kernel updates.</p> <p>System Software</p>"},{"location":"System-Software/Kernel_Exports/","title":"Kernel exports","text":""},{"location":"System-Software/Kernel_Exports/#rtlinitansistring","title":"RtlInitAnsiString","text":"<p>Parameters: OUT PANSI_STRING OutputString, IN LPCSTR String Returns: OutputString as an ANSI equivalent of String Prototype: void RtlInitAnsiString( PANSI_STRING, LPCSTR ); Example:</p> <pre><code>ANSI_STRING DeviceName;\nRtlInitAnsiString(&amp;DeviceName, \"\\\\Device\\\\Harddisk0\\\\Partition1\");\n</code></pre>"},{"location":"System-Software/Kernel_Exports/#obcreatesymboliclink","title":"ObCreateSymbolicLink","text":"<p>Parameters: IN PANSI_STRING SymbolicLinkName, IN PANSI_STRING DeviceName Returns: 0 if success Prototype: int ObCreateSymbolicLink( PANSI_STRING, PANSI_STRING ); Example:</p> <pre><code>int result = ObCreateSymbolicLink( \"\\\\??\\\\hdd:\", \"\\\\Device\\\\Harddisk0\\\\Partition1\" );\n(wont actually work)\n</code></pre> <p>Both strings have to be ANSI, use RtlInitAnsiString to make them</p>"},{"location":"System-Software/Kernel_Exports/#obdeletesymboliclink","title":"ObDeleteSymbolicLink","text":"<p>Parameters: IN PANSI_STRING SymbolicLinkName Returns: 0 if success Prototype: int ObDeleteSymbolicLink( PANSI_STRING ); Example:</p> <pre><code>int result = ObDeleteSymbolicLink( \"\\\\??\\\\hdd:\" );\n(wont actually work)\n</code></pre> <p>As above, use <code>RtlInitAnsiString</code> to make the string</p> <p>System Software</p>"},{"location":"System-Software/Memory_Map/","title":"Memory map","text":""},{"location":"System-Software/Memory_Map/#physical-mapping","title":"Physical Mapping","text":"Address Size Description <code>c000xxxx</code> 0x10000 Initial \"Kernel\" (bootloader, not real kernel), mapped L2-Cache? <code>c8xxxxxx</code> 0x1000000 memory mapped NAND flash (RO, 1:1, no OoB(ECC)) <code>c9xxxxxx</code> 0x1000000 ??? <code>d0xxxxxx</code> 0x1000000 PCI config space. Device number etc. is encoded in address, as usual <code>e0000000</code> ??? Host-Bridge <code>e1000000</code> ??? BIU <code>ea000000</code> 0x10000 PCI Bridge <code>ec800000</code> 0x10000 GPU"},{"location":"System-Software/Memory_Map/#pcidevice-mapping","title":"PCI/Device Mapping","text":"Address Size Description <code>0x(200)ea001000</code> 0x100 System Management Controller <code>0x(200)ea001200</code> 0x30 SATA Controller CDRom <code>0x(200)ea001300</code> 0x30 SATA Controller HDD <code>0x(200)ea001400</code> 0x80 Fast Ethernet Adapter <code>0x(200)ea001600</code> 0x40 Audio Controller <code>0x(200)ea001800</code> 0x400 XMA Decoder <code>0x(200)ea002000</code> 0x1000 OHCI Controller 0 <code>0x(200)ea003000</code> 0x1000 EHCI Controller 0 <code>0x(200)ea004000</code> 0x1000 OHCI Controller 1 <code>0x(200)ea005000</code> 0x1000 EHCI Controller 1 <code>0x(200)ea00c000</code> 0x400 Secure Flash Controller"},{"location":"System-Software/Memory_Map/#smc-area","title":"SMC Area","text":"Address Size Description <code>0x(200)ea001000</code> 0x10 Bus Control <code>0x(200)ea001010</code> 0x10 UART <code>0x(200)ea001020</code> 0x10 GPIO Port ?? <code>0x(200)ea001030</code> 0x10 GPIO Port ?? <code>0x(200)ea001040</code> 0x10 GPIO Port ?? <code>0x(200)ea001050</code> 0x10 SMI ???"},{"location":"System-Software/Memory_Map/#encryption","title":"Encryption","text":"<p>Dumps of physical memory</p> <p>Changed 1 byte in software, dumped again, 16 bytes changed again.</p> <p>Might be ~1 cache line</p> <p>(0, 1, 2, ...)</p> <p>log:</p> <pre><code>f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 6e bb c5 d1 62 9e 29 8f e9 3a 6b 7b 4d d0 44 24 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e\nf0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 03 58 f6 c0 f0 13 d5 02 4f 57 a1 d0 50 d3 46 6a 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e\nf0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 1b d6 a6 3b 3c 6e 68 4f da 75 7f a7 8a 02 e4 53 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e\nf0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 38 03 ff f0 61 99 e6 8c b0 3b 2f bb b6 70 06 53 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e\nf0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 0f 55 01 b1 61 9b 35 34 4d ce f4 e8 bb eb cc 4a 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e\nf0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 fc ce 87 2c 30 c0 1c 4f e7 65 da d4 e4 df f6 2b 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e\nf0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 e5 5d f3 38 d9 05 c0 8e 7a a9 b5 a2 fe 11 4c b3 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e\nf0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 84 83 5d 34 55 9b e4 06 26 03 1b f3 0b e9 0f b8 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e\nf0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 ba 4d 72 2b cd 0b e9 0c 2b aa ed 53 ea b0 63 49 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e\n</code></pre>"},{"location":"System-Software/NAND_File_System/","title":"NAND Flash System","text":"<p>The Xbox 360 NAND uses a proprietary format created by Microsoft. The format is used to store console-specific data (keyvault, config blocks, etc) and system data (bootloaders, kernel/hypervisor, dashboard files). The NAND is split into two sections - one for storing the keyvault, bootloaders and config blocks and one for storing the dashboard files. The file are stored using a format which is designed to be transactional (each change can be reverted).</p>"},{"location":"System-Software/NAND_File_System/#nand-basic-format","title":"NAND Basic Format","text":"<p>The NAND uses a series of pages to combine into blocks, which are small snippets of data (usually 512 bytes) which each have an EDC tag at the end (an extra 16 bytes or 64 in bigblock). These pages are each part of a specific block (which can be identified with the EDC), which is usually made with 16 pages (or 32 for bigblock NANDs)</p>"},{"location":"System-Software/NAND_File_System/#metadata","title":"Metadata","text":"<p>All (non-eMMC) NANDs have specific Spare-/Metadata for each page inside the NAND. Sometimes it will not be dumped with the NAND, so it has to either be added back or redumped. The Metadata contains the pages block number, a series of flags and a checksum. Those differ slightly, depending on the blocksize.</p>"},{"location":"System-Software/NAND_File_System/#small-block","title":"Small Block","text":"<pre><code>unsigned\u00a0char\u00a0BlockID1;\u00a0//\u00a0lba/id\u00a0=\u00a0(((BlockID0&amp;0xF)&lt;&lt;8)+(BlockID1))\nunsigned\u00a0char\u00a0BlockID0\u00a0:\u00a04;\nunsigned\u00a0char\u00a0FsUnused0\u00a0:\u00a04;\nunsigned\u00a0char\u00a0FsSequence0;\u00a0//\u00a0Not\u00a0reversed\nunsigned\u00a0char\u00a0FsSequence1;\nunsigned\u00a0char\u00a0FsSequence2;\nunsigned\u00a0char\u00a0BadBlock;\nunsigned\u00a0char\u00a0FsSequence3;\nunsigned\u00a0char\u00a0FsSize1;\u00a0//\u00a0((FsSize0&lt;&lt;8)+FsSize1)\u00a0=\u00a0cert\u00a0size\nunsigned\u00a0char\u00a0FsSize0;\nunsigned\u00a0char\u00a0FsPageCount;\u00a0//\u00a0free\u00a0pages\u00a0left\u00a0in\u00a0block\u00a0(ie:\u00a0if\u00a03\u00a0pages\u00a0are\u00a0used\u00a0by\u00a0cert\u00a0then\u00a0this\u00a0would\u00a0be\u00a029:0x1d)\nunsigned\u00a0char\u00a0FsUnused1[0x2];\nunsigned\u00a0char\u00a0FsBlockType\u00a0:\u00a06;\nunsigned\u00a0char\u00a0ECC3\u00a0:\u00a02;\nunsigned\u00a0char\u00a0ECC2;\u00a0//\u00a014\u00a0bit\u00a0ECD\nunsigned\u00a0char\u00a0ECC1;\nunsigned\u00a0char\u00a0ECC0;\n</code></pre>"},{"location":"System-Software/NAND_File_System/#big-block-on-small-nand","title":"Big Block on Small NAND","text":"<pre><code>unsigned\u00a0char\u00a0FsSequence0;\nunsigned\u00a0char\u00a0BlockID1;\u00a0//\u00a0lba/id\u00a0=\u00a0(((BlockID0&lt;&lt;8)&amp;0xF)+(BlockID1&amp;0xFF))\nunsigned\u00a0char\u00a0BlockID0\u00a0:\u00a04;\u00a0\nunsigned\u00a0char\u00a0FsUnused0\u00a0:\u00a04;\nunsigned\u00a0char\u00a0FsSequence1;\nunsigned\u00a0char\u00a0FsSequence2;\nunsigned\u00a0char\u00a0BadBlock;\nunsigned\u00a0char\u00a0FsSequence3;\nunsigned\u00a0char\u00a0FsSize1;\u00a0//\u00a0(((FsSize0&lt;&lt;8)&amp;0xFF)+(FsSize1&amp;0xFF))\u00a0=\u00a0cert\u00a0size\nunsigned\u00a0char\u00a0FsSize0;\nunsigned\u00a0char\u00a0FsPageCount;\u00a0//\u00a0free\u00a0pages\u00a0left\u00a0in\u00a0block\u00a0(ie:\u00a0if\u00a03\u00a0pages\u00a0are\u00a0used\u00a0by\u00a0cert\u00a0then\u00a0this\u00a0would\u00a0be\u00a029:0x1d)\nunsigned\u00a0char\u00a0FsUnused1[2];\nunsigned\u00a0char\u00a0FsBlockType\u00a0:\u00a06;\nunsigned\u00a0char\u00a0ECC3\u00a0:\u00a02;\nunsigned\u00a0char\u00a0ECC2;\u00a0//\u00a014\u00a0bit\u00a0ECD\nunsigned\u00a0char\u00a0ECC1;\nunsigned\u00a0char\u00a0ECC0;\n</code></pre>"},{"location":"System-Software/NAND_File_System/#big-block","title":"Big Block","text":"<pre><code>unsigned\u00a0char\u00a0BadBlock;\nunsigned\u00a0char\u00a0BlockID1;\u00a0//\u00a0lba/id\u00a0=\u00a0(((BlockID0&amp;0xF)&lt;&lt;8)+(BlockID1&amp;0xFF))\nunsigned\u00a0char\u00a0BlockID0\u00a0:\u00a04;\nunsigned\u00a0char\u00a0FsUnused0\u00a0:\u00a04;\nunsigned\u00a0char\u00a0FsSequence2;\u00a0//\u00a0oddly,\u00a0compared\u00a0to\u00a0before\u00a0these\u00a0are\u00a0reversed...?\nunsigned\u00a0char\u00a0FsSequence1;\nunsigned\u00a0char\u00a0FsSequence0;\nunsigned\u00a0char\u00a0FsUnused1;\nunsigned\u00a0char\u00a0FsSize1;\u00a0//\u00a0FS:\u00a006\u00a0((FsSize0&lt;&lt;16)+(FsSize1&lt;&lt;8)+FsSize2)\u00a0=\u00a0cert\u00a0size\nunsigned\u00a0char\u00a0FsSize0;\u00a0//\u00a0FS:\u00a020\nunsigned\u00a0char\u00a0FsPageCount;\u00a0//\u00a0FS:\u00a004\u00a0free\u00a0pages\u00a0left\u00a0in\u00a0block\u00a0(multiples\u00a0of\u00a04\u00a0pages,\u00a0ie\u00a0if\u00a03f\u00a0then\u00a03f*4\u00a0pages\u00a0are\u00a0free\u00a0after)\nunsigned\u00a0char\u00a0FsUnused2[0x2];\nunsigned\u00a0char\u00a0FsBlockType\u00a0:\u00a06;\u00a0//\u00a0FS:\u00a02a\u00a0bitmap:\u00a02c\u00a0(both\u00a0use\u00a0FS:\u00a0vals\u00a0for\u00a0size),\u00a0mobiles\nunsigned\u00a0char\u00a0ECC3\u00a0:\u00a02;\nunsigned\u00a0char\u00a0ECC2;\u00a0//\u00a014\u00a0bit\u00a0ECD\nunsigned\u00a0char\u00a0ECC1;\nunsigned\u00a0char\u00a0ECC0;\n</code></pre>"},{"location":"System-Software/NAND_File_System/#error-detectioncorrection-code","title":"Error Detection/Correction Code","text":"<p>The ECC/EDC checksum uses a custom algorithm - here is C code for that:</p> <pre><code>int\u00a0checkEcc(u8*\u00a0datc,\u00a0u8*\u00a0spare)\n{\nunsigned\u00a0int\u00a0i=0,\u00a0val=0;\nunsigned\u00a0char\u00a0edc[4]\u00a0=\u00a0{0,0,0,0};\nunsigned\u00a0long\u00a0*\u00a0data\u00a0=\u00a0(unsigned\u00a0long*)\u00a0datc;\n\nunsigned\u00a0int\u00a0v=0;\n//\u00a0printf(\"original\u00a0ECC\u00a0\u00a0:\u00a0%02x\u00a0%02x\u00a0%02x\u00a0%02x\u00a0\",\u00a0(spare[0xC]\u00a0&amp;\u00a00xC0),\u00a0spare[0xD],spare[0xE],spare[0xF]);\n\nfor\u00a0(i\u00a0=\u00a00;\u00a0i\u00a0&lt;\u00a00x1066;\u00a0i++)\n{\n\u00a0\u00a0\u00a0if\u00a0(!(i\u00a0&amp;\u00a031))\n\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(i\u00a0==\u00a00x1000)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0data\u00a0=\u00a0(unsigned\u00a0long*)spare;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v\u00a0=\u00a0~*data++;\u00a0//\u00a0byte\u00a0order:\u00a0LE\u00a0\n\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val\u00a0^=\u00a0v\u00a0&amp;\u00a01;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v&gt;&gt;=1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(val\u00a0&amp;\u00a01)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val\u00a0^=\u00a00x6954559;\n\u00a0\u00a0\u00a0val\u00a0&gt;&gt;=\u00a01;\n}\n\nval\u00a0=\u00a0~val;\n\nedc[0]\u00a0=\u00a0(val\u00a0&lt;&lt;\u00a06)\u00a0&amp;\u00a00xC0;\nedc[1]\u00a0=\u00a0(val\u00a0&gt;&gt;\u00a02)\u00a0&amp;\u00a00xFF;\nedc[2]\u00a0=\u00a0(val\u00a0&gt;&gt;\u00a010)\u00a0&amp;\u00a00xFF;\nedc[3]\u00a0=\u00a0(val\u00a0&gt;&gt;\u00a018)\u00a0&amp;\u00a00xFF;\n\nif(((spare[0xC]\u00a0&amp;\u00a00xC0)\u00a0!=\u00a0edc[0])||(spare[0xD]\u00a0!=\u00a0edc[1])||(spare[0xE]\u00a0!=\u00a0edc[2])||(spare[0xF]\u00a0!=\u00a0edc[3]))\n\u00a0\u00a0\u00a0return\u00a0ECC_FAILED;\n\nreturn\u00a0ECC_CORRECT;\n}\n</code></pre>"},{"location":"System-Software/NAND_File_System/#nand-format","title":"NAND Format","text":"<p>The first byte of a NAND image should always be 0xFF. If it isn't 0xFF this isn't a valid image. Another thing which should be checked is the copyright header, which is located at 0x10 in the NAND. This string should be read in two parts (skipping the year out, as it changes depending when that xbox was made) and then checked against a control string (although some valid images have this string changed to zeropair).</p> <p>At 0x2 in the NAND the version of the flash is stored (2bytes). Further on at 0x8 the offset of the CB is stored, followed by the CF1 offset (4bytes each).</p> <p>At 0x6C the offset to the keyvault is located (4bytes). Up from that at 0x78 the length of the SMC and offset to the SMC are stored (4bytes each).</p>"},{"location":"System-Software/NAND_File_System/#system-management-controller","title":"System Management Controller","text":"<p>finish later</p>"},{"location":"System-Software/NAND_File_System/#xell-image-layout","title":"XeLL Image Layout","text":"<p>The whole XeLL Image is pretty small with 1,3 MB compared to an original Xbox360 NAND-Image which is normally 16 MB or 64 MB.</p> <p>0x00000000..0x000001ff\u00a0(0x00000200\u00a0bytes)\u00a0Header 0x00000200..0x000003ff\u00a0(0x00000200\u00a0bytes)\u00a0Exploit 0x00000400..0x00000fff\u00a0(0x00000c00\u00a0bytes)\u00a0Padding 0x00001000..0x00003fff\u00a0(0x00003000\u00a0bytes)\u00a0SMC 0x00004000..0x00007fff\u00a0(0x00004000\u00a0bytes)\u00a0Keyvault 0x00008000..0x000117ff\u00a0(0x00009800\u00a0bytes)\u00a0CB\u00a01921 0x00011800..0x00016ebf\u00a0(0x000056c0\u00a0bytes)\u00a0CD\u00a01921 0x00016ec0..0x0006cf2f\u00a0(0x00056070\u00a0bytes)\u00a0CE\u00a01888 0x0006cf30..0x0006ffff\u00a0(0x000030d0\u00a0bytes)\u00a0Padding 0x00070000..0x000744bf\u00a0(0x000044c0\u00a0bytes)\u00a0CF\u00a04532 0x000744c0..0x000a33ff\u00a0(0x0002ef40\u00a0bytes)\u00a0CG\u00a04532 0x000a3400..0x000bffff\u00a0(0x0001cc00\u00a0bytes)\u00a0Padding 0x000c0000..0x000fffff\u00a0(0x00040000\u00a0bytes)\u00a0Xell\u00a0(backup) 0x00100000..0x0013ffff\u00a0(0x00040000\u00a0bytes)\u00a0Xell\u00a0(main)</p> <ul> <li>The (hacked) SMC Code is usually seen as Header + Exploit + Padding</li> <li>the actual SMC, so 0x0000 - 0x3FFF.</li> <li>The Keyvault is the unique \"System Information\" which holds stuff   like DVDKey, Console Region, Console Serial and other things. Whole   keyvault is crypted with CPUKey.</li> <li>After that exploitable CB (2BL) and CD (4BL), matching the console   revision, follows.</li> <li>After padding CB/CD theres CE (Base-Kernel 1888) followed by   exploitable Patchslots CF/CG (4532 or 4548) and again some padding.</li> <li>At the end of the Image theres a Backup-XeLL, which gets executed if   the original XeLL fails (Bad Update maybe) followed by the original   XeLL.</li> </ul> <p>System Software</p>"},{"location":"System-Software/Profile_Account/","title":"Profile Account","text":"<p>The Account file is a HMAC-RC4 encrypted file stored in profiles to hold things such as the profiles gamertag, PUID (Passport User ID), online key and more.</p>"},{"location":"System-Software/Profile_Account/#encryption","title":"Encryption","text":"<p>The file is encrypted with a custom form of HMAC-RC4, which is handled by the XeKeysUnobfuscate function. The key differs between retail and development consoles and is stored in key index 0x19.</p> <ul> <li>Retail     key</li> </ul> <pre><code>0xE1 0xBC 0x15 0x9C 0x73 0xB1 0xEA 0xE9 0xAB 0x31 0x70 0xF3 0xAD 0x47 0xEB 0xF3\n</code></pre> <ul> <li>Devkit     key</li> </ul> <pre><code>0xDA 0xB6 0x9A 0xD9 0x8E 0x28 0x76 0x4F 0x97 0x7E 0xE2 0x48 0x7E 0x4F 0x3F 0x68\n</code></pre> <p>To decrypt the file:</p> <ul> <li>Copy the first 16 bytes of the file to a buffer. This is the     HMAC-SHA1 hash of the file which is made using one of the keys     above.</li> <li>Use HMAC-SHA1 on that buffer with a key from above to create the RC4     key, which is 0x10 bytes.</li> <li>Decrypt 8 bytes after the hash of the file (at offset 0x10) using     RC4. This is the confounder.</li> <li>Decrypt 380 bytes after the confounder using RC4. This is the     decrypted account data.</li> <li>Make a hash of the confounder and decrypted data using HMAC-SHA1 and     a key above and compare it to the first 16 bytes of the file, if it     doesn't match then the decryption failed.</li> </ul> <p>To encrypt the file:</p> <ul> <li>Copy the decrypted data to offset 0x18</li> <li>Create a random 8 byte confounder and copy this to offset 0x10.</li> <li>Make a hash of the confounder and decrypted data using HMAC-SHA1 and     a key above, resize it to 16 bytes and then copy that to the     beginning of the file.</li> <li>Use HMAC-SHA1 on that hash with a key from above to create the RC4     key, which is 0x10 bytes.</li> <li>Encrypt 388 bytes from position 0x10 using RC4.</li> </ul>"},{"location":"System-Software/Profile_Account/#decrypted-file","title":"Decrypted File","text":"<p>Offset</p> <p>Length</p> <p>Type</p> <p>Information</p> <p>0</p> <p>4</p> <p>UInt32</p> <p>Reserved(Flags) </p> <p>4</p> <p>4</p> <p>UInt32</p> <p>LiveFlags</p> <p>8</p> <p>16 chars/32 bytes</p> <p>Unicode</p> <p>Gamertag</p> <p>40</p> <p>8</p> <p>ulong</p> <p>XUID</p> <p>48</p> <p>4</p> <p>UInt32</p> <p>Cached User Flags</p> <p>52</p> <p>4</p> <p>ASCII string</p> <p>Xbox Live Service Provider</p> <p>56</p> <p>4</p> <p>PasscodeKeys[4]</p> <p>Passcode</p> <p>60</p> <p>20</p> <p>ASCII string</p> <p>Online Domain</p> <p>80</p> <p>24</p> <p>ASCII string</p> <p>Online Kerberos Realm</p> <p>104</p> <p>16</p> <p>Bytes</p> <p>Online Key</p> <p>120</p> <p>114</p> <p>ASCII string</p> <p>User Passport Membername</p> <p>234</p> <p>32</p> <p>ASCII string</p> <p>User Passport Password</p> <p>266</p> <p>114</p> <p>ASCII string</p> <p>Owner Passport Membername</p> <ul> <li>Note Last 3 not used anymore(if ever).</li> </ul>"},{"location":"System-Software/Profile_Account/#reservedflags","title":"Reserved(flags)","text":"Name Value Passcode Enabled 0x10000000 LIVE Enabled 0x20000000 Recovering 0x40000000 <p>The flag at bit0 seems to be always set, not sure what it means though.</p>"},{"location":"System-Software/Profile_Account/#cached-user-flags","title":"Cached User Flags","text":"Bits Used Indices Field Name 0 Payment Instrument Credit Card 8-15 Country 16-19 Subscription Teir 24 Parental Controls Enabled 25-29 Language <p>The other bits are used, I'm just not sure what they all represent.</p>"},{"location":"System-Software/Profile_Account/#passcode","title":"Passcode","text":"<p>The passcode is made up of these bytes:</p> Byte Button 0 Null 1 DPad Up 2 DPad Down 3 DPad Left 4 DPad Right 5 X 6 Y 7 A 8 B 9 Left Trigger 10 Right Trigger 11 Left Bumper 12 Right Bumper <ul> <li>Note A and B are not valid for passwords.</li> </ul>"},{"location":"System-Software/Profile_Account/#xuid","title":"XUID","text":"<p><code>public\u00a0class\u00a0XUID</code> <code>{</code> <code>public\u00a0System.UInt64\u00a0Value;</code> <code>public\u00a0XUID(System.UInt64\u00a0_Value)</code> <code>{</code> <code>Value\u00a0=\u00a0_Value;</code> <code>}</code> <code>public\u00a0System.Boolean\u00a0IsOfflineXuid</code> <code>{</code> <code>get</code> <code>{</code> <code>return\u00a0(Value\u00a0&amp;\u00a017293822569102704640L)\u00a0==\u00a016140901064495857664L;</code> <code>}</code> <code>}</code> <code>public\u00a0System.Boolean\u00a0IsOnline</code> <code>{</code> <code>get</code> <code>{</code> <code>return\u00a0(Value\u00a0&amp;\u00a018446462598732840960L)\u00a0==\u00a02533274790395904L;</code> <code>}</code> <code>}</code> <code>public\u00a0System.Boolean\u00a0IsTeam//Guess\u00a0this\u00a0is\u00a0todo\u00a0with\u00a0devs</code> <code>{</code> <code>get</code> <code>{</code> <code>return\u00a0(Value\u00a0&amp;\u00a018374686479671624000L)\u00a0==\u00a018302628885633696000L;</code> <code>}</code> <code>}</code> <code>public\u00a0System.Boolean\u00a0IsValidXuid</code> <code>{</code> <code>get</code> <code>{</code> <code>return\u00a0IsOfflineXuid\u00a0!=\u00a0IsOnlineXuid;</code> <code>}</code> <code>}</code> <code>}</code></p>"},{"location":"System-Software/Profile_Account/#country","title":"Country","text":"<p><code>public\u00a0enum\u00a0XboxLiveCountry</code> <code>{</code> <code>Albania\u00a0=\u00a02,</code> <code>Algeria\u00a0=\u00a00x1b,</code> <code>Argentina\u00a0=\u00a04,</code> <code>Armenia\u00a0=\u00a03,</code> <code>Australia\u00a0=\u00a06,</code> <code>Austria\u00a0=\u00a05,</code> <code>Azerbaijan\u00a0=\u00a07,</code> <code>Bahrain\u00a0=\u00a010,</code> <code>Belarus\u00a0=\u00a014,</code> <code>Belgium\u00a0=\u00a08,</code> <code>Belize\u00a0=\u00a015,</code> <code>Bolivia\u00a0=\u00a012,</code> <code>Brazil\u00a0=\u00a013,</code> <code>BruneiDarussalam\u00a0=\u00a011,</code> <code>Bulgaria\u00a0=\u00a09,</code> <code>Canada\u00a0=\u00a00x10,</code> <code>Chile\u00a0=\u00a00x13,</code> <code>China\u00a0=\u00a020,</code> <code>Colombia\u00a0=\u00a00x15,</code> <code>CostaRica\u00a0=\u00a00x16,</code> <code>Croatia\u00a0=\u00a00x29,</code> <code>CzechRepublic\u00a0=\u00a00x17,</code> <code>Denmark\u00a0=\u00a00x19,</code> <code>DominicanRepublic\u00a0=\u00a00x1a,</code> <code>Ecuador\u00a0=\u00a00x1c,</code> <code>Egypt\u00a0=\u00a030,</code> <code>ElSalvador\u00a0=\u00a00x5f,</code> <code>Estonia\u00a0=\u00a00x1d,</code> <code>FaroeIslands\u00a0=\u00a00x21,</code> <code>Finland\u00a0=\u00a00x20,</code> <code>France\u00a0=\u00a00x22,</code> <code>Georgia\u00a0=\u00a00x24,</code> <code>Germany\u00a0=\u00a00x18,</code> <code>Greece\u00a0=\u00a00x25,</code> <code>Guatemala\u00a0=\u00a00x26,</code> <code>Honduras\u00a0=\u00a040,</code> <code>HongKong\u00a0=\u00a00x27,</code> <code>Hungary\u00a0=\u00a00x2a,</code> <code>Iceland\u00a0=\u00a00x31,</code> <code>India\u00a0=\u00a00x2e,</code> <code>Indonesia\u00a0=\u00a00x2b,</code> <code>Iran\u00a0=\u00a00x30,</code> <code>Iraq\u00a0=\u00a00x2f,</code> <code>Ireland\u00a0=\u00a00x2c,</code> <code>Israel\u00a0=\u00a00x2d,</code> <code>Italy\u00a0=\u00a050,</code> <code>Jamaica\u00a0=\u00a00x33,</code> <code>Japan\u00a0=\u00a00x35,</code> <code>Jordan\u00a0=\u00a00x34,</code> <code>Kazakhstan\u00a0=\u00a00x3a,</code> <code>Kenya\u00a0=\u00a00x36,</code> <code>Korea\u00a0=\u00a00x38,</code> <code>Kuwait\u00a0=\u00a00x39,</code> <code>Kyrgyzstan\u00a0=\u00a00x37,</code> <code>Latvia\u00a0=\u00a00x3f,</code> <code>Lebanon\u00a0=\u00a00x3b,</code> <code>LibyanArabJamahiriya\u00a0=\u00a00x40,</code> <code>Liechtenstein\u00a0=\u00a060,</code> <code>Lithuania\u00a0=\u00a00x3d,</code> <code>Luxembourg\u00a0=\u00a00x3e,</code> <code>Macao\u00a0=\u00a00x45,</code> <code>Macedonia\u00a0=\u00a00x43,</code> <code>Malaysia\u00a0=\u00a00x48,</code> <code>Maldives\u00a0=\u00a070,</code> <code>Mexico\u00a0=\u00a00x47,</code> <code>Monaco\u00a0=\u00a00x42,</code> <code>Mongolia\u00a0=\u00a00x44,</code> <code>Morocco\u00a0=\u00a00x41,</code> <code>Netherlands\u00a0=\u00a00x4a,</code> <code>NewZealand\u00a0=\u00a00x4c,</code> <code>Nicaragua\u00a0=\u00a00x49,</code> <code>Norway\u00a0=\u00a00x4b,</code> <code>Oman\u00a0=\u00a00x4d,</code> <code>Pakistan\u00a0=\u00a00x51,</code> <code>Panama\u00a0=\u00a00x4e,</code> <code>Paraguay\u00a0=\u00a00x55,</code> <code>Peru\u00a0=\u00a00x4f,</code> <code>Philippines\u00a0=\u00a080,</code> <code>Poland\u00a0=\u00a00x52,</code> <code>Portugal\u00a0=\u00a00x54,</code> <code>PuertoRico\u00a0=\u00a00x53,</code> <code>Qatar\u00a0=\u00a00x56,</code> <code>Romania\u00a0=\u00a00x57,</code> <code>RussianFederation\u00a0=\u00a00x58,</code> <code>SaudiArabia\u00a0=\u00a00x59,</code> <code>Singapore\u00a0=\u00a00x5b,</code> <code>Slovakia\u00a0=\u00a00x5d,</code> <code>Slovenia\u00a0=\u00a00x5c,</code> <code>SouthAfrica\u00a0=\u00a00x6d,</code> <code>Spain\u00a0=\u00a00x1f,</code> <code>Sweden\u00a0=\u00a090,</code> <code>Switzerland\u00a0=\u00a00x12,</code> <code>SyrianArabRepublic\u00a0=\u00a00x60,</code> <code>Taiwan\u00a0=\u00a00x65,</code> <code>Thailand\u00a0=\u00a00x61,</code> <code>TrinidadAndTobago\u00a0=\u00a0100,</code> <code>Tunisia\u00a0=\u00a00x62,</code> <code>Turkey\u00a0=\u00a00x63,</code> <code>Ukraine\u00a0=\u00a00x66,</code> <code>UnitedArabEmirates\u00a0=\u00a01,</code> <code>UnitedKingdom\u00a0=\u00a00x23,</code> <code>UnitedStates\u00a0=\u00a00x67,</code> <code>Unknown\u00a0=\u00a00,</code> <code>Uruguay\u00a0=\u00a00x68,</code> <code>Uzbekistan\u00a0=\u00a00x69,</code> <code>Venezuela\u00a0=\u00a00x6a,</code> <code>Vietnam\u00a0=\u00a00x6b,</code> <code>Yemen\u00a0=\u00a00x6c,</code> <code>Zimbabwe\u00a0=\u00a0110</code> <code>}</code></p>"},{"location":"System-Software/Profile_Account/#subscriptionteir","title":"SubscriptionTeir","text":"<p><code>enum\u00a0SubscriptionTeir</code> <code>{</code> <code>NoSubcription,</code> <code>Silver\u00a0=\u00a03,</code> <code>Gold\u00a0=\u00a06,</code> <code>FamilyGold\u00a0=\u00a09</code> <code>};</code></p>"},{"location":"System-Software/Profile_Account/#language","title":"Language","text":"<p><code>enum\u00a0ConsoleLanguage</code> <code>{</code> <code>None,</code> <code>English,</code> <code>Japanese,</code> <code>German,</code> <code>French,</code> <code>Spanish,</code> <code>Italian,</code> <code>Korean,</code> <code>TChinese,</code> <code>Portuguese,</code> <code>SChinese,</code> <code>Polish,</code> <code>Russian</code> <code>};</code></p> <p>System Software</p>"},{"location":"System-Software/Reversing_the_bootloaders/","title":"Reversing the bootloaders","text":"<p>Since there seems to be little to none documentation about this so I've decided to write up a guide to help all the up-and-coming hackers in the scene.</p>"},{"location":"System-Software/Reversing_the_bootloaders/#requirements","title":"Requirements","text":"<ul> <li>IDA Pro (This costs money, it's recommended you buy a license)</li> <li>PPC Altivec plugin (ver. 1.8 is recommended)</li> <li>Decrypted loader (1BL/CB(_A)/CB_B/CD/CF)</li> <li>Kernel with symbols, find this at usual places (Also, match these up     by the date modified and put the pdb in same folder as exe)</li> </ul>"},{"location":"System-Software/Reversing_the_bootloaders/#reversing","title":"Reversing","text":""},{"location":"System-Software/Reversing_the_bootloaders/#finding-the-entrypoint","title":"Finding the entrypoint","text":"<p>The entrypoint of the loader is located at offset 0x8-0xC in the loader header, once you've found the entrypoint the reversing can begin.</p>"},{"location":"System-Software/Reversing_the_bootloaders/#analyzing-the-loader","title":"Analyzing the loader","text":"<p>Open the loader in IDA Pro and make sure it's loading as a binary file with the processor type set to PowerPC: ppc. Once you've done that a dialog should appear asking if you want it to be mapped to ROM or RAM, leave this screen as it is and just press OK. IDA will then notify you that since it's a binary file the entrypoint is unknown, so press G to show the go to address screen and put in the entrypoint you found earlier. Press C to turn this entrypoint into code and start IDA's analysis. This should only take a few seconds and then the entire bootloader should be fully analyzed.</p>"},{"location":"System-Software/Reversing_the_bootloaders/#finding-functions","title":"Finding functions","text":"<p>I wasn't going to post this publicly for fear of MS updating their bootloaders to use different code, but I realized that keeping info back is for kids. Thankfully Microsoft use the same code for the most of the functions in the bootloaders as they do in the kernel, if you have a copy of the kernel and symbols (available in certain private SDKs..) you can just find the functions in the kernel, copy the hex code for them (make sure none of the branch instructions are in the code, as these use static offsets) and search for that hex in the bootloader. If you've done it correctly you should come across code in the bootloader which looks near identical to the code in the kernel. Just rename the sub to what it's called in the kernel and you've successfully \"reversed\" a section of the bootloader :D</p> <p>(also, before anyone complains to me about this I know this is the \"noob\" way of doing it, but its much easier then having to trawl through code)</p>"},{"location":"System-Software/Reversing_the_bootloaders/#functions-used-by-the-bootloaders","title":"Functions used by the bootloaders","text":"<p>Note, this list is incomplete, I've only included functions used for authentication/decompression here, also some loaders don't include all these functions.</p> <ul> <li>LDICreateDecompression</li> <li>LDIDecompress</li> <li>LZX_Decode</li> <li>LZX_DecodeInit</li> <li>LZX_DecodeNewGroup</li> <li>XeCryptBnDw_Copy</li> <li>XeCryptBnQwBeSigDifference</li> <li>XeCryptBnQwBeSigFormat</li> <li>XeCryptBnQwNeCompare</li> <li>XeCryptBnQwNeModInv</li> <li>XeCryptBnQwNeModMul</li> <li>XeCryptBnQw_Copy</li> <li>XeCryptHmacSha</li> <li>XeCryptHmacShaFinal</li> <li>XeCryptHmacShaInit</li> <li>XeCryptMemDiff</li> <li>XeCryptRc4Ecb</li> <li>XeCryptRc4Key</li> <li>XeCryptRotSum</li> <li>XeCryptRotSumSha</li> <li>XeCryptShaFinal</li> <li>XeCryptShaInit</li> <li>XeCryptShaTransform</li> <li>XeCryptShaUpdate</li> </ul>"},{"location":"System-Software/Reversing_the_bootloaders/#finding-authentication-procedures","title":"Finding authentication procedures","text":"<p>Almost all the authentication subs in the bootloaders use XeCryptRotSumSha, once you've managed to find that function you can just do \"Jump to xref to operand...\" to find them. The bootloader decryption routines all use XeCryptRc4Ecb, if you find that you can find the decryption routines quite easily.</p>"},{"location":"System-Software/Reversing_the_bootloaders/#tips","title":"Tips","text":"<ul> <li>If you see the value 0x3C0030 in the function, this is used during     CF decryption/authentication. You've just found the function used to     decrypt/auth CF.</li> <li>li r3, 0 is used to return that the decryption/auth failed, if     theres any branches to code which has this then that means the     branch is only used if a check fails, if you want to make it so you     can run the next bootloader unauthenticated you could just nop (60     00 00 00) out all the branches to this code.</li> <li>Patching the call to XeCryptRc4Ecb with nop will disable encryption     for the next loader, this is what the glitch hack build.py does to     the CB_B of slims, along with patching out the branch to the panic     function.</li> <li>All of the bootloaders have a function to handle post output during     boot. If you find that function, you can follow its references and     use the post codes from POST to step through each     bootloader and figure out what each one is doing.</li> <li>Please keep in mind that the newest versions of the bootloaders had     their post codes removed due to the RGH hack relying on them.</li> </ul>"},{"location":"System-Software/Reversing_the_bootloaders/#code-snippets","title":"Code Snippets","text":""},{"location":"System-Software/Reversing_the_bootloaders/#panic","title":"panic","text":"<pre><code>panic:\n     li    r0, 0         # Load Immediate\n     mtspr CTRL, r0      # Move to sprg,\n     b     panic         # Branch\n</code></pre>"},{"location":"System-Software/Reversing_the_bootloaders/#post-output","title":"post output","text":"<pre><code>#Sends the lowest byte of r4 to the post buffer\npost:\n    sldi    r4, r4, 56\n    std r4, 0(r3)\n    blr\n</code></pre>"},{"location":"System-Software/Reversing_the_bootloaders/#reversed-bootloaders","title":"Reversed Bootloaders","text":"<p>The following bootloaders have already been reversed and posted:</p> <ul> <li>1bl Code</li> <li>CB Code</li> </ul>"},{"location":"System-Software/SFCX/","title":"SFCX","text":"<p>System Software Category: Pages That Need Updates</p>"},{"location":"System-Software/Shadowboot/","title":"Shadowboot","text":"<p>Development kits have an undocumented, internal feature called 'shadow booting' which allows them to enter an alternate boot chain during the boot process. By placing a specially crafted file titled 'xboxromw2d.bin' on the root of the system's hard disk, on bootup the system will start, begin the process, then reboot again, finally completing the boot sequence having loaded from the bootloaders from the file on disk. Shadowbooting allows you to apply patches to any part of the system software stack from the 2BL up without reflashing the NAND.</p> <p>Once booted from shadowboot, the alternate bootloaders are loaded into memory just the same as a normal boot sequence: analyzing a NAND dump from a live shadow booted system (the flash dumped while the system is running) shows the SB, SD, and SE bootloaders on the system.</p> <p>Shadow booting has long been held a closely guarded secret within the community, where only recently have its existence become widely known due to their use with Xbox Live challenge bypass services.</p>"},{"location":"System-Software/Shadowboot/#test-kits","title":"Test Kits","text":"<p>Unlike full development kits, test kits are limited in their ability to do kernel debugging among other restrictions. Test kits run on a different software stack than dev kits, and as such require their own shadowboot during updates. ISO recoveries contain two shadowboot ROMs, 'xboxromw2d.bin' and 'xboxromtw2d.bin', which will initiate shadowboot on dev and test kits, respectively.</p>"},{"location":"System-Software/Shadowboot/#obtaining-a-shadowboot-rom","title":"Obtaining a shadowboot ROM","text":"<p>Shadowbooting is used in the recovery process.</p>"},{"location":"System-Software/Shadowboot/#iso-recoveries","title":"ISO Recoveries","text":"<p>Open an ISO recovery with an archiver and you will find the xboxromw2.bin and xboxromtw2.bin files. These are the \"clean\" shadowboot sources from which we base our modifications.</p>"},{"location":"System-Software/Shadowboot/#remote-recoveries","title":"Remote Recoveries","text":"<p>Remote recoveries also contain many shadowboot files (60 files) of varying sizes.</p>"},{"location":"System-Software/Shadowboot/#file-structure","title":"File Structure","text":"<p>Found in recovery images, shadowboot files are binaries titled 'xboxromw2d.bin' and 'xboxromtw2d.bin'. Full development kits will find and boot from xboxromw2d.bin and test kits xboxromtw2d.bin. Shadowboot files are always 832KB (851,968 bytes).</p> <p>Structurally, shadowboot files are nearly identical to flash dumps, but for obvious reasons they do not contain mobiles or filesystems.</p> File Structure Section File Header SMC Keyvault 2BL 3BL 4BL 5BL"},{"location":"System-Software/Shadowboot/#file-header","title":"File Header","text":"File Header Section Magic bytes Major Build QFE? Flags SB offset CF1 offset/Size? Microsoft copyright Padding KV size? CF1 offset? Patch slots KV version KV offset Patch slot size? Metadata style? (360FlashTool) SMC config offset SMC length SMC offset <p>On shadowboot ROMs the build number will be the major XDK flash version (ie. 21250). On the hacked 16547 shadowboot ROM it is 16547 On a cold flash dump, the build number will always be 1888.</p> <p>On xboxromtw2 shadowboot ROMs, the SB offset is 0xc0000 whereas on both normal ROMs and NAND dumps it is 0x8000</p> <p>On NAND dumps the CF1 offset is 0x080000 while on shadowboot ROMs it is 0x0d000</p> <p>The Microsoft copyright notice is as follows (ASCII) followed by a null byte terminator (0x00)</p> <p><code>\u00a9 2004-2011 Microsoft Corporation. All rights reserved.</code></p> <p>Note that later NAND dumps may have updated the years in this string.</p> <p>The unknown flag at 0x70 reads 0x0002(0000) on the NAND dump and 0x0001(0000) on the shadowboot ROMs</p> <p>The 360FlashTool changelog notes the value at offset 0x71 as the 'metadata style,' where \"0 = Original, 1 = New 16MB, 2 = Large Block\"</p> <ul> <li>I am unsure about the size of all of the data after the copyright     notice, and especially unsure of everything near 0x70.</li> </ul>"},{"location":"System-Software/Shadowboot/#keyvault","title":"Keyvault","text":"<p>The keyvault data section is entirely zeroed through, meaning that there is no keyvault. The KV data is probably loaded into RAM on the first startup sequence using the console's native bootloader's and may remain untouched by the shadowboot bootloader.</p>"},{"location":"System-Software/Shadowboot/#boot-process","title":"Boot Process","text":"<p>Development kernels contain a series of subroutines to find, validate and execute shadowboot ROMs found on various media. The first subroutine in this shadowboot process is ExpTryToShadowBoot, followed by ExpTryToBootMediaKernel, KiShadowBoot, KiQuiesce, and finally HvxShadowBoot.</p> <p>The fact that these subroutines cannot be find in bootloaders prior to SE implies that the system must fully reach the kernel before rebooting into the shadow kernel.</p>"},{"location":"System-Software/Shadowboot/#media","title":"Media","text":"<p>The shadowboot process will attempt to boot from media in the following order</p> <ol> <li>Remote - ExpMediaKernelKdRemoteBuffer - \"host:\\\\xboxromw2d.bin\"</li> <li>CDRROM - ExpMediaKernelCdRom0Buffer     \"\\\\Device\\\\CdRom0\\\\xboxromw2d.bin\"</li> <li>Flash - Flash media kernelExpMediaKernelFlashBuffer     \"\\\\Device\\\\FlashFs\\\\xboxromw2d.bin\"</li> <li>Hard disk - ExpMediaKernelHd0Buffer     \"\\\\Device\\\\Harddisk0\\\\Partition1\\\\xboxromw2d.bin\"</li> </ol>"},{"location":"System-Software/Shadowboot/#security-measures","title":"Security Measures","text":""},{"location":"System-Software/Shadowboot/#encryption-schema","title":"Encryption Schema","text":"<p>Shadowboot bootloaders use a very similar encryption schema to retails with CB \\&lt;=1920 but for the presence of SC. Beginning with CB 1920, the retail CD bootloader encryption key also uses the CPU key, whereas SD on shadowboot ROMs does not.</p>"},{"location":"System-Software/Shadowboot/#rc4-key","title":"RC4 Key","text":"<p>Each bootloader holds a random 'salt' value that is used in the calculation of its RC4 key.</p> <p>The key is derived from a 'secret' from the previous bootloader's key, originating from the hardcoded key in the 1BL. The key is the 16 (0x10) byte truncated HMAC-SHA1 digest of the secret appended with a random salt.</p> <p><code>key = HMAC-SHA(previous_key + salt)[0:0x10]</code></p> <p>The bootloader's 'payload' (everything after 0x20 for SB/CB, SC,SD/CD,SE/CE,CG everything after 0x30 for CF) is encrypted with RC4. The decryption process looks like:</p> <p><code>decrypted = encrypted[0:0x10] + key + decrypt_RC4(key, encrypted[0x20:]</code></p>"},{"location":"System-Software/Shadowboot/#2bl-key","title":"2BL Key","text":"<p>As an example, you calculate the 2BL RC4 key by reading out its salt from 0x10 to 0x20. Calculate the HMAC SHA of this salt using the 1BL key as the secret. The RC4 key is the first 0x10 bytes of this digest.</p>"},{"location":"System-Software/Shadowboot/#3bl-key","title":"3BL Key","text":"<p>The 3BL (SC) is the exception to the rule. Its key is not generated using the RC4 key from the 2BL, but its secret is instead 0x10 null bytes.</p>"},{"location":"System-Software/Shadowboot/#4bl-key","title":"4BL Key","text":"<p>Calculate the 4BL RC4 key by reading out its salt from 0x10 to 0x20. Calculate the HMAC SHA of this salt using the 3BL RC4 key as the secret. The 4BL RC4 key is the first 0x10 bytes of this digest.</p>"},{"location":"System-Software/Shadowboot/#5bl-key","title":"5BL Key","text":"<p>Calculate the 5BL RC4 key by reading out its salt from 0x10 to 0x20. Calculate the HMAC SHA of this salt using the 4BL RC4 key as the secret. The 5BL RC4 key is the first 0x10 bytes of this digest.</p>"},{"location":"System-Software/Shadowboot/#signature","title":"Signature","text":"<p>There is a common misconception to shadowbooting where we are able to replace everything from the 2BL onward. While shadowboot ROMs contain a nearly complete NAND image, the 2BL (and subsequently the 3BL) are still protected by signature checks with the 2BL private key.</p> <p>The fundamental difference in bootloader security between retail and devkit is the replacement of precomputed hashes in retail bootloaders, where the only signature checks occur on 2BL, CB, and the 6BL, CF; on devkits, most of these hash checks are instead replaced with signature checks. On both the cold boot as well as shadowboot, the 2BL is verified with a signature check, which subsequently verifies SD with a signature check.</p> <p>System Software</p>"},{"location":"System-Software/XConfig/","title":"XConfig","text":""},{"location":"System-Software/XConfig/#categories","title":"Categories","text":"Category Value XCONFIG_STATIC_CATEGORY 0x0 XCONFIG_STATISTIC_CATEGORY 0x1 XCONFIG_SECURED_CATEGORY 0x2 XCONFIG_USER_CATEGORY 0x3 XCONFIG_XNET_MACHINE_ACCOUNT_CATEGORY 0x4 XCONFIG_XNET_PARAMETERS_CATEGORY 0x5 XCONFIG_MEDIA_CENTER_CATEGORY 0x6 XCONFIG_CONSOLE_CATEGORY 0x7 XCONFIG_DVD_CATEGORY 0x8 XCONFIG_IPTV_CATEGORY 0x9 XCONFIG_SYSTEM_CATEGORY 0xA"},{"location":"System-Software/XConfig/#notes","title":"Notes","text":"<pre><code>XCONFIG_STATIC_SETTINGS 0x0\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nCheckSum                      unsigned long               4           0x00\nVersion                       unsigned long               4           0x04\nFirstPowerOnDate                 char[]                   5           0x08      // key 0x1 5 bytes\nReserved                         char                     1           0x0D\nSMCBlock                      union_SMC_BLOCK             256         0x0E\n\n-----------------------------------------------------------------------------------------------------------\n\n\nSMC_BLOCK\n~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nStuctureVersion               unsigned char               1           0x0E\nConfigSource                  unsigned char               1           0x0F\nClockSelect                      char                     1           0x10\nFanOverride                struct_FAN_OVERRIDE            2           0x11\npad1                             char[]                   1           0x13\n\nRadioEnable                      char                     1           0x14            0                1       //This is the \"bit field\" at offset 6   ;// 1 byte total for this bitfield\nUseTempCalDefaults               char                     1           0x14            1                1\nScreenToolStarted                char                     1           0x14            2                1\nScreenToolFinished               char                     1           0x14            3                1\nScreenToolExecutionCount         char                     1           0x14            4                2\n\npad2                             char[]                   3           0x15\nTemperature                union_TEMPERATURE              16          0x18\nAnaFuseValue                     char                     1           0x28\nThermal                      struct_Thermal               6           0x29\npad3                         unsigned char[]              1           0x2F\nViper vFlags                  struct_VIPER                4           0x30\n\npad4                         unsigned char[]              190         0x34\n\nBackupThermalCalData    union_BACKUP_THERMAL_CAL_DATA     23          0xF2\npad5                         unsigned char[]              3           0x109\nDoNotUse                     unsigned char[]              2           0x10C\n\n\n\nFAN_OVERRIDE\n~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nCpu                    struct_FAN_OVERRIDE_CPU            1           0\nGpu                    struct_FAN_OVERRIDE_GPU            1           0\n\n// 01111111 &lt;- normally disabled as 0x7F\nEnable : 1; // says 7 is bit 0\nSpeed  : 7; // says 0 bit 7\n\nFAN_OVERRIDE_CPU\n--------------\nSpeed                        unsigned char                1           0              0                7\nEnable                       unsigned char                1           0              7                1\n\nFAN_OVERRIDE_GPU\n--------------\nSpeed                        unsigned char                1           0              0                7\nEnable                       unsigned char                1           0              7                1\n-----------------------------------------------------------------------------------------------------------\n\n\n\n\n\nTEMPERATURE\n~~~~~~~~~~~\n\n-------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nTempCalData                  unsigned short[]             16          0\nConstant               struct_TEMPERATURE_CONSTANT        16          0\n\n\nTEMPERATURE_CONSTANT\n-------------------\nCpu                   struct_TEMPERATURE_CONSTANT_CPU     4           0\nGpu                   struct_TEMPERATURE_CONSTANT_GPU     4           4\nEdram                struct_TEMPERATURE_CONSTANT_EDRAM    4           8\nBoard                struct_TEMPERATURE_CONSTANT_BOARD    4           12\n\n\nTEMPERATURE_CONSTANT_BOARD\n------------------------\nGain                         unsigned short               2           0\nOffset                       unsigned short               2           2\n\n\nTEMPERATURE_CONSTANT_CPU\n------------------------\nGain                         unsigned short               2           0\nOffset                       unsigned short               2           2\n\n\nTEMPERATURE_CONSTANT_GPU\n------------------------\nGain                         unsigned short               2           0\nOffset                       unsigned short               2           2\n\n\nTEMPERATURE_CONSTANT_EDRAM\n------------------------\nGain                         unsigned short               2           0\nOffset                       unsigned short               2           2\n-----------------------------------------------------------------------------------------------------------\n\n\n\nTHERMAL\n~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nSetPoint                struct_THERMAL_SET_POINT          3           0\nOverload                struct_THERMAL_OVERLOAD           3           3\n\n\nTHERMAL_SET_POINT\n---------------\nCpu                          Unsigned char                1           0\nGpu                          Unsigned char                1           1\nEdram                        Unsigned char                1           2\n\n\nTHERMAL_OVERLOAD\n---------------\nCpu                          Unsigned char                1           0\nGpu                          Unsigned char                1           1\nEdram                        Unsigned char                1           2\n-----------------------------------------------------------------------------------------------------------\n\n\n\nVIPER\n~~~~~\n\n------------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nFlags                      union_VIPER_FLAGS              1           0\nGpuTarget                    unsigned char                1           1\nMemoryTarget                 unsigned char                1           2\nChecksum                     unsigned char                1           3\n\n\nVIPER_FLAGS\n-----------\nAsUCHAR                      Unsigned char                1           0\nAsFlags                  struct_VIPER_AS_FLAGS            1           0\n\n\nVIPER_AS_FLAGS\n------------\nMemoryVoltageNotSetting      Unsigned char                1           0              6                1\n: 1; // bit 6 (bit 5 thru 0 unused\nGpuVoltageNotSetting         unsigned char                1           0              7                1\n: 1; // bit 7\n\n//u8 unknown : 6; // 1 byte\n    u8 GpuTarget;\n    u8 MemoryTarget;\n    u8 CheckSum;\n-----------------------------------------------------------------------------------------------------------\n\n\n\nBACKUP_THERMAL_CALS\n~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nTemperature                  union_TEMPERATURE            16          0                                     // Same as other info\nAnaFuseValue                     char                     1           16\nThermal                      struct_THERMAL               6           17\n-----------------------------------------------------------------------------------------------------------\n\n\n\n\n\n\nXCONFIG_STATISTIC_SETTINGS 0x1\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nCheckSum                     unsigned long                4           0\nVersion                      unsigned long                4           4\nXUIDMACAddress                  char[]                    6           8\nReserved                        char[]                    2           14\nXUIDCount                    unsigned long                4           16\nODDFailures                 unsigned char[]               32          20\nBugCheckData                unsigned char[]               101         52\nTemperatureData             unsigned char[]               200         153\nUnused                          char[]                    467         353\nHDDSmartData                    char[]                    512         820\nUEMErrors                       char[]                    100         1332\nFPMErrors                       char[]                    56          1432\nLastReportTime               unsigned int                 8           1488\n-----------------------------------------------------------------------------------------------------------\n\n\n\n\nXCONFIG_SECURED_SETTINGS 0x2   // This is the other static one right after the SMCBlock\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nCheckSum                     Unsigned Long                4           0\nVersion                      Unsigned Long                4           4\nOnlineNetworkID                  char[]                   4           8\nReserved1                        char[]                   8           12\nReserved2                        char[]                   12          20\nMACAddress                  unsigned char[]               6           32\nReserved3                        char[]                   2           38\nAVRegion                     unsigned long                4           40\nGameRegion                   unsigned short               2           44\nReserved4                        char[]                   6           46\nDVDRegion                    unsigned long                4           52\nResetKey                     unsigned long                4           56\nSystemFlags                  unsigned long                4           60\nPowerMode               struct_XCONFIG_POWER_MODE         2           64\nPowerVcsControl      struct_XCONFIG_POWER_VCS_CONTROL     2           66\nReservedRegion                   char[]                   444         68\n\n\n\nPOWER_MODE\n---------\nVIDDelta                     unsigned char                1           0\nReserved                     unsigned char                1           1\n\n\n\nPOWER_VCS_CONTROL\n---------------\nConfigured                   unsigned short               2           0              15               1\nReserved                     unsigned short               2           0              12               3\nFull                         unsigned short               2           0              8                4\nQuiet                        unsigned short               2           0              4                4\nFuse                         unsigned short               2           0              0                4\n-----------------------------------------------------------------------------------------------------------\n\n\n\n\nXCONFIG_USER_SETTINGS 0x3\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nCheckSum                     unsigned long                4           0\nVersion                      unsigned long                4           4\nTimeZoneBias                 unsigned long                4           8\nTimeZoneStdName                 char[]                    4           12\nTimeZoneDltName                 char[]                    4           16\nTimeZoneStdDate        struct_XCONFIG_TIMEZONE_DATE       4           20\nTimeZoneDltDate        struct_XCONFIG_TIMEZONE_DATE       4           24\nTimeZoneStdBias              unsigned long                4           28\nTimeZoneDltBias              unsigned long                4           32\nDefaultProfile               unsigned int                 8           36\nLanguage                     unsigned long                4           44\nVideoFlags                   unsigned long                4           48\nAudioFlags                   unsigned long                4           52\nRetailFlags                  unsigned long                4           56\nDevkitFlags                  unsigned long                4           60\nCountry                          char                     1           64\nParentalControlFlags             char                     1           65\nReservedFlag                unsigned char[]               2           66\nSMBConfig                       char[]                    256         68\nLivePUID                     unsigned int                 8           324\nLiveCredentials                 char[]                    16          332\nAVPackHDMIScreenSz           signed short[]               4           348\nAVPackComponentScreenSz      signed short[]               4           352\nAVPackVGAScreenSz            signed short[]               4           356\nParentalControlGame          unsigned long                4           360\nParentalControlPassword      unsigned long                4           364\nParentalControlMovie         unsigned long                4           368\nParentalControlGameRating    unsigned long                4           372\nParentalControlMovieRating   unsigned long                4           376\nParentalControlHint              char                     1           380\nParentalControlHintAnswer       char[]                    32          381\nParentalControlOverride         char[]                    32          413\nMusicPlaybackMode            unsigned long                4           445\nMusicVolume                     float                     4           449\nMusicFlags                          unsigned long         4           453\nArcadeFlags                         unsigned long         4           457\nParentalControlVersion              unsigned long         4           461\nParentalControlTv                   unsigned long         4           465\nParentalControlTvRating             unsigned long         4           469\nParentalControlExplicitVideo        unsigned long         4           473\nParentalControlExplicitVideoRating  unsigned long         4           477\nParentalControlUnratedVideo         unsigned long         4           481\nParentalControlUnratedVideoRating   unsigned long         4           485\nVideoOutputBlackLevels              unsigned long         4           489\nVideoPlayerDisplayMode              unsigned char         1           493\nAlternativeVideoTimingIDs           unsigned long         4           494\nVideoDriverOptions                  unsigned long         4           498\nMusicUIFlags                        unsigned long         4           502\nVideoMediaSourceType             char                     1           506\nMusicMediaSourceType             char                     1           507\nPhotoMediaSourceType             char                     1           508\n\n\n\n\nXCONFIG_TIMEZONE_DATE\n---------------------\nMonth                        unsigned char                1           0\nDay                          unsigned char                1           1\nDayOfWeek                    unsigned char                1           2\nHour                         unsigned char                1           3\n-----------------------------------------------------------------------------------------------------------\n\n\n\n\nXCONFIG_XNET_MACHINE_ACCOUNT 0x4\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nVersion                      unsigned long                4           0\nData                        unsigned char[]               492         4\n-----------------------------------------------------------------------------------------------------------\n\n\n\n\nXCONFIG_XNET_PARAMETERS 0x5   //I believe this is XnetStartupParams which is retrieved at sockinit in xam\n~~~~~~~~~~~~~~~~~~~~~~~~~~~   // so this is a struct of XNetStartupParams, but that might not be right.\n                              // these Qos things seem to be the \"Ping Limit\"\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\ncfgSizeOfStruct                    unsigned char          1           0\ncfgFlags                           unsigned char          1           1\ncfgSockMaxDgramSockets             unsigned char          1           2\ncfgSockMaxStreamSockets            unsigned char          1           3\ncfgSockDefaultRecvBufsizeInK       unsigned char          1           4\ncfgSockDefaultSendBufsizeInK       unsigned char          1           5\ncfgKeyRegMax                       unsigned char          1           6\ncfgSecRegMax                       unsigned char          1           7\ncfgQosDataLimitDiv4                unsigned char          1           8\ncfgQosProbleTimeoutInSeconds       unsigned char          1           9\ncfgQosProbeEntries                 unsigned char          1           10\ncfgQosSrvMaxSimultaneousResponses  unsigned char          1           11\ncfgQosPairWaitTimeInSeconds        unsigned char          1           12\n-----------------------------------------------------------------------------------------------------------\n\n\n\nXCONFIG_MEDIA_CENTER_SETTINGS 0x6\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nCheckSum                     unsigned long                4           0\nVersion                      unsigned long                4           4\nMediaPlayer                     char[]                    20          8\nxeSledVersion               unsigned char[]               10          28\nxeSledTrustSecret           unsigned char[]               20          38\nxeSledTrustCode             unsigned char[]               8           58\nxeSledHostID                unsigned char[]               20          66\nxeSledKey                   unsigned char[]               1628        86\nxeSledHostMACAddress        unsigned char[]               6           1714\nServerUUID                      char[]                    16          1720\nServerName                      char[]                    128         1736\nServerFlags                     char[]                    4           1864\n\n\n\n\n\n\nXCONFIG_CONSOLE_SETTINGS 0x7\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nCheckSum                     unsigned long                4           0\nVersion                      unsigned long                4           4\nScreenSaver                  signed short                 2           8\nAutoShutOff                  signed short                 2           10\nWirelessSettings            unsigned char[]               256         12\nCameraSettings               unsigned long                4           268\nCameraSettingsReserved      unsigned char[]               28          272\nPlayTimerData         struct_XCONFIG_PLAY_TIMER_DATA      20          300\nMediaDisableAutoLaunch       signed short                 2           320\nKeyboardLayout               signed short                 2           322\n\n\n\nPLAY_TIMER_DATA\n-------------\nuliResetDate              union_ULARGE_INTEGER            8           0\ndwPlayTimerFrequency         unsigned long                4           8\ndwTotalPlayTime              unsigned long                4           12\ndwRemainingPlayTime          unsigned long                4           16\n\n\nunion_ULARGE_INTEGER\n--------------------\nHighPart                     unsigned long                4           0\nLowPart                      unsigned long                4           4\nu                         unnamed_ULARGE_INTEGER          8           0\nQuadPart                     unsigned int                 8           0\n\n\nunnamed_ULARGE_INTEGER\n----------------------\nHighPart                     unsigned long                4           0\nLowPart                      unsigned long                4           0\n-----------------------------------------------------------------------------------------------------------\n\n\n\n\nXCONFIG_DVD_SETTINGS 0x8\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nVersion                      unsigned long                4           0\nVolumeID                    unsigned char[]               20          4\nData                        unsigned char[]               640         24\n-----------------------------------------------------------------------------------------------------------\n\n\n\n\nXCONFIG_IPTV_SETTINGS 0x9\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nCheckSum                     unsigned long                4           0\nVersion                      unsigned long                4           4\nServiceProviderName            wchar_t[]                  120         8\nProvisioningServerURL          wchar_t[]                  128         128\nSupportInfo                    wchar_t[]                  128         256\nBootstrapServerURL             wchar_t[]                  128         384\n\n\n\nXCONFIG_SYSTEM_SETTINGS 0xA\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n-----------------------------------------------------------------------------------------------------------\nField Name                       Type                Field Size     Offset    Bit Position       Bit Length\n-----------------------------------------------------------------------------------------------------------\nVersion                      unsigned long                4            0\nAlarmTime                 union_LARGE_INTEGER             8            4\nPreviousFlashVersion         unsigned long                4            12\n-----------------------------------------------------------------------------------------------------------\n</code></pre> <p>Category: Pages That Need Updating</p>"},{"location":"System-Software/XDK_Kernel/","title":"XDK Kernel","text":"XDK Version Flash Version Comment 2.0.0198.0 2.0.????.0 First XDK Launcher Alpha 1 2.0.1232.0 2.0.????.0 Second XDK Launcher Alpha 2 2.0.1838.1 2.0.1838.1 Beta Launcher 2.0.1839.2 2.0.????.0 XeDK release Dashboard 2.0.1888.0 2.0.1888.0 XeDK 2.0.2099.9 2.0.????.0 XeDK 2.0.2135.0 2.0.????.0 XeDK 2.0.2417.0 2.0.2241.0 XeDK 2.0.2638.0 2.0.2258.0 XeDK 2.0.2638.0 2.0.2419.0 XeDK 2.0.2920.0 2.0.2832.0 XeDK - Remote includes 1888, 2241, 2255, 2258 and 2832 2.0.3215.0 2.0.2853.0 XeDK 2.0.3424.0 2.0.2858.0 XeDK 2.0.4314.0 2.0.4308.0 XeDK 2.0.4802.0 2.0.????.0 XeDK 2.0.4929.0 2.0.4548.0 XeDK 2.0.5426.0 2.0.4548.0 XeDK - Last recovery KK exploit works 2.0.5632.0 2.0.4548.0 XeDK - Remote includes 4548 and 5632 2.0.5787.0 2.0.????.0 XeDK - ISO image in game format 2.0.6132.0 2.0.5759.0 XeDK 2.0.6274.0 2.0.????.0 XeDK 2.0.6534.0 2.0.5759.0 XeDK - Remote includes 5787 (no 5759 ?) 2.0.6534.4 2.0.6683.0 XeDK 2.0.6707.0 2.0.????.0 XeDK 2.0.6995.0 2.0.6690.0 XeDK 2.0.6995.1 2.0.6690.0 XeDK 2.0.7645.0 2.0.6690.0 XeDK - Remote includes 6690 2.0.7645.1 2.0.6690.0 XeDK 2.0.7776.0 2.0.6719.0 XeDK 2.0.7776.1 2.0.6719.0 XeDK 2.0.7978.0 2.0.7342.0 XeDK 2.0.7978.3 2.0.7359.0 XeDK 2.0.8276.0 2.0.7366.0 XeDK 2.0.8953.0 2.0.????.0 XeDK 2.0.9328.0 2.0.8464.0 XeDK - Remote includes 8464 and 7366 2.0.9328.5 2.0.8498.0 XeDK 2.0.9328.8 2.0.????.0 XeDK 2.0.9328.9 2.0.8955.0 XeDK - DO NOT RUN THE LEAKED ISO RECOVERY it was edited by TheFallen93 (afaik) and others to brick kits. You can find the real 9328.9 iso around though with filesize 301,434,880 bytes 2.0.11164.0 2.0.9189.0 XeDK 2.0.11164.1 2.0.9189.0 XeDK 2.0.11511.0 2.0.11025.0 XeDK 2.0.11626.0 2.0.?????.0 XeDK 2.0.11626.1 2.0.?????.0 XeDK 2.0.11775.3 2.0.12387.0 XeDK - ISO leaked from chinese forums, remote includes 12387 and 9199 2.0.11776.3 2.0.?????.0 XeDK 2.0.20353.0 2.0.12611.0 XeDK - Remote leaked from MS server 2.0.20353.2 2.0.12625.0 XeDK 2.0.20500.1 2.0.13139.0 XeDK <p>System Software</p>"},{"location":"System-Software/Formats/FMIM/","title":"FMIM","text":"<p>FMIM files are used by the Xbox 360 \"System Music Player\" to store music ripped from a CD. They are stereo WMA 9.1 files, with one pass CBR (constant bitrate) at 192kbps/44.1kHz.</p>"},{"location":"System-Software/Formats/FMIM/#fmim","title":"FMIM","text":""},{"location":"System-Software/Formats/FMIM/#header","title":"Header","text":"Offset Length Type Information 0x0 0x4 ascii string magic \"FMIM\" / 0x464D494D 0x4 0x8 bytes magic (?) unknown purpose but always 0x100010001 0xC 0x200 unicode string Track Title 0x20C 0x200 unicode string Album Name 0x40C 0x200 unicode string Artist #1 0x60C 0x200 unicode string Artist #2 (reason for duplicate unknown, locale?) 0x80C 0x200 unicode string Genre #1 0xA0C 0x200 unicode string Genre #2 (reason for duplicate unknown, locale?) 0xC0C 0x4 unsigned int Track Length (milliseconds, to nearest second) 0xC10 0x4 unsigned int Track Number on Album (starts from 0x1) 0xC14 0xF4 bytes Unknown, sometimes contains readable text 0xD08 ... (rest of the file) bytes WMA 9.1 file containing audio as described above"},{"location":"System-Software/Formats/GPD/","title":"GPD (Game Profile Data)","text":"<p>GPD (Game Profile Data) files are used by the Xbox 360 to store information inside a profile. They are based on the XDBF format. Profiles are composed of many of these files, each named under their respective titles id (e.g. 4D5307E6.gpd for Halo 3). The dashboard GPD (<code>FFFE07D1.gpd</code>) contains information and sync information about all the titles.</p>"},{"location":"System-Software/Formats/GPD/#entry-table","title":"Entry Table","text":""},{"location":"System-Software/Formats/GPD/#entry-namespaces","title":"Entry Namespaces","text":"Value Description 1 Achievement 2 Image 3 Setting 4 Title 5 String 6 Achievement Security (created by GFWL for offline unlocked achievements?) 6 Avatar Award (360 only, this is only stored with in the PEC"},{"location":"System-Software/Formats/GPD/#entry-ids","title":"Entry IDs","text":"<p>An ID of 0x100000000 indicates that the entry is a Sync List, an ID of 0x200000000 means its a Sync Data entry. In PEC (Profile Embedded Content) files these are changed to 1 and 2.</p> <p>The Settings, Achievements, Title and Assets namespaces each have their own Sync List and Sync Data entries.</p> <p>An ID of 0x8000 is reserved for title information, in the string and image namespaces. For achievements and images the entry id must match the id enclosed in the entry data.</p> Description Value Sync List 0x100000000 Sync Data 0x200000000 Sync List (PEC) PEC Sync Data (PEC) PEC Option Controller Vibration 0x10040003 Title Specific 1 0x63E83FFF Title Specific 2 0x63E83FFE Title Specific 3 0x63E83FFD Gamer Yaxis Inversion 0x10040002 Gamercard Zone 0x10040004 Gamercard Region 0x10040005 Gamercard Cred 0x10040006 Gamercard Rep 0x50040011 Option Voice Muted 0x10040012 Option Voice Thru Speakers 0x10040013 Option Voice Thru Speakers Raw 0x10040063 Option Voice Volume 0x10040014 Gamercard Titles Played 0x10040018 Gamercard Achievements Earned 0x10040019 Gamer Difficulty 0x10040021 Gamer Control Sensitivity 0x10040024 Gamer Preferred Color First 0x10040029 Gamer Preferred Color Second 0x10040030 Gamer Action Auto Aim 0x10040034 Gamer Action Auto Center 0x10040035 Gamer Action Movement Control 0x10040036 Gamer Race Transmission 0x10040038 Gamer Race Camera Location 0x10040039 Gamer Race Brake Control 0x10040040 Gamer Race Accelerator Control 0x10040041 Gamercard Title Cred Earned 0x10040056 Gamercard Title Achievements Earned 0x10040057 Avatar Metadata 0x63E80068 Gamercard Picture Key 0x4064000F Gamercard Motto 0x402C0011 Title Information 0x8000 Gamer Name 0x41040040 Gamer Location 0x40520041 Avatar Information 0x63e80044 Avatar Image 0x8007 <p>Setting IDs are largely deterministic, based on there type max length see sample code</p>"},{"location":"System-Software/Formats/GPD/#entry-structures","title":"Entry Structures","text":""},{"location":"System-Software/Formats/GPD/#achievement-entries","title":"Achievement Entries","text":"Offset Length Type Information 0x0 0x4 unsigned int Struct size (0x1C) 0x4 0x4 unsigned int Achievement ID 0x8 0x4 unsigned int Image ID 0xC 0x4 signed int Gamerscore 0x10 0x4 unsigned int Flags (see below) 0x14 0x8 System.DateTime(signed long) Unlock Time 0x18 null terminated unicode string Name 0x18 + Name length null terminated unicode string Unlocked Description 0x18 + Name length + Locked Description length null terminated unicode string Locked Description"},{"location":"System-Software/Formats/GPD/#flags","title":"Flags","text":"<pre><code>public\u00a0enum\u00a0AchievementTypes\u00a0:\u00a0byte\n{\n\u00a0\u00a0\u00a0\u00a0Completion\u00a0=\u00a01,\n\u00a0\u00a0\u00a0\u00a0Leveling\u00a0=\u00a02,\n\u00a0\u00a0\u00a0\u00a0Unlock\u00a0=\u00a03,\n\u00a0\u00a0\u00a0\u00a0Event\u00a0=\u00a04,\n\u00a0\u00a0\u00a0\u00a0Tournament\u00a0=\u00a05,\n\u00a0\u00a0\u00a0\u00a0Checkpoint\u00a0=\u00a06,\n\u00a0\u00a0\u00a0\u00a0Other\u00a0=\u00a07,\n}\n\npublic\u00a0System.UInt32\u00a0Flags;\npublic\u00a0AchievementTypes\u00a0AchievementType\n{\n\u00a0\u00a0\u00a0\u00a0get\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0(AchievementTypes)(Flags\u00a0&amp;\u00a07);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0set\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0((System.Byte)value\u00a0&gt;\u00a07)\u00a0//\u00a0to\u00a0may\u00a0bits\u00a0in\u00a0use\u00a0:O\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw\u00a0new\u00a0Exceptions.InvalidAchievement(new\u00a0System.Exception(\"Invalid\u00a0Type\"));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(value\u00a0!=\u00a0Type)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Flags\u00a0^=\u00a04294967288;\u00a0//\u00a0Null\u00a0the\u00a03\u00a0bits\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Flags\u00a0^=\u00a0(System.Byte)Type;\u00a0//\u00a0set\u00a0the\u00a0new\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\npublic\u00a0System.Boolean\u00a0AchievementShowUnachieved\u00a0//\u00a0!Sectet\n{\n\u00a0\u00a0\u00a0\u00a0get\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0(Flags\u00a0&amp;\u00a08)\u00a0==\u00a08;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0set\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(value\u00a0!=\u00a0ShowUnachieved)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Flags\u00a0^=\u00a08;\n\u00a0\u00a0\u00a0\u00a0}\n}\npublic\u00a0System.Boolean\u00a0AchievementEarnedOnline\n{\n\u00a0\u00a0\u00a0\u00a0get\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0(Flags\u00a0&amp;\u00a065536)\u00a0==\u00a065536;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0set\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(value\u00a0!=\u00a0AchievementEarnedOnline)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Flags\u00a0^=\u00a065536;\n\u00a0\u00a0\u00a0\u00a0}\n}\npublic\u00a0System.Boolean\u00a0AchievementEarned\n{\n\u00a0\u00a0\u00a0\u00a0get\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0(Flags\u00a0&amp;\u00a0131072)\u00a0==\u00a0131072;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0set\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(value\u00a0!=\u00a0Achieved)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Flags\u00a0^=\u00a0131072;\n\u00a0\u00a0\u00a0\u00a0}\n}\npublic\u00a0System.Boolean\u00a0Edited\u00a0//?\n{\n\u00a0\u00a0\u00a0\u00a0get\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0(Flags\u00a0&amp;\u00a01048576)\u00a0==\u00a01048576;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0set\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0(value\u00a0!=\u00a0Edited)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Flags\u00a0^=\u00a01048576;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre>"},{"location":"System-Software/Formats/GPD/#setting-entries","title":"Setting Entries","text":"Offset Length Type Information 0 4 Int32 SettingID 4 2 UInt16 DOS Time(Last edited?) 6 2 UInt16 Unknown 8 1 Byte DataType (see Below) 9 7 Byte[] Unknown (always null?) 16 *depends on DataType* *depends on DataType* Data Description Value Context 0 Int32 1 Int64 2 Double 3 (UNI)String 4 Float 5 Binary 6 DateTime 7 Null 0xFF <p>With data type string and binary there is a leading Int32 with the length in the data blob.</p>"},{"location":"System-Software/Formats/GPD/#image-entries","title":"Image Entries","text":"<p>Image entries are PNG images. example code:</p> <pre><code>public\u00a0System.Byte[]\u00a0Data\n{\n\u00a0\u00a0\u00a0\u00a0get\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.Byte[]\u00a0TempData;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.IO.MemoryStream\u00a0TempStream\u00a0=\u00a0new\u00a0System.IO.MemoryStream();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Img.Save(TempStream,\u00a0System.Drawing.Imaging.ImageFormat.Png);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TempData\u00a0=\u00a0TempStream.ToArray();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TempStream.Close();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0TempData;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0set\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.IO.MemoryStream\u00a0TempStream\u00a0=\u00a0new\u00a0System.IO.MemoryStream(value);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Img\u00a0=\u00a0System.Drawing.Image.FromStream(TempStream);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TempStream.Close();\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre>"},{"location":"System-Software/Formats/GPD/#title-entries","title":"Title Entries","text":"<p>These entries are only located in the FFFE07D1 gpd. To get to them, the id for the XDBF entry is the title ID of the game, and the XDBF entry type is String. For more information see XDBF</p> Offset Length Type Information 0x0 0x4 unsigned int Title ID 0x4 0x4 signed int Achievement Count 0x8 0x4 signed int Achievement Unlocked Count 0xC 0x4 signed int Gamerscore Total 0x10 0x4 signed int Gamerscore Unlocked 0x14 0x1 unsigned byte Unknown 0x15 0x1 unsigned byte Achievement Unlocked Online Count 0x16 0x01 byte Avatar Assets Earned 0x17 0x01 byte Avatar Assets Max 0x18 0x01 byte Male Avatar Assets Earned 0x19 0x01 byte Male Avatar Assets Max 0x1A 0x01 byte Female Avatar Assets Earned 0x1B 0x01 byte Female Avatar Assets Max 0x1C 0x4 unsigned int Flags (see below) 0x20 0x8 signed long Last Played Time 0x28 null terminated unicode string Title Name <p>These are not all the flags, it's just that I don't know the rest.</p> Value Description 0x1 Achievement Unlocked Offline, needs to be synced. 0x2 Achievement Unlocked, image needs to be downloaded. 0x10 Avatar Award Unlocked, needs to be downloaded. 0x20 ? <p>Title images are also available online:</p> <pre><code>// IconURL\n\"http://image.xboxlive.com/global/t.\" + ID.ToString(\"x8\") +\n\"/icon/0/8000\"\n\n// LargeBoxArtURL\n\"http://tiles.xbox.com/consoleAssets/\" + ID.ToString(\"x8\") +\n\"/en-GB/largeboxart.jpg\"\n\n// SmallBoxArtURL\n\"http://tiles.xbox.com/consoleAssets/\" + ID.ToString(\"x8\") +\n\"/en-GB/smallboxart.jpg\"\n\n// BannerURL\n\"http://avatar.xboxlive.com/global/t.\" + ID.ToString(\"x8\") +\n\"/marketplace/0/1\"\n\n// MarketplaceURL\n\"http://marketplace.xbox.com/en-US/Title/\" + ID\n</code></pre>"},{"location":"System-Software/Formats/GPD/#avatar-award-entries","title":"Avatar Award Entries","text":"<p>The entries are only supported within the PEC version of the GPD. The images for the avatar awards, are stored in the game GPD for that game.</p> Offset Length Type Information 0 4 int32 Struct size (0x2C) 4 16 System.Guid ID 20 4 UInt32 ImageID 24 4 UInt32 Flags(Same as achievement) 28 8 filetime Unlock Time 36 4 Int32 Subcategory 40 4 UInt32 Unknown 44 Null Terminated Unicode Name 44 + Name length Null Terminated Unicode Unlocked Description 44 + Name length + Locked Description length Null Terminated Unicode Locked Description"},{"location":"System-Software/Formats/GPD/#image","title":"Image","text":"<p>The Image stored in the GPD is stored in the normal GPD however you can grab the image from the server, using the GUID.</p> <pre><code>\"http://download.xboxlive.com/content/4d530914/thumbnails/\" + size +\n    \"/\" + ID.ToString() + \".png\"); // size 64 128 300\n\"http://avatar.xboxlive.com/global/t.\" + TitleID + \"/avataritem/\" +\n    ID.ToString() + \"/\" + size // 64 or 128\n</code></pre>"},{"location":"System-Software/Formats/GPD/#string-entries","title":"String Entries","text":"<p>String entries are simply a unicode, null terminated string the length could be derived from the entry length.</p>"},{"location":"System-Software/Formats/GPD/#sync-lists","title":"Sync Lists","text":"<p>This is a list of \"Sync Items\".</p> <p>You can find the total sync items by,</p> <p>((SyncList.Length / 16) - 1)</p>"},{"location":"System-Software/Formats/GPD/#sync-item","title":"Sync Item","text":"Offset Length Type Information 0 8 unsigned long EntryID 8 8 unsigned long SyncID"},{"location":"System-Software/Formats/GPD/#sync-data","title":"Sync Data","text":"Offset Length Type Information 0x0 0x8 unsigned long Next Sync ID 0x8 0x8 unsigned long Last Synced ID 0x10 0x8 signed long Last Synced Time <p>IDs in Sync List between last and next are pushed //confirm?</p> <p>System Software</p>"},{"location":"System-Software/Formats/PEC/","title":"PEC","text":"<p>PEC (Profile Embedded Content) files are used by the Xbox 360 as an additional layer of security on profiles. Certain GPD files are relocated inside the PEC file. The PEC file stores information on avatar clothes/items, and is just another STFS package. With this said you must properly rehash and resign the PEC file to avoid the Xbox detecting corruption of the package. Rehashing is the same as all STFS packages (besides the starting block), but resigning is different (view below).</p>"},{"location":"System-Software/Formats/PEC/#header","title":"Header","text":"Offset Length Type Information 0x0 0x228 [[Console_Security_Certificate Console Security Certificate]] 0x228 0x14 bytes SHA1 hash from 0x23C-0x1000 0x23C 0x8 signed long Unknown 0x244 0x24 [[STFS#Volume_Descriptor Structure]] 0x268 0x4 signed int Unknown 0x26C 0x8 bytes Profile ID 0x274 0x1 byte Unknown 0x275 0x5 bytes Console ID"},{"location":"System-Software/Formats/PEC/#notes","title":"Notes","text":"<p>The Console ID at 0x275 must match the Console ID located in the Console Security Certificate, otherwise the Xbox 360 will see it as a corrupted file.</p> <p>The signature located in the Console Security Certificate is signed using the hash at location 0x228. (SHA1 hash from 0x23C - 0x1000)</p> <p>From 0x1000 the rest of the file is the standard block portion of STFS, with data block 0 starting at 0x3000, and hash table 0 at 0x1000/0x2000. The PEC file always has 2 hash tables (type 1 package).</p> <p>System Software</p>"},{"location":"System-Software/Formats/SPA/","title":"SPA","text":"<p>SPA files are contained inside XEX files or within Updates or DLC. They are just a XDBF file, they are used by the dashboard for GPD creation and Xbox LIVE information.</p>"},{"location":"System-Software/Formats/SPA/#record-table","title":"Record Table","text":""},{"location":"System-Software/Formats/SPA/#record-namespaces","title":"Record Namespaces","text":"Value Description 1 Metadata 2 Images 3 String Tables"},{"location":"System-Software/Formats/SPA/#record-structures","title":"Record Structures","text":""},{"location":"System-Software/Formats/SPA/#metadata","title":"Metadata","text":"<p>Each record here is set out differently depending on there magic.</p>"},{"location":"System-Software/Formats/SPA/#xach","title":"XACH","text":"<p>This is just a table of Achievements.</p> Offset Length Type Information 0 4 string Magic (XACH) 0x4 0x4 unsigned int Structure Version 0x8 0x4 unsigned int Structure Size (- Magic) 0xC 0x2 unsigned short Achievement Count 0xE Achievement Count * 36 (0x24) achievement structure (see below) Achievements"},{"location":"System-Software/Formats/SPA/#achievement-structure","title":"Achievement Structure","text":"Offset Length Type Information 0x0 0x2 unsigned short Achievement ID 0x2 0x2 unsigned short Title String ID 0x4 0x2 unsigned short Unlocked Description ID 0x6 0x2 unsigned short Locked Description ID 0x8 0x4 unsigned int Image ID 0xC 0x2 unsigned short Gamerscore 0xE 0x2 unsigned short Unused 0x10 0x4 unsigned int Flags 0x14 0x4 unsigned int Unused 0x18 0x4 unsigned int Unused 0x1C 0x4 unsigned int Unused 0x20 0x4 unsigned int Unused"},{"location":"System-Software/Formats/SPA/#xcxt","title":"XCXT","text":"<p>TODO: what this stores</p> Offset Length Type Information 0 4 string Magic (XCXT) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Record Count 16 Record Count * 16 Record structure (see below) Records"},{"location":"System-Software/Formats/SPA/#record-structure","title":"Record Structure","text":"Offset Length Type Information 0 4 UInt32 Unknown 4 4 UInt32 Unknown 8 4 UInt32 Unknown 12 4 UInt32 Unknown <p>TODO: Unknown</p>"},{"location":"System-Software/Formats/SPA/#xitb","title":"XITB","text":"<p>This record just stores the ImagePath + ID's.</p> Offset Length Type Information 0 4 string Magic (XITB) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Image Count 16 Image Count * 16 Image structure (see below) Images"},{"location":"System-Software/Formats/SPA/#image-structure","title":"Image Structure","text":"Offset Length Type Information 0 4 UInt32 ImageID 4 4 UInt32 Name Length 8 Name Length String Image Path"},{"location":"System-Software/Formats/SPA/#xmat","title":"XMAT","text":"<p>TODO: What this stores</p> Offset Length Type Information 0 4 string Magic (XMAT) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 Structure Size - 8 Byte[] Unknown <p>TODO: Unknown</p>"},{"location":"System-Software/Formats/SPA/#xpbm","title":"XPBM","text":"<p>TODO: What this stores</p> Offset Length Type Information 0 4 string Magic (XPBM) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 Structure Size - 8 Byte[] Unknown <p>TODO: Unknown</p>"},{"location":"System-Software/Formats/SPA/#xprp","title":"XPRP","text":"<p>TODO: what this stores</p> Offset Length Type Information 0 4 string Magic (XPRP) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Record Count 16 Record Count * 8 Record structure (see below) Records"},{"location":"System-Software/Formats/SPA/#record-structure_1","title":"Record Structure","text":"Offset Length Type Information 0 8 Byte[] Unknown <p>TODO: Unknown, (2 int32's?)</p>"},{"location":"System-Software/Formats/SPA/#xrpt","title":"XRPT","text":"<p>This record just stores a series of XPMB files.</p> Offset Length Type Information 0 4 string Magic (XRPT) 4 4 UInt32 Version 8 4 UInt32 Structure Size 12 XPMB XPBM 2 UInt16 XPBM Count XPBM[XPBM Count] Sub XPBMs"},{"location":"System-Software/Formats/SPA/#xsrc","title":"XSRC","text":"<p>This file is something todo with xlast, (a source file?)</p> Offset Length Type Information 0 4 string Magic (XSRC) 4 4 UInt32 Version 8 4 UInt32 Structure Size 12 4 UInt32 NameLength 16 NameLength String (original?)filename 16 + NameLength Structure Size - 8 Byte[] Unknown(compressed?) <p>TODO:Unknown</p>"},{"location":"System-Software/Formats/SPA/#xstc","title":"XSTC","text":"<p>TODO: What this stores</p> Offset Length Type Information 0 4 string Magic (XSTC) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Unknown <p>TODO: Unknown</p>"},{"location":"System-Software/Formats/SPA/#xthd","title":"XTHD","text":"Offset Length Type Information 0 4 unsigned int Magic (XTHD) 0x4 0x4 unsigned int Structure Version 0x8 0x4 unsigned int Structure Size 0xC 0x4 unsigned int Title ID 0x10 0x4 unsigned int Title Type (0 = system, 1 = full, 2 = demo, 3 = download) 0x14 0x2 unsigned short Project Version Major 0x16 0x2 unsigned short Project Version Minor 0x18 0x2 unsigned short Project Version Build 0x1A 0x2 unsigned short Project Version Revision 0x1C 0x4 unsigned int Unused 0x20 0x4 unsigned int Unused 0x24 0x4 unsigned int Unused 0x28 0x4 unsigned int Unused <p>Is StructureSize null for anyone else? only in this record.</p>"},{"location":"System-Software/Formats/SPA/#xvc2","title":"XVC2","text":"<p>This record just stores a series of XPBM files, and (TODO:Unknown).</p> Offset Length Type Information 0 4 string Magic (XVC2) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 2 UInt16 XPBM Count 14 204 Byte[] Unknown 208 XPBM[] XPBM's <p>TODO: Unknown</p>"},{"location":"System-Software/Formats/SPA/#images","title":"Images","text":"<p>Image entries are composed of a PNG image.</p>"},{"location":"System-Software/Formats/SPA/#string-tables","title":"String Tables","text":""},{"location":"System-Software/Formats/SPA/#xstr","title":"XSTR","text":"<p>All these records are set out the same however some have a unknown byte[] after the string.</p> Offset Length Type Information 0 4 string Magic (XSTR) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt16 String Count 16 String structure (see below) Strings"},{"location":"System-Software/Formats/SPA/#string-structure","title":"String Structure","text":"Offset Length Type Information 0 2 UInt16 String ID 2 2 UInt16 String Length 4 String Length String String <p>System Software</p>"},{"location":"System-Software/Formats/STFS/","title":"STFS","text":"<p>STFS (Secure Transacted File System) is the file system used by the Xbox 360 for all packages created and downloaded by the system. It is protected using a series of SHA1 hashes and a RSA signature. STFS is commonly found in Xbox 360 Content Packages (XContent), but is not limited to those only as the PEC (Profile Embedded Content) files employ STFS. The two known categories for STFS are read-only and writeable. Read-only content packages are found with a PIRS/LIVE signed header and writeable content packages are console signed (CON).</p> <p>The 360 uses packages to transfer saves/content/games/pictures and more. Most packages start with the strings PIRS, LIVE or \"CON \", some are even embedded inside gamer profiles (using the PEC format described below). All of these are STFS content packages which hold the real files along with metadata that the dashboard reads like the title, the licenses and the RSA signature which is used to verify the package.</p> <p>The acronym STFS stands for Secure Transacted File System, which shows how the packages are secure (signature and hashes) and transacted (multiple file / directory revisions)</p> <p>LIVE and PIRS files come from Xbox Live, these are signed using a private key that only Microsoft has. The console uses a public key which is hardcoded inside it to verify the package and make sure the person is allowed to use it. CON files are created by the console for saves and profiles. The console uses its own private key to sign CON files. Many editors are available for saves and profiles which can be used with no modification to the console.</p> <p>Throughout an STFS package, there is a series of SHA1 hashes used to verify the package, and help with downloads (if a block isn't valid, it can be redownloaded). The hashes are located at certain parts of the file, a way of calculating where is (will be!) down below.</p>"},{"location":"System-Software/Formats/STFS/#volume-descriptor","title":"Volume Descriptor","text":"<p>There are 2 types of volume descriptor a content file may have, one for STFS packages and another for SVOD</p>"},{"location":"System-Software/Formats/STFS/#stfs_1","title":"STFS","text":"Offset Length Type Information 0x00 0x01 byte Volume descriptor size (0x24) 0x01 0x01 byte Reserved 0x02 0x01 byte Block Seperation 0x03 0x02 signed short File Table Block Count 0x05 0x03 signed int24 File Table Block Number 0x08 0x14 byte[] Top Hash Table Hash 0x1C 0x04 signed int Total Allocated Block Count 0x20 0x04 signed int Total Unallocated Block Count"},{"location":"System-Software/Formats/STFS/#svod","title":"SVOD","text":"Offset Length Type Information 0x00 0x01 byte Volume descriptor size (0x24) 0x01 0x01 byte Block Cache Element Count 0x02 0x01 byte Worker Thread Processor 0x03 0x01 byte Worker Thread Priority 0x04 0x14 byte[] Hash 0x18 0x01 byte Device features 0x19 0x03 uint24 Data block count 0x1C 0x03 uint24 Data block offset 0x1F 0x05 byte[] Padding/reserved"},{"location":"System-Software/Formats/STFS/#content-packages","title":"Content Packages","text":""},{"location":"System-Software/Formats/STFS/#header","title":"Header","text":"Offset Length Type Information 0x0 0x4 ascii string Magic"},{"location":"System-Software/Formats/STFS/#magic","title":"Magic","text":"<p>The magic can be one of the following:</p> Signature Type Information \"CON \" Signed by a console. Found on many files such as cache files, profiles, saved games. PIRS Signed by Microsoft. Found on files delivered by Microsoft through non-Xbox Live means such as system updates. LIVE Signed by Microsoft. Found on files delivered over Xbox Live such as items from the Marketplace like themes."},{"location":"System-Software/Formats/STFS/#signatures","title":"Signatures","text":""},{"location":"System-Software/Formats/STFS/#con","title":"CON","text":"<p>The following is used for Console Signed (\"CON \") packages, and is used by the Xbox as the format for signatures generated by it:</p> Offset Length Type Information 0x004 0x2 byte[] Public Key Certificate Size 0x006 0x5 byte[] Certificate Owner Console ID 0x00B 0x14 ascii string Certificate Owner Console Part Number 0x01F 0x1 byte Certificate Owner Console Type (1 for devkit, 2 for retail) 0x020 0x8 ascii string Certificate Date of Generation 0x028 0x4 byte[] Public Exponent 0x02C 0x80 byte[] Public Modulus 0x0AC 0x100 byte[] Certificate Signature 0x1AC 0x80 byte[] Signature"},{"location":"System-Software/Formats/STFS/#live-pirs","title":"LIVE / PIRS","text":"<p>and for remotely signed (LIVE/PIRS) packages:</p> Offset Length Type Information 0x004 0x100 byte[] Package Signature 0x104 0x128 byte[] Padding <p>The Package Signature is generated using the value at 0x32C (Content ID/Header SHA1).</p>"},{"location":"System-Software/Formats/STFS/#metadata","title":"Metadata","text":"<p>If the Metadata Version field is set to 2, the format is slightly changed.</p>"},{"location":"System-Software/Formats/STFS/#version-1","title":"Version 1","text":"Offset Length Type Information 0x022C 0x100 license entries (see below) Licensing Data (used to check package owner) 0x032C 0x14 byte[] Header SHA1 Hash (from 0x344 to first hash table) 0x0340 0x4 int HeaderSize 0x0344 0x4 signed int Content Type (see below) 0x0348 0x4 signed int Metadata Version (see below) 0x034C 0x8 signed long Content Size 0x0354 0x4 int Media ID 0x0358 0x4 signed int Version (system/title updates) 0x035C 0x4 signed int Base Version (system/title updates) 0x0360 0x4 int Title ID 0x0364 0x1 byte Platform (Xbox 360 = 2/PC = 4) 0x0365 0x1 byte Executable Type 0x0366 0x1 byte Disc Number 0x0367 0x1 byte Disc In Set 0x0368 0x4 int Save Game ID 0x036C 0x5 byte[] Console ID 0x0371 0x8 byte[] Profile ID 0x0379 0x24 Volume Descriptor Volume Descriptor 0x039D 0x4 signed int Data File Count 0x03A1 0x8 signed long Data File Combined Size 0x03A9 0x4 int (STFS = 0, SVOD = 1) Descriptor type 0x03AD 0x4 int Reserved 0x03B1 0x4C byte[] Padding 0x03FD 0x14 bytes Device ID 0x0411 0x900 (each 0x80 = different locale) UTF-8 string Display Name 0x0D11 0x900 (each 0x80 = different locale) UTF-8 string Display Description 0x1611 0x80 UTF-8 string Publisher Name 0x1691 0x80 UTF-8 string Title Name 0x1711 0x1 byte Transfer Flags (see below) 0x1712 0x4 signed int Thumbnail Image Size 0x1716 0x4 signed int Title Thumbnail Image Size 0x171A 0x4000 (thumbnail size) image  Thumbnail Image 0x571A 0x4000 (title thumbnail size) image  Title Thumbnail Image"},{"location":"System-Software/Formats/STFS/#version-2","title":"Version 2","text":"Offset Length Type Information 0x03B1 0x10 byte[] Series ID 0x03C1 0x10 byte[] Season ID 0x03D1 0x2 signed short Season Number 0x03D3 0x2 signed short Episode Number 0x03D5 0x28 byte[] Padding 0x171A 0x3D00 (thumbnail size) image Thumbnail Image 0x541A 0x300 (each 0x80 = different locale) image Additional Display Names 0x571A 0x3D00 (title thumbnail size) image Title Thumbnail Image 0x941A 0x300 (each 0x80 = different locale) image Additional Display Descriptions"},{"location":"System-Software/Formats/STFS/#license-entries","title":"License Entries","text":"<p>For every entry in the license data field:</p> Offset Length Type Information 0x0 0x8 signed long License ID (XUID / PUID / console id) 0x8 0x4 signed int License Bits 0xC 0x4 signed int License Flags"},{"location":"System-Software/Formats/STFS/#content-types","title":"Content Types","text":"Value Description 0x0000001 Saved Game 0x0000002 Marketplace Content 0x0000003 Publisher 0x0001000 Xbox 360 Title 0x0002000 IPTV Pause Buffer 0x0004000 Installed Game 0x0005000 Xbox Original Game 0x0005000 Xbox Title 0x0007000 Game on Demand 0x0009000 Avatar Item 0x0010000 Profile 0x0020000 Gamer Picture 0x0030000 Theme 0x0040000 Cache File 0x0050000 Storage Download 0x0060000 Xbox Saved Game 0x0070000 Xbox Download 0x0080000 Game Demo 0x0090000 Video 0x00A0000 Game Title 0x00B0000 Installer 0x00C0000 Game Trailer 0x00D0000 Arcade Title 0x00E0000 XNA 0x00F0000 License Store 0x0100000 Movie 0x0200000 TV 0x0300000 Music Video 0x0400000 Game Video 0x0500000 Podcast Video 0x0600000 Viral Video 0x2000000 Community Game"},{"location":"System-Software/Formats/STFS/#transfer-flags","title":"Transfer Flags","text":"<p>These are bit flags, don't treat them as an enum!</p> Bit # Flag Value Description 0 0b00000001 None  1 0b00000010 None 2 0b00000100 Deep Link Supported 3 0b00001000 Disable Network Storage 4 0b00010000 Kinect Enabled 5 0b00100000 Move-Only Transfer 6 0b01000000 Device ID Transfer 7 0b10000000 Profile ID Transfer"},{"location":"System-Software/Formats/STFS/#profile-embedded-content-pec","title":"Profile Embedded Content (PEC)","text":"<p>When extra security is needed for content which is already using STFS, PEC files may be used to add an extra layer on top. PEC files use the STFS descriptor and algorithms, but has no similarity with content packages.</p> <p>PEC files are only currently used for avatar items/clothing.</p> <p>Block 0 starts at 0x3000, and hash table 0 at 0x1000/0x2000.</p>"},{"location":"System-Software/Formats/STFS/#header_1","title":"Header","text":"Offset Length Type Information 0x000 0x228 Console_Security_Certificate Console Security Certificate 0x228 0x14 bytes SHA1 hash from 0x23C-0x1000 0x23C 0x8 signed long Unknown 0x244 0x24 Volume Descriptor Volume Descriptor (STFS) 0x268 0x4 signed int Unknown 0x26C 0x8 bytes Profile ID 0x274 0x1 byte Unknown 0x275 0x5 bytes Console ID"},{"location":"System-Software/Formats/STFS/#file-listing","title":"File Listing","text":"<p>The value at 0x37E (File Table Block Number on the structure above) determines where the file table begins. As it is a block number, you will have to convert it to an offset. Here is some code in C# for converting:</p> <pre><code>internal int BlockToOffset(int xBlock)\n{\n    int xReturn = 0;\n    if (xBlock &gt; 0xFFFFFF)\n        xReturn = -1;\n    else\n        xReturn = (((MetaData.HeaderSize + 0xFFF) &amp; 0xF000) + (xBlock &lt;&lt; 12));\n    return xReturn;\n}\ninternal int ComputeDataBlockNumber(int xBlock)\n{\n    int xBlockShift;\n    if (((MetaData.HeaderSize + 0xFFF) &amp; 0xF000) == 0xB000)\n        xBlockShift = 1;\n    else\n    if ((MetaData.Descriptor.BlockSeperation &amp; 1) == 1)\n        xBlockShift = 0;\n    else\n        xBlockShift = 1;\n\n    int xBase = ((xBlock + 0xAA) / 0xAA);\n    if (this.Header.Magic == XContent_Header.Header_Magic.CON)\n        xBase = (xBase &lt;&lt; xBlockShift);\n    int xReturn = (xBase + xBlock);\n\n    if (xBlock &gt; 0xAA)\n    {\n        xBase = ((xBlock + 0x70E4) / 0x70E4);\n        if (this.Header.Magic == XContent_Header.Header_Magic.CON)\n            xBase = (xBase &lt;&lt; xBlockShift);\n        xReturn += xBase;\n\n        if (xBlock &gt; 0x70E4)\n        {\n            xBase = ((xBlock + 0x4AF768) / 0x4AF768);\n            if (this.Header.Magic == xBlockShift)\n                xBase = (xBase &lt;&lt; 1);\n\n            xReturn = (xReturn + xBase);\n        }\n    }\n\n    return xReturn;\n}\n</code></pre> <p>Each embedded file starts at a 4096 byte boundary. The optional space between embedded files is filled with null bytes.</p> <p>The file listing consists of entries which have the format below. The listing ends with an entry consisting of only null bytes.</p> Offset Length Type Information 0x0 0x28 ASCII string File name, null-padded 0x28 0x1 byte Length of file name, plus flags 0x29 0x3 signed int24 Number of blocks allocated for file (little endian) 0x2C 0x3 signed int24 Copy of 0x29 0x2F 0x3 signed int24 Starting block number of file (little endian) 0x32 0x2 signed short Path indicator (big endian) 0x34 0x4 int32 Size of file in bytes (big endian) 0x38 0x4 signed int32 Update date/time stamp of file 0x3C 0x4 signed int32 Access date/time stamp of file <p>Byte 0x28 also has two flags: bit 6 and bit 7. If bit 6 is set it means that all of the blocks in the file are consecutive. Bit 7 indicates that the file is a directory. The first 6 bits 0-5, are the length of the filename.</p> <pre><code>public System.Boolean IsDirectory//bit 7\n{\n    get\n    {\n        return (Flags &amp; 128) == 128;\n    }\n    set\n    {\n        if (value != IsDirectory)\n        {\n            Flags ^= 128;\n        }\n    }\n}\n//public System.Boolean IsUnknown//bit 6\n//{\n//    get\n//    {\n//        return (Flags &amp; 64) == 64;\n//    }\n//    set\n//    {\n//        if (value != IsUnknown)\n//        {\n//            Flags ^= 64;\n//        }\n//    }\n//}\npublic System.Byte NameLength//first 6 bits\n{\n    get\n    {\n        return (System.Byte)(Flags &amp; 63);\n    }\n    set\n    {\n        Flags ^= (System.Byte)(value ^ NameLength);\n    }\n}\n</code></pre> <p>The path indicator indicates the path of the file. -1 (0xFFFF) means that the file is in the root directory, any other value V refers to the (sub)directory which is listed as the Vth entry in the listing (counting from 0). Directories can nest.</p> <p>The FAT format is used for the date/time stamps of the files.</p>"},{"location":"System-Software/Formats/STFS/#hash-tables-block-offsets","title":"Hash Tables / Block Offsets","text":"<p>A block is 0x1000 (4096) bytes and the first block is located at 0xC000. Every 0xAA (170) blocks there is a block that contains a hash of each block and every 0xAA*0xAA (0x70E4) blocks there is another table (presumably hashing the 0xAA table blocks). This means that when using a block number from a file listing you need to account for the hash tables which are not included in the block numbering system. For example block 171 is actually located where you would expect block 172 to reside ((171 + int(171/170)) * 0x1000 + 0xC000).</p> Offset Length Type Information 0x0 0x14 byte Hash(SHA1) 0x14 0x1 byte Status byte 0x15 0x3 int24 Next block <p>The status byte is very important when injecting files into a package. Here are the meanings of them.</p> Value Meaning 0x00 Unused Block 0x40 Free Block (previously used) 0x80 Used Block 0x80 Used Block 0xC0 Newly Allocated Block <p>Files are not always stored in consecutive blocks, you have to find the corresponding hash table record and read the next block number (similar to cluster maps in FAT).</p> <p>Here is some C# code for converting a block to it's hash table position(it may not work perfectly!):</p> <pre><code>internal int ComputeLevelNHashBlockNumber(int xBlock, int xLevel)\n{\n    int xBlockShift;\n    if (((MetaData.HeaderSize + 0xFFF) &amp; 0xF000) == 0xB000)\n        xBlockShift = 1;\n    else\n    if ((MetaData.Descriptor.BlockSeperation &amp; 1) == 1)\n        xBlockShift = 0;\n    else\n        xBlockShift = 1;\n    int[] xBlockStep;\n    if (((MetaData.HeaderSize + 0xFFF) &amp; 0xF000) == 0xB000)\n        xBlockStep = new[] { 0xAC, 0x723A };\n    else\n    if ((MetaData.Descriptor.BlockSeperation &amp; 1) == 1)\n        xBlockStep = new[] { 0xAB, 0x718F };\n    else\n        xBlockStep = new[] { 0xAC, 0x723A };\n\n    int xReturn;\n    int xBase;\n    int xStep = xBlockStep[1];\n\n    if (xLevel == 0)\n    {\n        xReturn = (xBlock / 0xAA);\n        xStep = (xReturn * xBlockStep[0]);\n        if (xReturn != 0)\n        {\n            xReturn = (xBlock / 0x70E4);\n            xBase = (xReturn + 1);\n\n            if (this.Header.Magic == XContent_Header.Header_Magic.CON)\n                xStep += (xBase &lt;&lt; xBlockShift);\n            else\n                xStep += xBase;\n\n            if (xReturn == 0)\n                return xStep;\n            else\n            {\n                if (this.Header.Magic == XContent_Header.Header_Magic.CON)\n                    return (xStep + (1 &lt;&lt; xBlockShift));\n                else\n                    return (xStep + 1);\n            }\n        }\n        else\n            return xStep;\n    }\n    else if (xLevel == 1)\n    {\n        xReturn = (xBlock / 0x70E4);\n        xBase = (xReturn * xStep);\n        if (xReturn != 0)\n        {\n            if (this.Header.Magic == XContent_Header.Header_Magic.CON)\n                return (xBase + (1 &lt;&lt; xBlockShift));\n            else\n                return (xBase + 1);\n        }\n        else\n            return (xBase + xBlockStep[0]);\n    }\n    else if (xLevel == 2)\n    {\n        return xStep;\n    }\n    else\n    {\n        throw new Exception(\"Level\u00a0Unknown:\u00a0\" + xLevel.ToString());\n        return 0xFFFFFF;\n    }\n}\n</code></pre>"},{"location":"System-Software/Formats/STFS/#tools","title":"Tools","text":"<ul> <li>Velocity can create, open, view and extract most STFS files, and other Xbox and Xbox 360 files.</li> <li>extract360.py is an (old) tool (Python 2.5 required) to analyze and extract these archive files.</li> <li>py360 can read STFS files</li> <li>wxPirs 1.1 can extract from LIVE/PIRS files fine, but as it doesn't use hash tables properly it doesn't work well with CON files.</li> <li>A newer tool was released by DJ Shepherd called Le Fluffie, which can create and extract from CON/LIVE/PIRS files (but it has some   problems with creation, some prefer to use XLAST)</li> <li>XLAST inside the Xbox 360 SDK can create LIVE/PIRS packages, but it is illegal to share it.</li> </ul> <p>System Software</p>"},{"location":"System-Software/Formats/XCP/","title":"Xbox Content Package (XCP)","text":"<p>It's been found that Xbox 360 Marketplace downloads files with the extension .xcp over unencrypted http on port 3074 for content distribution.</p> <ul> <li>XCP stands for Xbox Content Package (from     Xbox Scene Forum Thread)</li> <li>XCP files are (in-order) encrypted and compressed (with zlib). Underneath, they are STFS containers.<ul> <li>XCP files from some categories (\"Full Game Demos\" being one of them) are not encrypted</li> </ul> </li> <li>It may be possible to use the avatar downloads to glean more info     about the file format.</li> <li>The communication is pure http and you can redirect traffic to a     local webserver, however it does checksum the file</li> <li>Content downloaded with licenses are locked to a 360 at purchase<ul> <li>Box A downloads trial</li> <li>Box B can run the same downloaded trial</li> <li>Box A upgrades trial to full</li> <li>Box B can only run in trial mode (if available)</li> </ul> </li> <li>Content is downloaded and extracted into place</li> <li>When upgrading to full license the 360 dials home and then some     modification is made to lock content to the particular box</li> </ul>"},{"location":"System-Software/Formats/XCP/#first-generation-xbox","title":"First Generation Xbox","text":"<p>xcp files are not new to the Xbox 360.</p> <ul> <li>Are encrypted Cabinet files</li> <li>Encrypted with a public and symmetric key.</li> <li>Keys needed for extraction.</li> <li>Need tools to create our own without the Xbox SDK</li> </ul> <p>System Software Category: Pages That Need Updates</p>"},{"location":"System-Software/Formats/XDBF/","title":"XDBF","text":"<p>XDBF (Xbox Data Base File) files are used by the Xbox 360 as a generic database. It is used as the format for GPD (Gamer Profile Data) and SPA (Statistics, Presence and Achievements) files. SPA files are linked into an Xbox 360 executable during compilation and are used by the dashboard to generate the GPD, Save Game (STFS) Meta-Data and Images. In the XAM the DataFile class handles all of the operations associated with these files.</p>"},{"location":"System-Software/Formats/XDBF/#header","title":"Header","text":"<p>Total length: 24 bytes (0x18)</p> <p>Byte ordering: Dependant on magic. If the magic is little endian then the whole file is and is a GFWL, if it's big endian then it's an Xbox file.</p> Offset Length Type Information 0x0 0x4 ascii string Magic (0x58444246) 0x4 0x4 unsigned int Version (0x10000) 0x8 0x4 unsigned int Entry Table Length (in number of entries) 0xC 0x4 unsigned int Entry Count 0x10 0x4 unsigned int Free Space Table Length (in number of entries) 0x14 0x4 unsigned int Free Space Table Entry Count <p>Entry Table Length and Free Space Table Length will be a multiple of 512, this is just Xbox's preferred values, but it will read the file if you decrease them to make the size of the file smaller, alot smaller.</p>"},{"location":"System-Software/Formats/XDBF/#entry-table","title":"Entry Table","text":"<p>The Entry Table is made up of entries, each one under a different namespace and ID. The table length will be Entry Table Length * 18, but only the first Entry Count are used.</p>"},{"location":"System-Software/Formats/XDBF/#entry-structure","title":"Entry Structure","text":"<p>Total length: 18 bytes (0x12)</p> Offset Length Type Information 0x0 0x2 unsigned short Namespace (see [[GPD 0x2 0x8 unsigned long ID 0xA 0x4 unsigned int OffsetSpecifier 0xE 0x4 unsigned int Length"},{"location":"System-Software/Formats/XDBF/#free-space-table","title":"Free Space Table","text":"<p>The Free Space Table is used to map out the unused space within the file. It is updated whenever n entry changes size. Each entry within the Free Space Table is composed of the OffsetSpecifier and how much space is unused their (Length). The final entry in the Free Space Table isn't actually free space, but rather is information about the length of data after the tables. The OffsetSpecifier would be the length (file length - header and tables) and the Length would be -1 -OffsetSpecifier.</p>"},{"location":"System-Software/Formats/XDBF/#free-space-entry-structure","title":"Free Space Entry Structure","text":"<p>Total length: 8 bytes</p> Offset Length Type Information 0x0 0x4 unsigned int OffsetSpecifier 0x4 0x4 unsigned int Length"},{"location":"System-Software/Formats/XDBF/#entry-data-offset","title":"Entry Data Offset","text":"<p>To work out the real entry data offset, times the Entry Table Length by 0x12, then times the Free Space Table Length by 0x8 and add the result together, and add 0x18 (file header). This is where the beginning of the entry data begins, then add the OffsetSpecifier by the entry to get the real offset.</p> <p>(((Entry Table Length * 18) + (Free Space Table Length * 8)) + 24) + OffsetSpecifier</p> <p>Just to explain a bit more,</p> <p>Entry Table Length * 18, 18 being the length of each entry, this will workout the actual length of the entry table.</p> <p>Free Space Table Length * 8, 8 being the length of each free space entry, workout the actual length of the free space table.</p> <p>+ 24, 24 is the length of the header.</p> <p>System Software</p>"},{"location":"System-Software/Formats/XEX/","title":"File Format Speculation","text":"<p>XEX is the executable file format used by the Xbox 360 operating system. It seems to be a crypto and packing container for PPC PE executable files, comparable to UPX or TEEE Burneye. It's likely the 360 knows how to grab the section it needs into memory and decrypt/decompress on demand, instead of traditional all at once extraction.</p>"},{"location":"System-Software/Formats/XEX/#cryptography","title":"Cryptography","text":"<p>The executable code seems to be crypted, though, there exists some uncrypted XEX files in the wild.</p> <p>The following program dumps what is supposed to be a hash table. Actually it has been reported to work with the first official \"Backward Compatibility\" .XEX File from Microsoft. It takes the XEX file as argument.</p> <pre><code>//\u00a0default.xex\u00a0table\u00a0dumper\n//\u00a0only\u00a0works\u00a0with\u00a0the\u00a0default.xex\u00a0from\u00a0the\u00a0xbox360\u00a0emulator\u00a0update\u00a0package.\n//\u00a0-\u00a0th0mas,\u00a0th0mas.sixbit.org@gmail.com\n\n#include\u00a0&lt;stdio.h&gt;\n#include\u00a0&lt;string.h&gt;\n\n#define\u00a0TABLE_START\u00a00x288\n\nstruct\u00a0table\u00a0{\n\u00a0\u00a0\u00a0unsigned\u00a0int\u00a0unknown[6];\n};\n\nunsigned\u00a0int\u00a0ByteSwap\u00a0(unsigned\u00a0int\u00a0nInt)\n{\n\u00a0\u00a0\u00a0union\u00a0u\u00a0{ unsigned\u00a0int\u00a0vi;\u00a0unsigned\u00a0char\u00a0c[sizeof(unsigned\u00a0int)]; };\n\u00a0\u00a0\u00a0union\u00a0v\u00a0{ unsigned\u00a0int\u00a0ni;\u00a0unsigned\u00a0char\u00a0d[sizeof(unsigned\u00a0int)]; };\n\u00a0\u00a0\u00a0union\u00a0u\u00a0un;\n\u00a0\u00a0\u00a0union\u00a0v\u00a0vn;\n\u00a0\u00a0\u00a0un.vi\u00a0=\u00a0nInt;\n\u00a0\u00a0\u00a0vn.d[0]=un.c[3];\n\u00a0\u00a0\u00a0vn.d[1]=un.c[2];\n\u00a0\u00a0\u00a0vn.d[2]=un.c[1];\n\u00a0\u00a0\u00a0vn.d[3]=un.c[0];\n\u00a0\u00a0\u00a0return\u00a0(vn.ni);`\n}\n\nvoid\u00a0printTable(struct\u00a0table\u00a0*t)\n{\n\u00a0\u00a0\u00a0int\u00a0i;\n\u00a0\u00a0\u00a0for\u00a0(i\u00a0=\u00a00;\u00a0i\u00a0&lt;\u00a06;\u00a0i++)\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int\u00a0j\u00a0=\u00a0ByteSwap(t-&gt;unknown[i]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printf(\"0x%08x\u00a0\",\u00a0j);\n\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0printf(\"\\n\");\n}\n\nint\u00a0main(int\u00a0argc,\u00a0char\u00a0**argv)\n{\n\u00a0\u00a0\u00a0FILE\u00a0*fp\u00a0=\u00a0fopen(argv[1],\u00a0\"rb\");\n\u00a0\u00a0\u00a0struct\u00a0table\u00a0tmp;\n\u00a0\u00a0\u00a0int\u00a0numEntries\u00a0=\u00a00;\n\u00a0\u00a0\u00a0int\u00a0i;\n\n\u00a0\u00a0\u00a0fseek(fp,\u00a0TABLE_START,\u00a0SEEK_SET);\n\u00a0\u00a0\u00a0fread(&amp;numEntries,\u00a0sizeof(unsigned\u00a0int),\u00a01,\u00a0fp);\n\u00a0\u00a0\u00a0numEntries\u00a0=\u00a0ByteSwap(numEntries);\n\u00a0\u00a0\u00a0for\u00a0(i\u00a0=\u00a00;\u00a0i\u00a0&lt;\u00a0numEntries;\u00a0i++)\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fread(&amp;tmp,\u00a0sizeof(struct\u00a0table),\u00a01,\u00a0fp);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printTable(&amp;tmp);\n\u00a0\u00a0\u00a0}\n}\n</code></pre>"},{"location":"System-Software/Formats/XEX/#structure-of-the-xex-file","title":"Structure of the XEX File","text":"<p>A XEX file is composed of the following:</p> <ul> <li>A 24 bytes XEX Header</li> <li>Variable-length program/section headers</li> <li>Program/Section content</li> </ul>"},{"location":"System-Software/Formats/XEX/#xex-header","title":"XEX Header","text":"<p>Total length: 24 bytes.</p> <p>Byte ordering: Big Endian.</p> Offset Length Type Information 0x0 0x4 ascii string \"XEX2\" magic 0x4 0x4 module flags (see below) Flags 0x8 0x4 unsigned int PE data offset 0xC 0x4 unsigned int Reserved 0x10 0x4 unsigned int Security Info Offset 0x14 0x4 unsigned int Optional Header Count <p>The Flags field is a bitfield, as shown below:</p> <p><code>bit\u00a00\u00a0-\u00a0Title\u00a0Module</code> <code>bit\u00a01\u00a0-\u00a0Exports\u00a0To\u00a0Title</code> <code>bit\u00a02\u00a0-\u00a0System\u00a0Debugger</code> <code>bit\u00a03\u00a0-\u00a0DLL\u00a0Module</code> <code>bit\u00a04\u00a0-\u00a0Module\u00a0Patch</code> <code>bit\u00a05\u00a0-\u00a0Patch\u00a0Full</code> <code>bit\u00a06\u00a0-\u00a0Patch\u00a0Delta</code> <code>bit\u00a07\u00a0-\u00a0User\u00a0Mode</code></p>"},{"location":"System-Software/Formats/XEX/#optional-headers","title":"Optional Headers","text":"<p>Following the XEX header is a list of the optional headers within the file. Use the Optional Header Count field to determine how many there are.</p> <p>Each Optional Header is composed of the following:</p> Offset Length Type Information 0x0 0x4 unsigned int Header ID (see below) 0x4 0x8 unsigned int Header Data / Offset to data (see below) <p>To handle the data you would first check to see what its size is, to do this you need to AND the Header ID by 0xFF.</p> <p>If ID &amp; 0xFF == 0x01 then the Header Data field is used to store the headers data, otherwise it's used to store the data's offset. if ID &amp; 0xFF == 0xFF then the Header's data will contain its size if ID &amp; 0xFF == (Anything else) the value of this is the size of the entry in number of DWORDS (times by 4 to get real size)</p>"},{"location":"System-Software/Formats/XEX/#header-ids","title":"Header IDs","text":"Value Description 0x2FF Resource Info 0x3FF Base File Format 0x405 Base Reference 0x5FF Delta Patch Descriptor 0x80FF Bounding Path 0x8105 Device ID 0x10001 Original Base Address 0x10100 Entry Point 0x10201 Image Base Address 0x103FF Import Libraries 0x18002 Checksum Timestamp 0x18102 Enabled For Callcap 0x18200 Enabled For Fastcap 0x183FF Original PE Name 0x200FF Static Libraries 0x20104 TLS Info 0x20200 Default Stack Size 0x20301 Default Filesystem Cache Size 0x20401 Default Heap Size 0x28002 Page Heap Size and Flags 0x30000 System Flags 0x40006 Execution ID 0x401FF Service ID List 0x40201 Title Workspace Size 0x40310 Game Ratings 0x40404 LAN Key 0x405FF Xbox 360 Logo 0x406FF Multidisc Media IDs 0x407FF Alternate Title IDs 0x40801 Additional Title Memory 0xE10402 Exports by Name"},{"location":"System-Software/Formats/XEX/#program-section-content","title":"Program / Section content","text":"<p>The program holds a PE file which is crypted/packed, usually starting at offset 0x2000 (described in the XEX header). It's possible to have this PE uncrypted/unpacked on debug XEX files. Section contents are encrypted with CBC AES, with the key changing for each file. It's probably derived from the RSA(?) block at the beginning and a \"secret\" public key in the box. Contents are compressed with microsoft's proprietary LDIC compression (hello, xbox1!).</p>"},{"location":"System-Software/Formats/XEX/#miscellaneous","title":"Miscellaneous","text":""},{"location":"System-Software/Formats/XEX/#strings-found-in-some-xex-files","title":"Strings found in some XEX Files","text":"<p>These appear to be important strings found in the update file</p> <ul> <li> <p>Directories?</p> <ul> <li>XAdu</li> <li>$UPDATES</li> <li>MEDIA</li> </ul> </li> <li> <p>\\Device\\CdRom0\\default.xex</p> </li> <li> <p>installupdate.exe</p> </li> <li> <p>The xboxkrnl is updated using the updates.</p> </li> <li> <p>xam.xex</p> </li> <li> <p>xboxkrnl.exe</p> </li> <li> <p>Library includes:</p> <ul> <li>XUIRNDR</li> <li>XAUD</li> <li>XGRAPHC</li> <li>XRTLLIB</li> <li>XAPILIB</li> <li>LIBCMT</li> <li>XBOXKRNL</li> <li>D3D9</li> <li>XUIRUN</li> <li>XUIRNDR</li> </ul> </li> </ul>"},{"location":"System-Software/Formats/XEX/#availability-of-xex-files","title":"Availability of XEX files","text":"<p>There are currently at least four XEX files freely available on the net:</p> <ul> <li> <p>Original Xbox Game Support November 2005 update found on http://www.xbox.com/en-US/games/backwardscompatibility.htm.</p> </li> <li> <p>Original Xbox Game Support December 2005 update found on http://www.xbox.com/en-US/games/backwardscompatibility.htm.</p> </li> <li> <p>Windows XP Media Center Edition Update Rollup 2 from http://www.xbox.com/en-US/pcsetup/alldownloads.htm. Use cabextract to extract the executable file, then do the same on mcrdinstaller/ehd.cab inside the archive. This cabinet file contains XboxMcx.xex.</p> </li> <li> <p>XBOX 360 HD DVD Update found on http://www.xbox.com/en-us/hardware/x/xbox360hddvdplayer/download.htm#disc</p> </li> </ul>"},{"location":"System-Software/Formats/XEX/#programs","title":"Programs","text":"<ul> <li>xextools     -- A library and tools for manipulating xex files (xexread     replacement).</li> <li>xexdump -- Dumps information     about xex files (perl)</li> <li>xexdump -- Dumps     information about xex files (windows)</li> </ul>"},{"location":"System-Software/Formats/XEX/#executable-format","title":"Executable Format","text":"<p>XEX files are the default executable format.</p> <pre><code>&lt;nowiki&gt;\nFile-offset Description\n0       \"XEX2\"\n0x4     (module flags?)\n0x10        File header offset\n0x14        Definition count (see below)\n0x18        Definition[]\n\nDefinition  Description\n0x2FF       Module Sections\n0x3FF\n0x5FF       Delta patch descriptor\n0x4004\n0x4104\n0x42FF\n0x80FF      Binding path(s)\n0x8105\n0x10001     Load Address\n0x10100     Entry Point\n0x10201     Base Address\n0x103FF     Import Libraries\n0x18002     Checksum[4], Filetime[4]\n0x18102     (something debug related)\n0x183FF     PE Name\n\n0x200FF     Static Libraries\n        UINT32 Total size\n        entries[total size / 0x10]\n0x20104     TLS\n        UINT32 Number of Slots\n        UINT32 Raw Data Address\n        UINT32 Data Size\n        UINT32 Raw Data Size\n0x20200     Get Stack Size\n0x20301     Cache Element Count\n0x30000\n0x40006     MediaID[4], Version[4], Baseversion[4], TitleID[4]\n0x40310     Game Ratings\n        UINT8 ESRB\n        UINT8 PEGI\n        UINT8 PEGI-FI\n        UINT8 PEGI-PT\n        UINT8 PEGI_BBFC\n        UINT8 CERO\n        UINT8 USK\n        UINT8 OFLCAU\n        UINT8 OFLCNZ\n        UINT8 KMRB\n        UINT8 BRASIL\n        UINT8 FPB\n\n0x40404     Lan Key (16 Bytes)\n0x406FF     Multidisc, accepted Media IDs\n0x40801\n\nFileHeaderOffset    Description\n0           HeaderSize[4]\n0x4         Image Size[4]\n0x8         RSA Signature\n0x10C           (resulting Image size?)[4]\n0x110           LoadAddress\n0x140           MediaID[16]\n0x150           (AES key seed?)[16]\n0x164           (Input to SHA)[0x14]\n0x178           Region[4]\n0x17C           SHA Hash[0x14]\n0x180           ImageDataCount[4]\n0x184...0x184+(IDC*24)  ImageData0[8], ImageData1[8], ImageData2[8]\n&lt;/nowiki&gt;\n</code></pre> <p>System Software</p>"},{"location":"System-Software/Systems/FATX/","title":"FATX - Filesystem","text":"<p>FATX is the file system used by the Xbox and the Xbox 360, it is unsupported natively by Windows but has some functionality in Linux. Sometimes called \"XTAF\" (due to its little endian header), the file system is derived from the age-old MS-DOS file system and can be considered as a cleaned-up version of it.</p> <p>Note that, while not part of the file system itself, the media which contain this file system do not have a master file table which describes which file system starts where. It is up to the consumer Xbox 360, geom_xbox360 kernel module to know this.</p>"},{"location":"System-Software/Systems/FATX/#file-system-layout","title":"File System Layout","text":"<p>The file system is divided into 4 parts:</p> <ul> <li>Header (the BOOT sector on FAT file systems)</li> <li>File allocation table (FAT)</li> <li>Root directory cluster/data region</li> </ul> <p>All multi-byte values contained in each part are 1 big-endian.</p>"},{"location":"System-Software/Systems/FATX/#difference-between-retail-and-development-kit-hdd","title":"Difference Between Retail and Development Kit HDD","text":"<p>The essential difference between retail and devkit HDDs is that devkit HDDs hold a partition table (length of 0x18 bytes) at the start of the drive. The table contains sector and length information for the Content and DEVKIT Partitions (possibly Compatibility partition too). This partition table only exists on Devkit HDDs, retails have the offsets built in to the kernel.</p>"},{"location":"System-Software/Systems/FATX/#usb-drive-layout","title":"USB Drive Layout","text":"<p>Unlike the hard disks and memory units that the Xbox 360 originally shipped with, the USB drives which can be Xbox 360-configured contain sets of files located in a hidden \"Xbox360\" folder located in the root of the device. The Data0000-Data0003 files are always present no matter what the device size. The Data0000 file houses the Cache/USB System Extended partitions, device performance information, and device geometry (mainly just the total device size). Data0001 contains the file allocation table for the Data partition, which uses the remaining files.</p> <p>There was some research done in hopes to remove the maximum device size of 16 GB (for Xbox 360 storage) on exploited/development consoles, but it was later discovered that anything a few GB larger than the current maximum causes the console to crash. http://www.xboxhacker.org/index.php?topic=16913.0</p>"},{"location":"System-Software/Systems/FATX/#configuration-file","title":"Configuration file","text":"<p>The configuration is the first 2 sectors (0x400 bytes) of the Data0000 and is created when the device is configured. It contains info about the device and is secured with a signature. The layout is as follows:</p>"},{"location":"System-Software/Systems/FATX/#type-1-certificate-size-0x228","title":"Type 1 (Certificate size = 0x228)","text":"Offset Length Description 0 0x1A8 Console Security Certificate 0x1A8 0x80 Signature (part of the console cert) 0x228 0x14 Device ID 0x23C 4 (UINT32) Certificate size (0x228) 0x240 8 (UINT64) Size of device in bytes 0x248 2 (UINT16) Read speed in KBs 0x24A 2 (UINT16) Write speed in KBs 0x24C 0x1B4 Padding (0x00)"},{"location":"System-Software/Systems/FATX/#type-2-certificate-size-0x100","title":"Type 2 (Certificate size = 0x100)","text":"Offset Length Description 0 0x100 Device Signature 0x100 0xA8 Padding (0x00) 0x228 0x14 Device ID 0x23C 4 (UINT32) Certificate size (0x100) 0x240 8 (UINT64) Size of device in bytes 0x248 2 (UINT16) Read speed in KBs 0x24A 2 (UINT16) Write speed in KBs 0x24C 0x1B4 Padding (0x00) <p>The signature is derived from a SHA1 hash taken from the start of the device id (0x228) till the end of the config (0x1D8 bytes) and is signed with the consoles private key and the matching public parameters are present in the console certificate for verification later on.</p> <p>The certificate size is used to determine how to verify the configuration file when the device is mounted. If the value is 0x228 then the device was configured by an Xbox and the signature is verified using the params in the console certificate, if the value is 0x100 then the device was pre-configured by Microsoft and is verified using the SATA public key (also used for HDDSS verification).</p> <p>The last 2 values are written when the device is configured, it is unknown how these are used later on. Perhaps it could be used to determine what connected device would provide best performance for caching.</p>"},{"location":"System-Software/Systems/FATX/#partition-header","title":"Partition Header","text":"<p>For each offset, add the offset of the partition.</p> Offset Length Type Information 0x0 0x4 ascii string Partition magic (XTAF) 0x4 0x4 unsigned int Partition ID 0x8 0x4 unsigned int Sectors per Cluster 0xC 0x4 unsigned int Root directory cluster"},{"location":"System-Software/Systems/FATX/#sysext-partition","title":"SysExt Partition","text":"<p>The SystemUpdate with Kernel-Version 2.0.12611.0 (Kinect-Dashboard) introduced a new system to hold the Kinect-/Avatar related systemfiles. It creates a Partition named \"SysExt\" aka SystemExtended to store these files. You could call it a Sub-Partition or Hidden-Partition as it's a \"Partition inside another Partition\".</p>"},{"location":"System-Software/Systems/FATX/#partition-locations","title":"Partition Locations","text":""},{"location":"System-Software/Systems/FATX/#memory-unit","title":"Memory Unit","text":"Offset Length Information Format 0x0 0x7FF000 System Cache SFCX 0x7FF000 end of drive Data FATX"},{"location":"System-Software/Systems/FATX/#xbox-360-hard-drive","title":"Xbox 360 Hard Drive","text":"Offset Length Information Format 0x2000 0x204 - 0x80000 Security Sector Binary 0x80000 0x80000000 System Cache SFCX 0x80080000 0xA0E30000 Game Cache SFCX 0x10C080000 0xCE30000 SysExt FATX (\"Sub\"-Partition) 0x118EB0000 0x8000000 SysExt2 FATX (\"Sub\"-Partition) 0x120eb0000 0x10000000 Xbox 1 Backwards Compatibility FATX 0x130eb0000 end of drive Data FATX"},{"location":"System-Software/Systems/FATX/#development-kit-hdd-partition-table","title":"Development Kit HDD Partition Table","text":"Offset Length Information Value 0x0 0x4 HDD Header (Devkit identification) 0x00020000 0x4 0x4 ? ? 0x8 0x4 Content Volume sector 0x00633000 (Raw address: 0xC6600000 = 0x633000 * 0x200) 0xC 0x4 Content Volume length (in sectors) variable (real length = var * 0x200) 0x10 0x4 Xbox 360 Dashboard Volume sector 0x005B3000 (Raw address: 0xB6600000 = 0x5B3000 * 0x200) 0x14 0x4 Xbox 360 Dashboard Volume length (in sectors) 0x00080000 (0x10000000 = 0x80000 * 0x200)"},{"location":"System-Software/Systems/FATX/#usb-drive","title":"USB Drive","text":"Offset Length Information Format 0x8000400 0x12000400 System Cache FATX 0x8115200 0x8000000 SysExt (\"Sub\"-Partition) FATX 0x12000400 0xDFFFC00 SysExt2 (\"Sub\"-Partition) FATX 0x20000000 End of Files Data FATX"},{"location":"System-Software/Systems/FATX/#josh-sector","title":"\"Josh\" Sector","text":"<p>The \"Josh\" Sector is located on the 4th sector (0x800). It's purpose is currently unknown. It may be used just to identify the Xbox that previously formatted it.</p> Offset Length Type Information 0x0 0x4 ascii string \"Josh\" magic <p>The Console Security Certificate(Inc 0x80 sig) then,</p> Offset Length Type Information 0x22C 0x24 STFSVolumeDescriptor Cache? 0x250 0x24 STFSVolumeDescriptor Cache? 0x274 0x4 (un?)signed int Unknown 0x278 0x4 (un?)signed int Unknown 0x27C 0x4 unsigned int TitleID(for the first VolumeDescriptor) 0x280 0x4 unsigned int TitleID(for the second VolumeDescriptor) <p>The upper 4 bits in the STFSVolumeDescriptor.Flags seem to always be set (maybe to signify it is cache)</p>"},{"location":"System-Software/Systems/FATX/#security-sector","title":"Security Sector","text":"<p>The Security Sector is used by Microsoft to verify that the harddrive is an original Microsoft product. The Security Sector holds details such as drive sector count, drive serial number and the Microsoft logo (to stop other companies using it)</p> <p>It begins at the 16th sector on the drive (0x2000).</p> Offset Length Type Information 0x0 0x14 ascii string Serial Number 0x14 0x8 ascii string Firmware Revision 0x1C 0x28 ascii string Model Number 0x44 0x14 bytes MS Logo Hash 0x58 0x4 unsigned int (LITTLE ENDIAN) Number of Sectors on drive 0x5C 0x100 bytes RSA Signature 0x200 0x4 signed int MS Logo Size 0x204 MS Logo Size image MS Logo <p>If a Security Sector from a smaller hard drive is used on a bigger one, the Xbox will only see the number of sectors defined in the Security Sector.</p>"},{"location":"System-Software/Systems/FATX/#chainmap-and-directories","title":"Chainmap and directories","text":"<p>To find the offset of the chainmap, take the offset of the position and add 4096 (0x1000) to it. Each entry in the chainmap is either an unsigned int or a unsigned short, depending on the number of clusters inside the partition.</p> <p>To work out the cluster size, take the Sectors per Cluster value and multiply it by 512 (0x200).</p> <p>To work out the number of clusters, divide the partitions size by the cluster size and that's have the number of clusters.</p> <p>If the number of clusters is below 65520 (0xFFF0), then the drive uses 2-byte chainmap entries, otherwise it uses 4-byte chainmap entries. The size of the chainmap is the size of the chainmap entries multiplied by the partitions cluster count.</p> <p>To get a clusters offset, you need to work out the offset of the file data area. This is determined by taking the chainmap offset and adding it's size to it. You then simply times the cluster index (minus 1) by the cluster size and add it to the file data offset.</p> <p>To get a clusters chainmap entrys offset, times the cluster index by the chain map entry size and add that to the chainmap offset.</p>"},{"location":"System-Software/Systems/FATX/#files","title":"Files","text":"<p>The file contents is stored per cluster as indicated by the chainmap and the starting cluster (see below). If the file is larger than one cluster, it is stored in multiple clusters. If the length of the file is not a multiple of the cluster size, then the last cluster is only partially used. If the file covers more than 1 cluster, the next cluster must be determined by finding the current cluster's entry in the chainmap and using the value as the next cluster.</p>"},{"location":"System-Software/Systems/FATX/#directories","title":"Directories","text":"<p>Directories are stored in a tabular format. Because directories are normal files with the \"directory\" bit set, they are allocated in the FAT and may therefore cover multiple clusters. This makes it possible to have many files in one directory.</p> <p>Each entry of the directory table is 64 bytes long.</p> <p>An entry can be set to all 0xFF bytes, which means that this entry is unused and probably marks the end of the directory contents. Used entries are filled as follows:</p> Offset Type Size Description 0x00 byte 1 File name length, or 0xE5 for deleted files 0x01 byte 1 File Attributes 0x02 ASCII string 0x2A file name, padded with either 0x00 or 0xFF bytes 0x2C unsigned int 4 First cluster of file, null/0x00 for empty files 0x30 (un?)signed int 4 File size 0x34 (un?)signed short? 2 Creation date 0x36 (un?)signed short? 2 Creation time 0x38 (un?)signed short? 2 Last write date 0x3A (un?)signed short? 2 Last write time 0x3C (un?)signed short 2 Last access time 0x3E (un?)signed short 2 Last access time <p>The file flags and the date and time fields are in the same format as the one used in the FAT file system. For time, bits 15-11 represent the hour, 10-5 the minutes, 4-0 the seconds. For date, bits 15-9 are the year, 8-5 are the month, 4-0 are the day.</p> <p>The volume bit is unused, the volume label is instead stored in a file \"name.txt\" in the root directory. The contents of this file is big-endian UTF-16 (Unicode string) starting at offset 0x2</p> <p>The following characters are found in XTAF file names from actual disk images:</p> <ul> <li>0x20, 0x24, 0x2e ( SPACE $ . )</li> <li>0x30-0x39 (digits 0-9)</li> <li>0x41-0x5a (letters A-Z)</li> <li>0x5f ( _ )</li> <li>0x61-0x7a (letters a-z)</li> </ul> <p>Unlike the FAT file system, XTAF has no \".\" and \"..\" entries in the directory tables. This means that it's only possible to go to the parent directory by remembering its cluster number.</p>"},{"location":"System-Software/Systems/FATX/#limitations","title":"Limitations","text":"Attribute Limitation Maximum Filename Length 0x2A (42) Maximum Path Length 240 Characters Maximum File Size 4 GB (4294967296 bytes) Maximum File Per Directory 0x1000 (4096) File/Folder Name Characters ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"},{"location":"System-Software/Systems/FATX/#possible-cluster-sizes","title":"Possible cluster sizes","text":"<ul> <li>4 KB (0x1000 bytes, 0x8 sectors per cluster)</li> <li>8 KB (0x2000, 0x10 SPC)</li> <li>16 KB (0x4000, 0x20 SPC)</li> <li>32 KB (0x8000, 0x40 SPC)</li> <li>64 KB (0x10000, 0x80 SPC)</li> </ul> <p>System Software</p>"},{"location":"System-Software/Systems/GDFX/","title":"GDFX","text":"<p>Used in Disks and SVOD devices, except when in SVOD format it seems to have extra sectors containing a hash of 2 segments(4098 bytes). Each segment is 2048 bytes.</p> <p>The first segment starts with 440816472(Little endian).</p> <p>The 32nd segment seems to be a descriptor.</p> Offset Length Type Information 0 20 string \"MICROSOFT*XBOX*MEDIA\" 20 4 int Root Sector 24 4 int Root Size 28 8 FileTime Creation Time"},{"location":"System-Software/Systems/GDFX/#directory","title":"Directory","text":"Offset Length Type Information 0 2 int unk 2 2 int unk 4 4 int Sector 8 4 int Size 12 1 int Flags? 13 1 int namelength 14 namelength string name"},{"location":"System-Software/Systems/GDFX/#dirent-attributes","title":"Dirent Attributes","text":"Flag Bitmask READONLY 0x00000001 HIDDEN 0x00000002 SYSTEM 0x00000004 DIRECTORY 0x00000010 ARCHIVE 0x00000020 DEVICE 0x00000040 NORMAL 0x00000080 TEMPORARY 0x00000100 <p>System Software</p>"},{"location":"Xbox-360-Homebrew/Apps/XMPlayer/","title":"XMPlayer","text":""},{"location":"Xbox-360-Homebrew/Apps/XMPlayer/#nfo","title":"NFO","text":"<pre><code>XMPlayer 0.0.1 - June 17, 2012\n--------------\n\nAfter some long weeks of work, this XMPlayer for 360\n\n================================================================================\nWebsite &amp; Donate\n================================================================================\nCed2911\n\nhttps://www.paypal.com/cgi-bin/websc...if%3aNonHosted\n\n================================================================================\nWhat it does\n================================================================================\n- Play video from usb, hard drive and disc drive\n- Support for ext2fs, ntfs, fat, xtaf and iso9660 partition\n- French and english translation\n- Launch elf from every media\n\n================================================================================\nWhat it does not do\n================================================================================\n- Some 1080p are playing, some doesn't\n- No network support\n- No control when playing music files\n- No picture viewer\n\n================================================================================\nKnow issues\n================================================================================\n- Slowdown when using vsync\n- XTAF support is experimental\n\n================================================================================\nWhat to do next\n================================================================================\n- More tranlastions\n- Nand flasher/dumper\n- Nand fs\n- Network support (http, youtube, update)\n- More performance\n\n================================================================================\nInstall\n================================================================================\n- Copy all files at the root of an usb stick, launch it by xell or latest dashlaunch\n\nThanks to\nAioros\ncancerous\nGliGli\nIceKiller\nJuvenal\nNatelx\nRazkar\nsk1080\ntuxuser\n[c0z]\n</code></pre> <p>Category: Homebrew Software</p>"},{"location":"Xbox-360-Homebrew/PC-Software/","title":"PC Software","text":""},{"location":"Xbox-360-Homebrew/PC-Software/#nand-tools","title":"NAND Tools","text":""},{"location":"Xbox-360-Homebrew/PC-Software/#nandcompare","title":"NandCompare","text":""},{"location":"Xbox-360-Homebrew/PC-Software/#description","title":"Description:","text":"<p>Check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps.</p> <p>Author: Rab at XBH</p>"},{"location":"Xbox-360-Homebrew/PC-Software/#download","title":"Download:","text":"<ul> <li>v1.3</li> </ul>"},{"location":"Xbox-360-Homebrew/PC-Software/#nandpro","title":"NandPro","text":""},{"location":"Xbox-360-Homebrew/PC-Software/#description_1","title":"Description:","text":"<p>Read/write NAND dumps and repair the spare bytes / ECC sections.</p> <p>Author: Tiros at XBH</p>"},{"location":"Xbox-360-Homebrew/PC-Software/#download_1","title":"Download:","text":"<ul> <li>xbins </li> <li>360-HQ</li> </ul>"},{"location":"Xbox-360-Homebrew/PC-Software/#360flashtool","title":"360FlashTool","text":""},{"location":"Xbox-360-Homebrew/PC-Software/#description_2","title":"Description:","text":"<p>Decrypt and extract various parts of an Xbox NAND dump.</p> <p>Author: Robinsod, TheSpecialist and SeventhSon at XBH</p> <p>Since Robinsod released the source of \"360 Flash Dump Tool\" and stopped developing a couple of people (Redline99, Tiros and MODFREAKz) decided to continue develop this great app.</p>"},{"location":"Xbox-360-Homebrew/PC-Software/#download_2","title":"Download:","text":"<ul> <li>0.97</li> </ul>"},{"location":"Xbox-360-Homebrew/PC-Software/#nandfs","title":"NANDFS","text":"<p>Description: Add/remove/extract files from a NAND dump. Open source.</p> <p>Author: [stoker25], based on 360 Flash Tool source by Robinsod.</p>"},{"location":"Xbox-360-Homebrew/PC-Software/#download_3","title":"Download:","text":"<ul> <li>v.45d binaries</li> <li>v.45d source</li> </ul>"},{"location":"Xbox-360-Homebrew/PC-Software/#pc-utilities","title":"PC Utilities","text":"Title Description NandCompare Check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps. NANDPro Read/write NAND dumps and repair the spare bytes / ECC sections. It can also flash CPLDs or log POST-Codes. 360FlashTool Display, Decrypt and extract various parts of an Xbox NAND dump. <p>Category: Homebrew Software</p>"},{"location":"Xbox-360-Homebrew/PC-Software/List_of_PC_utilities/","title":"List of PC utilities","text":"<p>Category: Homebrew Software</p>"}]}